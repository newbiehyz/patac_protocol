// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: parking_slot.proto

#ifndef PROTOBUF_parking_5fslot_2eproto__INCLUDED
#define PROTOBUF_parking_5fslot_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_parking_5fslot_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsCornerInfoImpl();
void InitDefaultsCornerInfo();
void InitDefaultsPoseInfoImpl();
void InitDefaultsPoseInfo();
void InitDefaultsParkingRodInfoImpl();
void InitDefaultsParkingRodInfo();
void InitDefaultsParkingLockInfoImpl();
void InitDefaultsParkingLockInfo();
void InitDefaultsBoundaryInfoImpl();
void InitDefaultsBoundaryInfo();
void InitDefaultsParkingSlotInfoImpl();
void InitDefaultsParkingSlotInfo();
inline void InitDefaults() {
  InitDefaultsCornerInfo();
  InitDefaultsPoseInfo();
  InitDefaultsParkingRodInfo();
  InitDefaultsParkingLockInfo();
  InitDefaultsBoundaryInfo();
  InitDefaultsParkingSlotInfo();
}
}  // namespace protobuf_parking_5fslot_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
namespace parking_slot {
class BoundaryInfo;
class BoundaryInfoDefaultTypeInternal;
extern BoundaryInfoDefaultTypeInternal _BoundaryInfo_default_instance_;
class CornerInfo;
class CornerInfoDefaultTypeInternal;
extern CornerInfoDefaultTypeInternal _CornerInfo_default_instance_;
class ParkingLockInfo;
class ParkingLockInfoDefaultTypeInternal;
extern ParkingLockInfoDefaultTypeInternal _ParkingLockInfo_default_instance_;
class ParkingRodInfo;
class ParkingRodInfoDefaultTypeInternal;
extern ParkingRodInfoDefaultTypeInternal _ParkingRodInfo_default_instance_;
class ParkingSlotInfo;
class ParkingSlotInfoDefaultTypeInternal;
extern ParkingSlotInfoDefaultTypeInternal _ParkingSlotInfo_default_instance_;
class PoseInfo;
class PoseInfoDefaultTypeInternal;
extern PoseInfoDefaultTypeInternal _PoseInfo_default_instance_;
}  // namespace parking_slot
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {
namespace parking_slot {

enum ParkingType {
  kParkingTypeUnknown = 0,
  kParkingTypeVertical = 1,
  kParkingTypeParallel = 2,
  kParkingTypeOblique = 3,
  ParkingType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParkingType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParkingType_IsValid(int value);
const ParkingType ParkingType_MIN = kParkingTypeUnknown;
const ParkingType ParkingType_MAX = kParkingTypeOblique;
const int ParkingType_ARRAYSIZE = ParkingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParkingType_descriptor();
inline const ::std::string& ParkingType_Name(ParkingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParkingType_descriptor(), value);
}
inline bool ParkingType_Parse(
    const ::std::string& name, ParkingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParkingType>(
    ParkingType_descriptor(), name, value);
}
enum OccupancyStatus {
  kOccupancyStatusUnknown = 0,
  kOccupancyStatusOccupied = 1,
  kOccupancyStatusNotOccupied = 2,
  OccupancyStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OccupancyStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OccupancyStatus_IsValid(int value);
const OccupancyStatus OccupancyStatus_MIN = kOccupancyStatusUnknown;
const OccupancyStatus OccupancyStatus_MAX = kOccupancyStatusNotOccupied;
const int OccupancyStatus_ARRAYSIZE = OccupancyStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* OccupancyStatus_descriptor();
inline const ::std::string& OccupancyStatus_Name(OccupancyStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    OccupancyStatus_descriptor(), value);
}
inline bool OccupancyStatus_Parse(
    const ::std::string& name, OccupancyStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OccupancyStatus>(
    OccupancyStatus_descriptor(), name, value);
}
enum ParkingSource {
  kParkingSourceUnspecified = 0,
  kParkingSourceIpm = 1,
  kParkingSourceUss = 2,
  kParkingSourceUserSel = 3,
  ParkingSource_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParkingSource_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParkingSource_IsValid(int value);
const ParkingSource ParkingSource_MIN = kParkingSourceUnspecified;
const ParkingSource ParkingSource_MAX = kParkingSourceUserSel;
const int ParkingSource_ARRAYSIZE = ParkingSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParkingSource_descriptor();
inline const ::std::string& ParkingSource_Name(ParkingSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParkingSource_descriptor(), value);
}
inline bool ParkingSource_Parse(
    const ::std::string& name, ParkingSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParkingSource>(
    ParkingSource_descriptor(), name, value);
}
enum ParkingStage {
  kParkingStageUninit = 0,
  kParkingStageUnconverged = 1,
  kParkingStageConverged = 2,
  kParkingStageUpdateError = 3,
  kParkingStageLost = 4,
  kParkingStageFixed = 5,
  ParkingStage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParkingStage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParkingStage_IsValid(int value);
const ParkingStage ParkingStage_MIN = kParkingStageUninit;
const ParkingStage ParkingStage_MAX = kParkingStageFixed;
const int ParkingStage_ARRAYSIZE = ParkingStage_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParkingStage_descriptor();
inline const ::std::string& ParkingStage_Name(ParkingStage value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParkingStage_descriptor(), value);
}
inline bool ParkingStage_Parse(
    const ::std::string& name, ParkingStage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParkingStage>(
    ParkingStage_descriptor(), name, value);
}
enum ParkingLockStatus {
  kParkingLockStatusUnknown = 0,
  kParkingLockStatusOpen = 1,
  kParkingLockStatusClose = 2,
  ParkingLockStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParkingLockStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParkingLockStatus_IsValid(int value);
const ParkingLockStatus ParkingLockStatus_MIN = kParkingLockStatusUnknown;
const ParkingLockStatus ParkingLockStatus_MAX = kParkingLockStatusClose;
const int ParkingLockStatus_ARRAYSIZE = ParkingLockStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParkingLockStatus_descriptor();
inline const ::std::string& ParkingLockStatus_Name(ParkingLockStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParkingLockStatus_descriptor(), value);
}
inline bool ParkingLockStatus_Parse(
    const ::std::string& name, ParkingLockStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParkingLockStatus>(
    ParkingLockStatus_descriptor(), name, value);
}
enum BoundaryStatus {
  kBoundaryStatusUnspecified = 0,
  kBoundaryStatusLow = 1,
  kBoundaryStatusHigh = 2,
  kBoundaryStatusMid = 3,
  BoundaryStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BoundaryStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BoundaryStatus_IsValid(int value);
const BoundaryStatus BoundaryStatus_MIN = kBoundaryStatusUnspecified;
const BoundaryStatus BoundaryStatus_MAX = kBoundaryStatusMid;
const int BoundaryStatus_ARRAYSIZE = BoundaryStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* BoundaryStatus_descriptor();
inline const ::std::string& BoundaryStatus_Name(BoundaryStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    BoundaryStatus_descriptor(), value);
}
inline bool BoundaryStatus_Parse(
    const ::std::string& name, BoundaryStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BoundaryStatus>(
    BoundaryStatus_descriptor(), name, value);
}
enum BoundaryFixStatus {
  kBoundaryFixStatusUnspecified = 0,
  kBoundaryFixStatusUnfixed = 1,
  kBoundaryFixStatusFixed = 2,
  BoundaryFixStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BoundaryFixStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BoundaryFixStatus_IsValid(int value);
const BoundaryFixStatus BoundaryFixStatus_MIN = kBoundaryFixStatusUnspecified;
const BoundaryFixStatus BoundaryFixStatus_MAX = kBoundaryFixStatusFixed;
const int BoundaryFixStatus_ARRAYSIZE = BoundaryFixStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* BoundaryFixStatus_descriptor();
inline const ::std::string& BoundaryFixStatus_Name(BoundaryFixStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    BoundaryFixStatus_descriptor(), value);
}
inline bool BoundaryFixStatus_Parse(
    const ::std::string& name, BoundaryFixStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BoundaryFixStatus>(
    BoundaryFixStatus_descriptor(), name, value);
}
enum OccupyObjType {
  kOccupyObjTypeVehicle = 0,
  kOccupyObjTypePedestrain = 1,
  kOccupyObjTypeCyclist = 2,
  kOccupyObjTypeAnimal = 3,
  kOccupyObjTypeTrafficCone = 50,
  kOccupyObjTypeCementColumn = 51,
  kOccupyObjTypeParkingLock = 52,
  kOccupyObjTypeAFrameSign = 53,
  kOccupyObjTypeCurb = 54,
  kOccupyObjTypeFence = 55,
  kOccupyObjTypeWaterBarrier = 56,
  kOccupyObjTypeTrolley = 57,
  kOccupyObjTypeWall = 58,
  kOccupyObjTypeUnknown = 100,
  OccupyObjType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OccupyObjType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OccupyObjType_IsValid(int value);
const OccupyObjType OccupyObjType_MIN = kOccupyObjTypeVehicle;
const OccupyObjType OccupyObjType_MAX = kOccupyObjTypeUnknown;
const int OccupyObjType_ARRAYSIZE = OccupyObjType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OccupyObjType_descriptor();
inline const ::std::string& OccupyObjType_Name(OccupyObjType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OccupyObjType_descriptor(), value);
}
inline bool OccupyObjType_Parse(
    const ::std::string& name, OccupyObjType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OccupyObjType>(
    OccupyObjType_descriptor(), name, value);
}
enum ParkingReleaseMode {
  kNoneMode = 0,
  kRealTime = 1,
  kTracking = 2,
  ParkingReleaseMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParkingReleaseMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParkingReleaseMode_IsValid(int value);
const ParkingReleaseMode ParkingReleaseMode_MIN = kNoneMode;
const ParkingReleaseMode ParkingReleaseMode_MAX = kTracking;
const int ParkingReleaseMode_ARRAYSIZE = ParkingReleaseMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParkingReleaseMode_descriptor();
inline const ::std::string& ParkingReleaseMode_Name(ParkingReleaseMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParkingReleaseMode_descriptor(), value);
}
inline bool ParkingReleaseMode_Parse(
    const ::std::string& name, ParkingReleaseMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParkingReleaseMode>(
    ParkingReleaseMode_descriptor(), name, value);
}
// ===================================================================

class CornerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.parking_slot.CornerInfo) */ {
 public:
  CornerInfo();
  virtual ~CornerInfo();

  CornerInfo(const CornerInfo& from);

  inline CornerInfo& operator=(const CornerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CornerInfo(CornerInfo&& from) noexcept
    : CornerInfo() {
    *this = ::std::move(from);
  }

  inline CornerInfo& operator=(CornerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CornerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CornerInfo* internal_default_instance() {
    return reinterpret_cast<const CornerInfo*>(
               &_CornerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CornerInfo* other);
  friend void swap(CornerInfo& a, CornerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CornerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CornerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CornerInfo& from);
  void MergeFrom(const CornerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CornerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.Vector3f point_vcs = 1;
  bool has_point_vcs() const;
  void clear_point_vcs();
  static const int kPointVcsFieldNumber = 1;
  const ::autodrive::workflow::proto::Vector3f& point_vcs() const;
  ::autodrive::workflow::proto::Vector3f* release_point_vcs();
  ::autodrive::workflow::proto::Vector3f* mutable_point_vcs();
  void set_allocated_point_vcs(::autodrive::workflow::proto::Vector3f* point_vcs);

  // .autodrive.workflow.proto.Vector3f point_world = 2;
  bool has_point_world() const;
  void clear_point_world();
  static const int kPointWorldFieldNumber = 2;
  const ::autodrive::workflow::proto::Vector3f& point_world() const;
  ::autodrive::workflow::proto::Vector3f* release_point_world();
  ::autodrive::workflow::proto::Vector3f* mutable_point_world();
  void set_allocated_point_world(::autodrive::workflow::proto::Vector3f* point_world);

  // .autodrive.workflow.proto.Vector3f point_cov = 3;
  bool has_point_cov() const;
  void clear_point_cov();
  static const int kPointCovFieldNumber = 3;
  const ::autodrive::workflow::proto::Vector3f& point_cov() const;
  ::autodrive::workflow::proto::Vector3f* release_point_cov();
  ::autodrive::workflow::proto::Vector3f* mutable_point_cov();
  void set_allocated_point_cov(::autodrive::workflow::proto::Vector3f* point_cov);

  // bool valid = 4;
  void clear_valid();
  static const int kValidFieldNumber = 4;
  bool valid() const;
  void set_valid(bool value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.parking_slot.CornerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::Vector3f* point_vcs_;
  ::autodrive::workflow::proto::Vector3f* point_world_;
  ::autodrive::workflow::proto::Vector3f* point_cov_;
  bool valid_;
  mutable int _cached_size_;
  friend struct ::protobuf_parking_5fslot_2eproto::TableStruct;
  friend void ::protobuf_parking_5fslot_2eproto::InitDefaultsCornerInfoImpl();
};
// -------------------------------------------------------------------

class PoseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.parking_slot.PoseInfo) */ {
 public:
  PoseInfo();
  virtual ~PoseInfo();

  PoseInfo(const PoseInfo& from);

  inline PoseInfo& operator=(const PoseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoseInfo(PoseInfo&& from) noexcept
    : PoseInfo() {
    *this = ::std::move(from);
  }

  inline PoseInfo& operator=(PoseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PoseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoseInfo* internal_default_instance() {
    return reinterpret_cast<const PoseInfo*>(
               &_PoseInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PoseInfo* other);
  friend void swap(PoseInfo& a, PoseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PoseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PoseInfo& from);
  void MergeFrom(const PoseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PoseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.Vector3f corners_vcs = 9;
  int corners_vcs_size() const;
  void clear_corners_vcs();
  static const int kCornersVcsFieldNumber = 9;
  const ::autodrive::workflow::proto::Vector3f& corners_vcs(int index) const;
  ::autodrive::workflow::proto::Vector3f* mutable_corners_vcs(int index);
  ::autodrive::workflow::proto::Vector3f* add_corners_vcs();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
      mutable_corners_vcs();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
      corners_vcs() const;

  // repeated .autodrive.workflow.proto.Vector3f corners_world = 10;
  int corners_world_size() const;
  void clear_corners_world();
  static const int kCornersWorldFieldNumber = 10;
  const ::autodrive::workflow::proto::Vector3f& corners_world(int index) const;
  ::autodrive::workflow::proto::Vector3f* mutable_corners_world(int index);
  ::autodrive::workflow::proto::Vector3f* add_corners_world();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
      mutable_corners_world();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
      corners_world() const;

  // .autodrive.workflow.proto.Vector3f position_vcs = 1;
  bool has_position_vcs() const;
  void clear_position_vcs();
  static const int kPositionVcsFieldNumber = 1;
  const ::autodrive::workflow::proto::Vector3f& position_vcs() const;
  ::autodrive::workflow::proto::Vector3f* release_position_vcs();
  ::autodrive::workflow::proto::Vector3f* mutable_position_vcs();
  void set_allocated_position_vcs(::autodrive::workflow::proto::Vector3f* position_vcs);

  // .autodrive.workflow.proto.Vector3f position_world = 2;
  bool has_position_world() const;
  void clear_position_world();
  static const int kPositionWorldFieldNumber = 2;
  const ::autodrive::workflow::proto::Vector3f& position_world() const;
  ::autodrive::workflow::proto::Vector3f* release_position_world();
  ::autodrive::workflow::proto::Vector3f* mutable_position_world();
  void set_allocated_position_world(::autodrive::workflow::proto::Vector3f* position_world);

  // float length = 3;
  void clear_length();
  static const int kLengthFieldNumber = 3;
  float length() const;
  void set_length(float value);

  // float width = 4;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  float width() const;
  void set_width(float value);

  // float yaw_vcs = 5;
  void clear_yaw_vcs();
  static const int kYawVcsFieldNumber = 5;
  float yaw_vcs() const;
  void set_yaw_vcs(float value);

  // float yaw_world = 6;
  void clear_yaw_world();
  static const int kYawWorldFieldNumber = 6;
  float yaw_world() const;
  void set_yaw_world(float value);

  // float alpha_vcs = 7;
  void clear_alpha_vcs();
  static const int kAlphaVcsFieldNumber = 7;
  float alpha_vcs() const;
  void set_alpha_vcs(float value);

  // float alpha_world = 8;
  void clear_alpha_world();
  static const int kAlphaWorldFieldNumber = 8;
  float alpha_world() const;
  void set_alpha_world(float value);

  // float slotline_w0 = 11;
  void clear_slotline_w0();
  static const int kSlotlineW0FieldNumber = 11;
  float slotline_w0() const;
  void set_slotline_w0(float value);

  // float slotline_w1 = 12;
  void clear_slotline_w1();
  static const int kSlotlineW1FieldNumber = 12;
  float slotline_w1() const;
  void set_slotline_w1(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.parking_slot.PoseInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f > corners_vcs_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f > corners_world_;
  ::autodrive::workflow::proto::Vector3f* position_vcs_;
  ::autodrive::workflow::proto::Vector3f* position_world_;
  float length_;
  float width_;
  float yaw_vcs_;
  float yaw_world_;
  float alpha_vcs_;
  float alpha_world_;
  float slotline_w0_;
  float slotline_w1_;
  mutable int _cached_size_;
  friend struct ::protobuf_parking_5fslot_2eproto::TableStruct;
  friend void ::protobuf_parking_5fslot_2eproto::InitDefaultsPoseInfoImpl();
};
// -------------------------------------------------------------------

class ParkingRodInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.parking_slot.ParkingRodInfo) */ {
 public:
  ParkingRodInfo();
  virtual ~ParkingRodInfo();

  ParkingRodInfo(const ParkingRodInfo& from);

  inline ParkingRodInfo& operator=(const ParkingRodInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingRodInfo(ParkingRodInfo&& from) noexcept
    : ParkingRodInfo() {
    *this = ::std::move(from);
  }

  inline ParkingRodInfo& operator=(ParkingRodInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingRodInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingRodInfo* internal_default_instance() {
    return reinterpret_cast<const ParkingRodInfo*>(
               &_ParkingRodInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ParkingRodInfo* other);
  friend void swap(ParkingRodInfo& a, ParkingRodInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingRodInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingRodInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingRodInfo& from);
  void MergeFrom(const ParkingRodInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingRodInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.Vector3f end_points_vcs = 1;
  int end_points_vcs_size() const;
  void clear_end_points_vcs();
  static const int kEndPointsVcsFieldNumber = 1;
  const ::autodrive::workflow::proto::Vector3f& end_points_vcs(int index) const;
  ::autodrive::workflow::proto::Vector3f* mutable_end_points_vcs(int index);
  ::autodrive::workflow::proto::Vector3f* add_end_points_vcs();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
      mutable_end_points_vcs();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
      end_points_vcs() const;

  // repeated .autodrive.workflow.proto.Vector3f end_points_world = 2;
  int end_points_world_size() const;
  void clear_end_points_world();
  static const int kEndPointsWorldFieldNumber = 2;
  const ::autodrive::workflow::proto::Vector3f& end_points_world(int index) const;
  ::autodrive::workflow::proto::Vector3f* mutable_end_points_world(int index);
  ::autodrive::workflow::proto::Vector3f* add_end_points_world();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
      mutable_end_points_world();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
      end_points_world() const;

  // bool valid = 3;
  void clear_valid();
  static const int kValidFieldNumber = 3;
  bool valid() const;
  void set_valid(bool value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f > end_points_vcs_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f > end_points_world_;
  bool valid_;
  mutable int _cached_size_;
  friend struct ::protobuf_parking_5fslot_2eproto::TableStruct;
  friend void ::protobuf_parking_5fslot_2eproto::InitDefaultsParkingRodInfoImpl();
};
// -------------------------------------------------------------------

class ParkingLockInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.parking_slot.ParkingLockInfo) */ {
 public:
  ParkingLockInfo();
  virtual ~ParkingLockInfo();

  ParkingLockInfo(const ParkingLockInfo& from);

  inline ParkingLockInfo& operator=(const ParkingLockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingLockInfo(ParkingLockInfo&& from) noexcept
    : ParkingLockInfo() {
    *this = ::std::move(from);
  }

  inline ParkingLockInfo& operator=(ParkingLockInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingLockInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingLockInfo* internal_default_instance() {
    return reinterpret_cast<const ParkingLockInfo*>(
               &_ParkingLockInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ParkingLockInfo* other);
  friend void swap(ParkingLockInfo& a, ParkingLockInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingLockInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingLockInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingLockInfo& from);
  void MergeFrom(const ParkingLockInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingLockInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.Vector3f point_vcs = 1;
  bool has_point_vcs() const;
  void clear_point_vcs();
  static const int kPointVcsFieldNumber = 1;
  const ::autodrive::workflow::proto::Vector3f& point_vcs() const;
  ::autodrive::workflow::proto::Vector3f* release_point_vcs();
  ::autodrive::workflow::proto::Vector3f* mutable_point_vcs();
  void set_allocated_point_vcs(::autodrive::workflow::proto::Vector3f* point_vcs);

  // .autodrive.workflow.proto.Vector3f point_world = 2;
  bool has_point_world() const;
  void clear_point_world();
  static const int kPointWorldFieldNumber = 2;
  const ::autodrive::workflow::proto::Vector3f& point_world() const;
  ::autodrive::workflow::proto::Vector3f* release_point_world();
  ::autodrive::workflow::proto::Vector3f* mutable_point_world();
  void set_allocated_point_world(::autodrive::workflow::proto::Vector3f* point_world);

  // .autodrive.workflow.proto.parking_slot.ParkingLockStatus parking_status = 3;
  void clear_parking_status();
  static const int kParkingStatusFieldNumber = 3;
  ::autodrive::workflow::proto::parking_slot::ParkingLockStatus parking_status() const;
  void set_parking_status(::autodrive::workflow::proto::parking_slot::ParkingLockStatus value);

  // bool valid = 4;
  void clear_valid();
  static const int kValidFieldNumber = 4;
  bool valid() const;
  void set_valid(bool value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::Vector3f* point_vcs_;
  ::autodrive::workflow::proto::Vector3f* point_world_;
  int parking_status_;
  bool valid_;
  mutable int _cached_size_;
  friend struct ::protobuf_parking_5fslot_2eproto::TableStruct;
  friend void ::protobuf_parking_5fslot_2eproto::InitDefaultsParkingLockInfoImpl();
};
// -------------------------------------------------------------------

class BoundaryInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.parking_slot.BoundaryInfo) */ {
 public:
  BoundaryInfo();
  virtual ~BoundaryInfo();

  BoundaryInfo(const BoundaryInfo& from);

  inline BoundaryInfo& operator=(const BoundaryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoundaryInfo(BoundaryInfo&& from) noexcept
    : BoundaryInfo() {
    *this = ::std::move(from);
  }

  inline BoundaryInfo& operator=(BoundaryInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundaryInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundaryInfo* internal_default_instance() {
    return reinterpret_cast<const BoundaryInfo*>(
               &_BoundaryInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(BoundaryInfo* other);
  friend void swap(BoundaryInfo& a, BoundaryInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoundaryInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  BoundaryInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BoundaryInfo& from);
  void MergeFrom(const BoundaryInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BoundaryInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.Vector3f points_vcs = 1;
  int points_vcs_size() const;
  void clear_points_vcs();
  static const int kPointsVcsFieldNumber = 1;
  const ::autodrive::workflow::proto::Vector3f& points_vcs(int index) const;
  ::autodrive::workflow::proto::Vector3f* mutable_points_vcs(int index);
  ::autodrive::workflow::proto::Vector3f* add_points_vcs();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
      mutable_points_vcs();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
      points_vcs() const;

  // repeated .autodrive.workflow.proto.Vector3f points_world = 2;
  int points_world_size() const;
  void clear_points_world();
  static const int kPointsWorldFieldNumber = 2;
  const ::autodrive::workflow::proto::Vector3f& points_world(int index) const;
  ::autodrive::workflow::proto::Vector3f* mutable_points_world(int index);
  ::autodrive::workflow::proto::Vector3f* add_points_world();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
      mutable_points_world();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
      points_world() const;

  // repeated .autodrive.workflow.proto.parking_slot.BoundaryStatus boundaries_status = 3;
  int boundaries_status_size() const;
  void clear_boundaries_status();
  static const int kBoundariesStatusFieldNumber = 3;
  ::autodrive::workflow::proto::parking_slot::BoundaryStatus boundaries_status(int index) const;
  void set_boundaries_status(int index, ::autodrive::workflow::proto::parking_slot::BoundaryStatus value);
  void add_boundaries_status(::autodrive::workflow::proto::parking_slot::BoundaryStatus value);
  const ::google::protobuf::RepeatedField<int>& boundaries_status() const;
  ::google::protobuf::RepeatedField<int>* mutable_boundaries_status();

  // repeated float boundaries_height = 4;
  int boundaries_height_size() const;
  void clear_boundaries_height();
  static const int kBoundariesHeightFieldNumber = 4;
  float boundaries_height(int index) const;
  void set_boundaries_height(int index, float value);
  void add_boundaries_height(float value);
  const ::google::protobuf::RepeatedField< float >&
      boundaries_height() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_boundaries_height();

  // repeated .autodrive.workflow.proto.parking_slot.BoundaryFixStatus boundaries_fix_status = 5;
  int boundaries_fix_status_size() const;
  void clear_boundaries_fix_status();
  static const int kBoundariesFixStatusFieldNumber = 5;
  ::autodrive::workflow::proto::parking_slot::BoundaryFixStatus boundaries_fix_status(int index) const;
  void set_boundaries_fix_status(int index, ::autodrive::workflow::proto::parking_slot::BoundaryFixStatus value);
  void add_boundaries_fix_status(::autodrive::workflow::proto::parking_slot::BoundaryFixStatus value);
  const ::google::protobuf::RepeatedField<int>& boundaries_fix_status() const;
  ::google::protobuf::RepeatedField<int>* mutable_boundaries_fix_status();

  // repeated .autodrive.workflow.proto.Vector3f points_delta_ss = 6;
  int points_delta_ss_size() const;
  void clear_points_delta_ss();
  static const int kPointsDeltaSsFieldNumber = 6;
  const ::autodrive::workflow::proto::Vector3f& points_delta_ss(int index) const;
  ::autodrive::workflow::proto::Vector3f* mutable_points_delta_ss(int index);
  ::autodrive::workflow::proto::Vector3f* add_points_delta_ss();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
      mutable_points_delta_ss();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
      points_delta_ss() const;

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.parking_slot.BoundaryInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f > points_vcs_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f > points_world_;
  ::google::protobuf::RepeatedField<int> boundaries_status_;
  mutable int _boundaries_status_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > boundaries_height_;
  mutable int _boundaries_height_cached_byte_size_;
  ::google::protobuf::RepeatedField<int> boundaries_fix_status_;
  mutable int _boundaries_fix_status_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f > points_delta_ss_;
  mutable int _cached_size_;
  friend struct ::protobuf_parking_5fslot_2eproto::TableStruct;
  friend void ::protobuf_parking_5fslot_2eproto::InitDefaultsBoundaryInfoImpl();
};
// -------------------------------------------------------------------

class ParkingSlotInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.parking_slot.ParkingSlotInfo) */ {
 public:
  ParkingSlotInfo();
  virtual ~ParkingSlotInfo();

  ParkingSlotInfo(const ParkingSlotInfo& from);

  inline ParkingSlotInfo& operator=(const ParkingSlotInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingSlotInfo(ParkingSlotInfo&& from) noexcept
    : ParkingSlotInfo() {
    *this = ::std::move(from);
  }

  inline ParkingSlotInfo& operator=(ParkingSlotInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSlotInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingSlotInfo* internal_default_instance() {
    return reinterpret_cast<const ParkingSlotInfo*>(
               &_ParkingSlotInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ParkingSlotInfo* other);
  friend void swap(ParkingSlotInfo& a, ParkingSlotInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingSlotInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSlotInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSlotInfo& from);
  void MergeFrom(const ParkingSlotInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSlotInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.parking_slot.CornerInfo polygon_points = 4;
  int polygon_points_size() const;
  void clear_polygon_points();
  static const int kPolygonPointsFieldNumber = 4;
  const ::autodrive::workflow::proto::parking_slot::CornerInfo& polygon_points(int index) const;
  ::autodrive::workflow::proto::parking_slot::CornerInfo* mutable_polygon_points(int index);
  ::autodrive::workflow::proto::parking_slot::CornerInfo* add_polygon_points();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::parking_slot::CornerInfo >*
      mutable_polygon_points();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::parking_slot::CornerInfo >&
      polygon_points() const;

  // string str_id = 14;
  void clear_str_id();
  static const int kStrIdFieldNumber = 14;
  const ::std::string& str_id() const;
  void set_str_id(const ::std::string& value);
  #if LANG_CXX11
  void set_str_id(::std::string&& value);
  #endif
  void set_str_id(const char* value);
  void set_str_id(const char* value, size_t size);
  ::std::string* mutable_str_id();
  ::std::string* release_str_id();
  void set_allocated_str_id(::std::string* str_id);

  // .autodrive.workflow.proto.parking_slot.PoseInfo pose = 5;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 5;
  const ::autodrive::workflow::proto::parking_slot::PoseInfo& pose() const;
  ::autodrive::workflow::proto::parking_slot::PoseInfo* release_pose();
  ::autodrive::workflow::proto::parking_slot::PoseInfo* mutable_pose();
  void set_allocated_pose(::autodrive::workflow::proto::parking_slot::PoseInfo* pose);

  // .autodrive.workflow.proto.parking_slot.ParkingRodInfo parking_rod = 6;
  bool has_parking_rod() const;
  void clear_parking_rod();
  static const int kParkingRodFieldNumber = 6;
  const ::autodrive::workflow::proto::parking_slot::ParkingRodInfo& parking_rod() const;
  ::autodrive::workflow::proto::parking_slot::ParkingRodInfo* release_parking_rod();
  ::autodrive::workflow::proto::parking_slot::ParkingRodInfo* mutable_parking_rod();
  void set_allocated_parking_rod(::autodrive::workflow::proto::parking_slot::ParkingRodInfo* parking_rod);

  // .autodrive.workflow.proto.parking_slot.ParkingLockInfo parking_lock_info = 7;
  bool has_parking_lock_info() const;
  void clear_parking_lock_info();
  static const int kParkingLockInfoFieldNumber = 7;
  const ::autodrive::workflow::proto::parking_slot::ParkingLockInfo& parking_lock_info() const;
  ::autodrive::workflow::proto::parking_slot::ParkingLockInfo* release_parking_lock_info();
  ::autodrive::workflow::proto::parking_slot::ParkingLockInfo* mutable_parking_lock_info();
  void set_allocated_parking_lock_info(::autodrive::workflow::proto::parking_slot::ParkingLockInfo* parking_lock_info);

  // .autodrive.workflow.proto.parking_slot.BoundaryInfo boundary = 8;
  bool has_boundary() const;
  void clear_boundary();
  static const int kBoundaryFieldNumber = 8;
  const ::autodrive::workflow::proto::parking_slot::BoundaryInfo& boundary() const;
  ::autodrive::workflow::proto::parking_slot::BoundaryInfo* release_boundary();
  ::autodrive::workflow::proto::parking_slot::BoundaryInfo* mutable_boundary();
  void set_allocated_boundary(::autodrive::workflow::proto::parking_slot::BoundaryInfo* boundary);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 valid = 2;
  void clear_valid();
  static const int kValidFieldNumber = 2;
  ::google::protobuf::int32 valid() const;
  void set_valid(::google::protobuf::int32 value);

  // float conf = 3;
  void clear_conf();
  static const int kConfFieldNumber = 3;
  float conf() const;
  void set_conf(float value);

  // .autodrive.workflow.proto.parking_slot.ParkingType type = 9;
  void clear_type();
  static const int kTypeFieldNumber = 9;
  ::autodrive::workflow::proto::parking_slot::ParkingType type() const;
  void set_type(::autodrive::workflow::proto::parking_slot::ParkingType value);

  // .autodrive.workflow.proto.parking_slot.OccupancyStatus occupancy_status = 10;
  void clear_occupancy_status();
  static const int kOccupancyStatusFieldNumber = 10;
  ::autodrive::workflow::proto::parking_slot::OccupancyStatus occupancy_status() const;
  void set_occupancy_status(::autodrive::workflow::proto::parking_slot::OccupancyStatus value);

  // .autodrive.workflow.proto.parking_slot.ParkingSource parking_source = 11;
  void clear_parking_source();
  static const int kParkingSourceFieldNumber = 11;
  ::autodrive::workflow::proto::parking_slot::ParkingSource parking_source() const;
  void set_parking_source(::autodrive::workflow::proto::parking_slot::ParkingSource value);

  // .autodrive.workflow.proto.parking_slot.ParkingStage stage = 12;
  void clear_stage();
  static const int kStageFieldNumber = 12;
  ::autodrive::workflow::proto::parking_slot::ParkingStage stage() const;
  void set_stage(::autodrive::workflow::proto::parking_slot::ParkingStage value);

  // .autodrive.workflow.proto.parking_slot.OccupyObjType occupancy_obs_type = 13;
  void clear_occupancy_obs_type();
  static const int kOccupancyObsTypeFieldNumber = 13;
  ::autodrive::workflow::proto::parking_slot::OccupyObjType occupancy_obs_type() const;
  void set_occupancy_obs_type(::autodrive::workflow::proto::parking_slot::OccupyObjType value);

  // .autodrive.workflow.proto.parking_slot.ParkingReleaseMode parking_release_mode = 15;
  void clear_parking_release_mode();
  static const int kParkingReleaseModeFieldNumber = 15;
  ::autodrive::workflow::proto::parking_slot::ParkingReleaseMode parking_release_mode() const;
  void set_parking_release_mode(::autodrive::workflow::proto::parking_slot::ParkingReleaseMode value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::parking_slot::CornerInfo > polygon_points_;
  ::google::protobuf::internal::ArenaStringPtr str_id_;
  ::autodrive::workflow::proto::parking_slot::PoseInfo* pose_;
  ::autodrive::workflow::proto::parking_slot::ParkingRodInfo* parking_rod_;
  ::autodrive::workflow::proto::parking_slot::ParkingLockInfo* parking_lock_info_;
  ::autodrive::workflow::proto::parking_slot::BoundaryInfo* boundary_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 valid_;
  float conf_;
  int type_;
  int occupancy_status_;
  int parking_source_;
  int stage_;
  int occupancy_obs_type_;
  int parking_release_mode_;
  mutable int _cached_size_;
  friend struct ::protobuf_parking_5fslot_2eproto::TableStruct;
  friend void ::protobuf_parking_5fslot_2eproto::InitDefaultsParkingSlotInfoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CornerInfo

// .autodrive.workflow.proto.Vector3f point_vcs = 1;
inline bool CornerInfo::has_point_vcs() const {
  return this != internal_default_instance() && point_vcs_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& CornerInfo::point_vcs() const {
  const ::autodrive::workflow::proto::Vector3f* p = point_vcs_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.CornerInfo.point_vcs)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* CornerInfo::release_point_vcs() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.CornerInfo.point_vcs)
  
  ::autodrive::workflow::proto::Vector3f* temp = point_vcs_;
  point_vcs_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* CornerInfo::mutable_point_vcs() {
  
  if (point_vcs_ == NULL) {
    point_vcs_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.CornerInfo.point_vcs)
  return point_vcs_;
}
inline void CornerInfo::set_allocated_point_vcs(::autodrive::workflow::proto::Vector3f* point_vcs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(point_vcs_);
  }
  if (point_vcs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point_vcs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point_vcs, submessage_arena);
    }
    
  } else {
    
  }
  point_vcs_ = point_vcs;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.CornerInfo.point_vcs)
}

// .autodrive.workflow.proto.Vector3f point_world = 2;
inline bool CornerInfo::has_point_world() const {
  return this != internal_default_instance() && point_world_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& CornerInfo::point_world() const {
  const ::autodrive::workflow::proto::Vector3f* p = point_world_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.CornerInfo.point_world)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* CornerInfo::release_point_world() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.CornerInfo.point_world)
  
  ::autodrive::workflow::proto::Vector3f* temp = point_world_;
  point_world_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* CornerInfo::mutable_point_world() {
  
  if (point_world_ == NULL) {
    point_world_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.CornerInfo.point_world)
  return point_world_;
}
inline void CornerInfo::set_allocated_point_world(::autodrive::workflow::proto::Vector3f* point_world) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(point_world_);
  }
  if (point_world) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point_world = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point_world, submessage_arena);
    }
    
  } else {
    
  }
  point_world_ = point_world;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.CornerInfo.point_world)
}

// .autodrive.workflow.proto.Vector3f point_cov = 3;
inline bool CornerInfo::has_point_cov() const {
  return this != internal_default_instance() && point_cov_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& CornerInfo::point_cov() const {
  const ::autodrive::workflow::proto::Vector3f* p = point_cov_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.CornerInfo.point_cov)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* CornerInfo::release_point_cov() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.CornerInfo.point_cov)
  
  ::autodrive::workflow::proto::Vector3f* temp = point_cov_;
  point_cov_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* CornerInfo::mutable_point_cov() {
  
  if (point_cov_ == NULL) {
    point_cov_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.CornerInfo.point_cov)
  return point_cov_;
}
inline void CornerInfo::set_allocated_point_cov(::autodrive::workflow::proto::Vector3f* point_cov) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(point_cov_);
  }
  if (point_cov) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point_cov = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point_cov, submessage_arena);
    }
    
  } else {
    
  }
  point_cov_ = point_cov;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.CornerInfo.point_cov)
}

// bool valid = 4;
inline void CornerInfo::clear_valid() {
  valid_ = false;
}
inline bool CornerInfo::valid() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.CornerInfo.valid)
  return valid_;
}
inline void CornerInfo::set_valid(bool value) {
  
  valid_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.CornerInfo.valid)
}

// -------------------------------------------------------------------

// PoseInfo

// .autodrive.workflow.proto.Vector3f position_vcs = 1;
inline bool PoseInfo::has_position_vcs() const {
  return this != internal_default_instance() && position_vcs_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& PoseInfo::position_vcs() const {
  const ::autodrive::workflow::proto::Vector3f* p = position_vcs_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.position_vcs)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* PoseInfo::release_position_vcs() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.PoseInfo.position_vcs)
  
  ::autodrive::workflow::proto::Vector3f* temp = position_vcs_;
  position_vcs_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* PoseInfo::mutable_position_vcs() {
  
  if (position_vcs_ == NULL) {
    position_vcs_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.PoseInfo.position_vcs)
  return position_vcs_;
}
inline void PoseInfo::set_allocated_position_vcs(::autodrive::workflow::proto::Vector3f* position_vcs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_vcs_);
  }
  if (position_vcs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_vcs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_vcs, submessage_arena);
    }
    
  } else {
    
  }
  position_vcs_ = position_vcs;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.PoseInfo.position_vcs)
}

// .autodrive.workflow.proto.Vector3f position_world = 2;
inline bool PoseInfo::has_position_world() const {
  return this != internal_default_instance() && position_world_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& PoseInfo::position_world() const {
  const ::autodrive::workflow::proto::Vector3f* p = position_world_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.position_world)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* PoseInfo::release_position_world() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.PoseInfo.position_world)
  
  ::autodrive::workflow::proto::Vector3f* temp = position_world_;
  position_world_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* PoseInfo::mutable_position_world() {
  
  if (position_world_ == NULL) {
    position_world_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.PoseInfo.position_world)
  return position_world_;
}
inline void PoseInfo::set_allocated_position_world(::autodrive::workflow::proto::Vector3f* position_world) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_world_);
  }
  if (position_world) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_world = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_world, submessage_arena);
    }
    
  } else {
    
  }
  position_world_ = position_world;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.PoseInfo.position_world)
}

// float length = 3;
inline void PoseInfo::clear_length() {
  length_ = 0;
}
inline float PoseInfo::length() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.length)
  return length_;
}
inline void PoseInfo::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.PoseInfo.length)
}

// float width = 4;
inline void PoseInfo::clear_width() {
  width_ = 0;
}
inline float PoseInfo::width() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.width)
  return width_;
}
inline void PoseInfo::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.PoseInfo.width)
}

// float yaw_vcs = 5;
inline void PoseInfo::clear_yaw_vcs() {
  yaw_vcs_ = 0;
}
inline float PoseInfo::yaw_vcs() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.yaw_vcs)
  return yaw_vcs_;
}
inline void PoseInfo::set_yaw_vcs(float value) {
  
  yaw_vcs_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.PoseInfo.yaw_vcs)
}

// float yaw_world = 6;
inline void PoseInfo::clear_yaw_world() {
  yaw_world_ = 0;
}
inline float PoseInfo::yaw_world() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.yaw_world)
  return yaw_world_;
}
inline void PoseInfo::set_yaw_world(float value) {
  
  yaw_world_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.PoseInfo.yaw_world)
}

// float alpha_vcs = 7;
inline void PoseInfo::clear_alpha_vcs() {
  alpha_vcs_ = 0;
}
inline float PoseInfo::alpha_vcs() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.alpha_vcs)
  return alpha_vcs_;
}
inline void PoseInfo::set_alpha_vcs(float value) {
  
  alpha_vcs_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.PoseInfo.alpha_vcs)
}

// float alpha_world = 8;
inline void PoseInfo::clear_alpha_world() {
  alpha_world_ = 0;
}
inline float PoseInfo::alpha_world() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.alpha_world)
  return alpha_world_;
}
inline void PoseInfo::set_alpha_world(float value) {
  
  alpha_world_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.PoseInfo.alpha_world)
}

// repeated .autodrive.workflow.proto.Vector3f corners_vcs = 9;
inline int PoseInfo::corners_vcs_size() const {
  return corners_vcs_.size();
}
inline const ::autodrive::workflow::proto::Vector3f& PoseInfo::corners_vcs(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.corners_vcs)
  return corners_vcs_.Get(index);
}
inline ::autodrive::workflow::proto::Vector3f* PoseInfo::mutable_corners_vcs(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.PoseInfo.corners_vcs)
  return corners_vcs_.Mutable(index);
}
inline ::autodrive::workflow::proto::Vector3f* PoseInfo::add_corners_vcs() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.PoseInfo.corners_vcs)
  return corners_vcs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
PoseInfo::mutable_corners_vcs() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.PoseInfo.corners_vcs)
  return &corners_vcs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
PoseInfo::corners_vcs() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.PoseInfo.corners_vcs)
  return corners_vcs_;
}

// repeated .autodrive.workflow.proto.Vector3f corners_world = 10;
inline int PoseInfo::corners_world_size() const {
  return corners_world_.size();
}
inline const ::autodrive::workflow::proto::Vector3f& PoseInfo::corners_world(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.corners_world)
  return corners_world_.Get(index);
}
inline ::autodrive::workflow::proto::Vector3f* PoseInfo::mutable_corners_world(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.PoseInfo.corners_world)
  return corners_world_.Mutable(index);
}
inline ::autodrive::workflow::proto::Vector3f* PoseInfo::add_corners_world() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.PoseInfo.corners_world)
  return corners_world_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
PoseInfo::mutable_corners_world() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.PoseInfo.corners_world)
  return &corners_world_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
PoseInfo::corners_world() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.PoseInfo.corners_world)
  return corners_world_;
}

// float slotline_w0 = 11;
inline void PoseInfo::clear_slotline_w0() {
  slotline_w0_ = 0;
}
inline float PoseInfo::slotline_w0() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.slotline_w0)
  return slotline_w0_;
}
inline void PoseInfo::set_slotline_w0(float value) {
  
  slotline_w0_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.PoseInfo.slotline_w0)
}

// float slotline_w1 = 12;
inline void PoseInfo::clear_slotline_w1() {
  slotline_w1_ = 0;
}
inline float PoseInfo::slotline_w1() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.PoseInfo.slotline_w1)
  return slotline_w1_;
}
inline void PoseInfo::set_slotline_w1(float value) {
  
  slotline_w1_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.PoseInfo.slotline_w1)
}

// -------------------------------------------------------------------

// ParkingRodInfo

// repeated .autodrive.workflow.proto.Vector3f end_points_vcs = 1;
inline int ParkingRodInfo::end_points_vcs_size() const {
  return end_points_vcs_.size();
}
inline const ::autodrive::workflow::proto::Vector3f& ParkingRodInfo::end_points_vcs(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingRodInfo.end_points_vcs)
  return end_points_vcs_.Get(index);
}
inline ::autodrive::workflow::proto::Vector3f* ParkingRodInfo::mutable_end_points_vcs(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.ParkingRodInfo.end_points_vcs)
  return end_points_vcs_.Mutable(index);
}
inline ::autodrive::workflow::proto::Vector3f* ParkingRodInfo::add_end_points_vcs() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.ParkingRodInfo.end_points_vcs)
  return end_points_vcs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
ParkingRodInfo::mutable_end_points_vcs() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.ParkingRodInfo.end_points_vcs)
  return &end_points_vcs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
ParkingRodInfo::end_points_vcs() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.ParkingRodInfo.end_points_vcs)
  return end_points_vcs_;
}

// repeated .autodrive.workflow.proto.Vector3f end_points_world = 2;
inline int ParkingRodInfo::end_points_world_size() const {
  return end_points_world_.size();
}
inline const ::autodrive::workflow::proto::Vector3f& ParkingRodInfo::end_points_world(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingRodInfo.end_points_world)
  return end_points_world_.Get(index);
}
inline ::autodrive::workflow::proto::Vector3f* ParkingRodInfo::mutable_end_points_world(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.ParkingRodInfo.end_points_world)
  return end_points_world_.Mutable(index);
}
inline ::autodrive::workflow::proto::Vector3f* ParkingRodInfo::add_end_points_world() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.ParkingRodInfo.end_points_world)
  return end_points_world_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
ParkingRodInfo::mutable_end_points_world() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.ParkingRodInfo.end_points_world)
  return &end_points_world_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
ParkingRodInfo::end_points_world() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.ParkingRodInfo.end_points_world)
  return end_points_world_;
}

// bool valid = 3;
inline void ParkingRodInfo::clear_valid() {
  valid_ = false;
}
inline bool ParkingRodInfo::valid() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingRodInfo.valid)
  return valid_;
}
inline void ParkingRodInfo::set_valid(bool value) {
  
  valid_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingRodInfo.valid)
}

// -------------------------------------------------------------------

// ParkingLockInfo

// .autodrive.workflow.proto.Vector3f point_vcs = 1;
inline bool ParkingLockInfo::has_point_vcs() const {
  return this != internal_default_instance() && point_vcs_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& ParkingLockInfo::point_vcs() const {
  const ::autodrive::workflow::proto::Vector3f* p = point_vcs_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingLockInfo.point_vcs)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* ParkingLockInfo::release_point_vcs() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.ParkingLockInfo.point_vcs)
  
  ::autodrive::workflow::proto::Vector3f* temp = point_vcs_;
  point_vcs_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* ParkingLockInfo::mutable_point_vcs() {
  
  if (point_vcs_ == NULL) {
    point_vcs_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.ParkingLockInfo.point_vcs)
  return point_vcs_;
}
inline void ParkingLockInfo::set_allocated_point_vcs(::autodrive::workflow::proto::Vector3f* point_vcs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(point_vcs_);
  }
  if (point_vcs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point_vcs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point_vcs, submessage_arena);
    }
    
  } else {
    
  }
  point_vcs_ = point_vcs;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.ParkingLockInfo.point_vcs)
}

// .autodrive.workflow.proto.Vector3f point_world = 2;
inline bool ParkingLockInfo::has_point_world() const {
  return this != internal_default_instance() && point_world_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& ParkingLockInfo::point_world() const {
  const ::autodrive::workflow::proto::Vector3f* p = point_world_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingLockInfo.point_world)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* ParkingLockInfo::release_point_world() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.ParkingLockInfo.point_world)
  
  ::autodrive::workflow::proto::Vector3f* temp = point_world_;
  point_world_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* ParkingLockInfo::mutable_point_world() {
  
  if (point_world_ == NULL) {
    point_world_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.ParkingLockInfo.point_world)
  return point_world_;
}
inline void ParkingLockInfo::set_allocated_point_world(::autodrive::workflow::proto::Vector3f* point_world) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(point_world_);
  }
  if (point_world) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point_world = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point_world, submessage_arena);
    }
    
  } else {
    
  }
  point_world_ = point_world;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.ParkingLockInfo.point_world)
}

// .autodrive.workflow.proto.parking_slot.ParkingLockStatus parking_status = 3;
inline void ParkingLockInfo::clear_parking_status() {
  parking_status_ = 0;
}
inline ::autodrive::workflow::proto::parking_slot::ParkingLockStatus ParkingLockInfo::parking_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingLockInfo.parking_status)
  return static_cast< ::autodrive::workflow::proto::parking_slot::ParkingLockStatus >(parking_status_);
}
inline void ParkingLockInfo::set_parking_status(::autodrive::workflow::proto::parking_slot::ParkingLockStatus value) {
  
  parking_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingLockInfo.parking_status)
}

// bool valid = 4;
inline void ParkingLockInfo::clear_valid() {
  valid_ = false;
}
inline bool ParkingLockInfo::valid() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingLockInfo.valid)
  return valid_;
}
inline void ParkingLockInfo::set_valid(bool value) {
  
  valid_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingLockInfo.valid)
}

// -------------------------------------------------------------------

// BoundaryInfo

// repeated .autodrive.workflow.proto.Vector3f points_vcs = 1;
inline int BoundaryInfo::points_vcs_size() const {
  return points_vcs_.size();
}
inline const ::autodrive::workflow::proto::Vector3f& BoundaryInfo::points_vcs(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_vcs)
  return points_vcs_.Get(index);
}
inline ::autodrive::workflow::proto::Vector3f* BoundaryInfo::mutable_points_vcs(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_vcs)
  return points_vcs_.Mutable(index);
}
inline ::autodrive::workflow::proto::Vector3f* BoundaryInfo::add_points_vcs() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_vcs)
  return points_vcs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
BoundaryInfo::mutable_points_vcs() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_vcs)
  return &points_vcs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
BoundaryInfo::points_vcs() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_vcs)
  return points_vcs_;
}

// repeated .autodrive.workflow.proto.Vector3f points_world = 2;
inline int BoundaryInfo::points_world_size() const {
  return points_world_.size();
}
inline const ::autodrive::workflow::proto::Vector3f& BoundaryInfo::points_world(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_world)
  return points_world_.Get(index);
}
inline ::autodrive::workflow::proto::Vector3f* BoundaryInfo::mutable_points_world(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_world)
  return points_world_.Mutable(index);
}
inline ::autodrive::workflow::proto::Vector3f* BoundaryInfo::add_points_world() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_world)
  return points_world_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
BoundaryInfo::mutable_points_world() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_world)
  return &points_world_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
BoundaryInfo::points_world() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_world)
  return points_world_;
}

// repeated .autodrive.workflow.proto.parking_slot.BoundaryStatus boundaries_status = 3;
inline int BoundaryInfo::boundaries_status_size() const {
  return boundaries_status_.size();
}
inline void BoundaryInfo::clear_boundaries_status() {
  boundaries_status_.Clear();
}
inline ::autodrive::workflow::proto::parking_slot::BoundaryStatus BoundaryInfo::boundaries_status(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_status)
  return static_cast< ::autodrive::workflow::proto::parking_slot::BoundaryStatus >(boundaries_status_.Get(index));
}
inline void BoundaryInfo::set_boundaries_status(int index, ::autodrive::workflow::proto::parking_slot::BoundaryStatus value) {
  boundaries_status_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_status)
}
inline void BoundaryInfo::add_boundaries_status(::autodrive::workflow::proto::parking_slot::BoundaryStatus value) {
  boundaries_status_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_status)
}
inline const ::google::protobuf::RepeatedField<int>&
BoundaryInfo::boundaries_status() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_status)
  return boundaries_status_;
}
inline ::google::protobuf::RepeatedField<int>*
BoundaryInfo::mutable_boundaries_status() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_status)
  return &boundaries_status_;
}

// repeated float boundaries_height = 4;
inline int BoundaryInfo::boundaries_height_size() const {
  return boundaries_height_.size();
}
inline void BoundaryInfo::clear_boundaries_height() {
  boundaries_height_.Clear();
}
inline float BoundaryInfo::boundaries_height(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_height)
  return boundaries_height_.Get(index);
}
inline void BoundaryInfo::set_boundaries_height(int index, float value) {
  boundaries_height_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_height)
}
inline void BoundaryInfo::add_boundaries_height(float value) {
  boundaries_height_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_height)
}
inline const ::google::protobuf::RepeatedField< float >&
BoundaryInfo::boundaries_height() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_height)
  return boundaries_height_;
}
inline ::google::protobuf::RepeatedField< float >*
BoundaryInfo::mutable_boundaries_height() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_height)
  return &boundaries_height_;
}

// repeated .autodrive.workflow.proto.parking_slot.BoundaryFixStatus boundaries_fix_status = 5;
inline int BoundaryInfo::boundaries_fix_status_size() const {
  return boundaries_fix_status_.size();
}
inline void BoundaryInfo::clear_boundaries_fix_status() {
  boundaries_fix_status_.Clear();
}
inline ::autodrive::workflow::proto::parking_slot::BoundaryFixStatus BoundaryInfo::boundaries_fix_status(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_fix_status)
  return static_cast< ::autodrive::workflow::proto::parking_slot::BoundaryFixStatus >(boundaries_fix_status_.Get(index));
}
inline void BoundaryInfo::set_boundaries_fix_status(int index, ::autodrive::workflow::proto::parking_slot::BoundaryFixStatus value) {
  boundaries_fix_status_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_fix_status)
}
inline void BoundaryInfo::add_boundaries_fix_status(::autodrive::workflow::proto::parking_slot::BoundaryFixStatus value) {
  boundaries_fix_status_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_fix_status)
}
inline const ::google::protobuf::RepeatedField<int>&
BoundaryInfo::boundaries_fix_status() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_fix_status)
  return boundaries_fix_status_;
}
inline ::google::protobuf::RepeatedField<int>*
BoundaryInfo::mutable_boundaries_fix_status() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.boundaries_fix_status)
  return &boundaries_fix_status_;
}

// repeated .autodrive.workflow.proto.Vector3f points_delta_ss = 6;
inline int BoundaryInfo::points_delta_ss_size() const {
  return points_delta_ss_.size();
}
inline const ::autodrive::workflow::proto::Vector3f& BoundaryInfo::points_delta_ss(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_delta_ss)
  return points_delta_ss_.Get(index);
}
inline ::autodrive::workflow::proto::Vector3f* BoundaryInfo::mutable_points_delta_ss(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_delta_ss)
  return points_delta_ss_.Mutable(index);
}
inline ::autodrive::workflow::proto::Vector3f* BoundaryInfo::add_points_delta_ss() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_delta_ss)
  return points_delta_ss_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
BoundaryInfo::mutable_points_delta_ss() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_delta_ss)
  return &points_delta_ss_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
BoundaryInfo::points_delta_ss() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.BoundaryInfo.points_delta_ss)
  return points_delta_ss_;
}

// -------------------------------------------------------------------

// ParkingSlotInfo

// int32 id = 1;
inline void ParkingSlotInfo::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ParkingSlotInfo::id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.id)
  return id_;
}
inline void ParkingSlotInfo::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.id)
}

// int32 valid = 2;
inline void ParkingSlotInfo::clear_valid() {
  valid_ = 0;
}
inline ::google::protobuf::int32 ParkingSlotInfo::valid() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.valid)
  return valid_;
}
inline void ParkingSlotInfo::set_valid(::google::protobuf::int32 value) {
  
  valid_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.valid)
}

// float conf = 3;
inline void ParkingSlotInfo::clear_conf() {
  conf_ = 0;
}
inline float ParkingSlotInfo::conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.conf)
  return conf_;
}
inline void ParkingSlotInfo::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.conf)
}

// repeated .autodrive.workflow.proto.parking_slot.CornerInfo polygon_points = 4;
inline int ParkingSlotInfo::polygon_points_size() const {
  return polygon_points_.size();
}
inline void ParkingSlotInfo::clear_polygon_points() {
  polygon_points_.Clear();
}
inline const ::autodrive::workflow::proto::parking_slot::CornerInfo& ParkingSlotInfo::polygon_points(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.polygon_points)
  return polygon_points_.Get(index);
}
inline ::autodrive::workflow::proto::parking_slot::CornerInfo* ParkingSlotInfo::mutable_polygon_points(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.polygon_points)
  return polygon_points_.Mutable(index);
}
inline ::autodrive::workflow::proto::parking_slot::CornerInfo* ParkingSlotInfo::add_polygon_points() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.polygon_points)
  return polygon_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::parking_slot::CornerInfo >*
ParkingSlotInfo::mutable_polygon_points() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.polygon_points)
  return &polygon_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::parking_slot::CornerInfo >&
ParkingSlotInfo::polygon_points() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.polygon_points)
  return polygon_points_;
}

// .autodrive.workflow.proto.parking_slot.PoseInfo pose = 5;
inline bool ParkingSlotInfo::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline void ParkingSlotInfo::clear_pose() {
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) {
    delete pose_;
  }
  pose_ = NULL;
}
inline const ::autodrive::workflow::proto::parking_slot::PoseInfo& ParkingSlotInfo::pose() const {
  const ::autodrive::workflow::proto::parking_slot::PoseInfo* p = pose_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::parking_slot::PoseInfo*>(
      &::autodrive::workflow::proto::parking_slot::_PoseInfo_default_instance_);
}
inline ::autodrive::workflow::proto::parking_slot::PoseInfo* ParkingSlotInfo::release_pose() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.pose)
  
  ::autodrive::workflow::proto::parking_slot::PoseInfo* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::parking_slot::PoseInfo* ParkingSlotInfo::mutable_pose() {
  
  if (pose_ == NULL) {
    pose_ = new ::autodrive::workflow::proto::parking_slot::PoseInfo;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.pose)
  return pose_;
}
inline void ParkingSlotInfo::set_allocated_pose(::autodrive::workflow::proto::parking_slot::PoseInfo* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_;
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.pose)
}

// .autodrive.workflow.proto.parking_slot.ParkingRodInfo parking_rod = 6;
inline bool ParkingSlotInfo::has_parking_rod() const {
  return this != internal_default_instance() && parking_rod_ != NULL;
}
inline void ParkingSlotInfo::clear_parking_rod() {
  if (GetArenaNoVirtual() == NULL && parking_rod_ != NULL) {
    delete parking_rod_;
  }
  parking_rod_ = NULL;
}
inline const ::autodrive::workflow::proto::parking_slot::ParkingRodInfo& ParkingSlotInfo::parking_rod() const {
  const ::autodrive::workflow::proto::parking_slot::ParkingRodInfo* p = parking_rod_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_rod)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::parking_slot::ParkingRodInfo*>(
      &::autodrive::workflow::proto::parking_slot::_ParkingRodInfo_default_instance_);
}
inline ::autodrive::workflow::proto::parking_slot::ParkingRodInfo* ParkingSlotInfo::release_parking_rod() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_rod)
  
  ::autodrive::workflow::proto::parking_slot::ParkingRodInfo* temp = parking_rod_;
  parking_rod_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::parking_slot::ParkingRodInfo* ParkingSlotInfo::mutable_parking_rod() {
  
  if (parking_rod_ == NULL) {
    parking_rod_ = new ::autodrive::workflow::proto::parking_slot::ParkingRodInfo;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_rod)
  return parking_rod_;
}
inline void ParkingSlotInfo::set_allocated_parking_rod(::autodrive::workflow::proto::parking_slot::ParkingRodInfo* parking_rod) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parking_rod_;
  }
  if (parking_rod) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parking_rod = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parking_rod, submessage_arena);
    }
    
  } else {
    
  }
  parking_rod_ = parking_rod;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_rod)
}

// .autodrive.workflow.proto.parking_slot.ParkingLockInfo parking_lock_info = 7;
inline bool ParkingSlotInfo::has_parking_lock_info() const {
  return this != internal_default_instance() && parking_lock_info_ != NULL;
}
inline void ParkingSlotInfo::clear_parking_lock_info() {
  if (GetArenaNoVirtual() == NULL && parking_lock_info_ != NULL) {
    delete parking_lock_info_;
  }
  parking_lock_info_ = NULL;
}
inline const ::autodrive::workflow::proto::parking_slot::ParkingLockInfo& ParkingSlotInfo::parking_lock_info() const {
  const ::autodrive::workflow::proto::parking_slot::ParkingLockInfo* p = parking_lock_info_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_lock_info)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::parking_slot::ParkingLockInfo*>(
      &::autodrive::workflow::proto::parking_slot::_ParkingLockInfo_default_instance_);
}
inline ::autodrive::workflow::proto::parking_slot::ParkingLockInfo* ParkingSlotInfo::release_parking_lock_info() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_lock_info)
  
  ::autodrive::workflow::proto::parking_slot::ParkingLockInfo* temp = parking_lock_info_;
  parking_lock_info_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::parking_slot::ParkingLockInfo* ParkingSlotInfo::mutable_parking_lock_info() {
  
  if (parking_lock_info_ == NULL) {
    parking_lock_info_ = new ::autodrive::workflow::proto::parking_slot::ParkingLockInfo;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_lock_info)
  return parking_lock_info_;
}
inline void ParkingSlotInfo::set_allocated_parking_lock_info(::autodrive::workflow::proto::parking_slot::ParkingLockInfo* parking_lock_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parking_lock_info_;
  }
  if (parking_lock_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parking_lock_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parking_lock_info, submessage_arena);
    }
    
  } else {
    
  }
  parking_lock_info_ = parking_lock_info;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_lock_info)
}

// .autodrive.workflow.proto.parking_slot.BoundaryInfo boundary = 8;
inline bool ParkingSlotInfo::has_boundary() const {
  return this != internal_default_instance() && boundary_ != NULL;
}
inline void ParkingSlotInfo::clear_boundary() {
  if (GetArenaNoVirtual() == NULL && boundary_ != NULL) {
    delete boundary_;
  }
  boundary_ = NULL;
}
inline const ::autodrive::workflow::proto::parking_slot::BoundaryInfo& ParkingSlotInfo::boundary() const {
  const ::autodrive::workflow::proto::parking_slot::BoundaryInfo* p = boundary_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.boundary)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::parking_slot::BoundaryInfo*>(
      &::autodrive::workflow::proto::parking_slot::_BoundaryInfo_default_instance_);
}
inline ::autodrive::workflow::proto::parking_slot::BoundaryInfo* ParkingSlotInfo::release_boundary() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.boundary)
  
  ::autodrive::workflow::proto::parking_slot::BoundaryInfo* temp = boundary_;
  boundary_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::parking_slot::BoundaryInfo* ParkingSlotInfo::mutable_boundary() {
  
  if (boundary_ == NULL) {
    boundary_ = new ::autodrive::workflow::proto::parking_slot::BoundaryInfo;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.boundary)
  return boundary_;
}
inline void ParkingSlotInfo::set_allocated_boundary(::autodrive::workflow::proto::parking_slot::BoundaryInfo* boundary) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete boundary_;
  }
  if (boundary) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      boundary = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, boundary, submessage_arena);
    }
    
  } else {
    
  }
  boundary_ = boundary;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.boundary)
}

// .autodrive.workflow.proto.parking_slot.ParkingType type = 9;
inline void ParkingSlotInfo::clear_type() {
  type_ = 0;
}
inline ::autodrive::workflow::proto::parking_slot::ParkingType ParkingSlotInfo::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.type)
  return static_cast< ::autodrive::workflow::proto::parking_slot::ParkingType >(type_);
}
inline void ParkingSlotInfo::set_type(::autodrive::workflow::proto::parking_slot::ParkingType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.type)
}

// .autodrive.workflow.proto.parking_slot.OccupancyStatus occupancy_status = 10;
inline void ParkingSlotInfo::clear_occupancy_status() {
  occupancy_status_ = 0;
}
inline ::autodrive::workflow::proto::parking_slot::OccupancyStatus ParkingSlotInfo::occupancy_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.occupancy_status)
  return static_cast< ::autodrive::workflow::proto::parking_slot::OccupancyStatus >(occupancy_status_);
}
inline void ParkingSlotInfo::set_occupancy_status(::autodrive::workflow::proto::parking_slot::OccupancyStatus value) {
  
  occupancy_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.occupancy_status)
}

// .autodrive.workflow.proto.parking_slot.ParkingSource parking_source = 11;
inline void ParkingSlotInfo::clear_parking_source() {
  parking_source_ = 0;
}
inline ::autodrive::workflow::proto::parking_slot::ParkingSource ParkingSlotInfo::parking_source() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_source)
  return static_cast< ::autodrive::workflow::proto::parking_slot::ParkingSource >(parking_source_);
}
inline void ParkingSlotInfo::set_parking_source(::autodrive::workflow::proto::parking_slot::ParkingSource value) {
  
  parking_source_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_source)
}

// .autodrive.workflow.proto.parking_slot.ParkingStage stage = 12;
inline void ParkingSlotInfo::clear_stage() {
  stage_ = 0;
}
inline ::autodrive::workflow::proto::parking_slot::ParkingStage ParkingSlotInfo::stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.stage)
  return static_cast< ::autodrive::workflow::proto::parking_slot::ParkingStage >(stage_);
}
inline void ParkingSlotInfo::set_stage(::autodrive::workflow::proto::parking_slot::ParkingStage value) {
  
  stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.stage)
}

// .autodrive.workflow.proto.parking_slot.OccupyObjType occupancy_obs_type = 13;
inline void ParkingSlotInfo::clear_occupancy_obs_type() {
  occupancy_obs_type_ = 0;
}
inline ::autodrive::workflow::proto::parking_slot::OccupyObjType ParkingSlotInfo::occupancy_obs_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.occupancy_obs_type)
  return static_cast< ::autodrive::workflow::proto::parking_slot::OccupyObjType >(occupancy_obs_type_);
}
inline void ParkingSlotInfo::set_occupancy_obs_type(::autodrive::workflow::proto::parking_slot::OccupyObjType value) {
  
  occupancy_obs_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.occupancy_obs_type)
}

// string str_id = 14;
inline void ParkingSlotInfo::clear_str_id() {
  str_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ParkingSlotInfo::str_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id)
  return str_id_.GetNoArena();
}
inline void ParkingSlotInfo::set_str_id(const ::std::string& value) {
  
  str_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id)
}
#if LANG_CXX11
inline void ParkingSlotInfo::set_str_id(::std::string&& value) {
  
  str_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id)
}
#endif
inline void ParkingSlotInfo::set_str_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  str_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id)
}
inline void ParkingSlotInfo::set_str_id(const char* value, size_t size) {
  
  str_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id)
}
inline ::std::string* ParkingSlotInfo::mutable_str_id() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id)
  return str_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParkingSlotInfo::release_str_id() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id)
  
  return str_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParkingSlotInfo::set_allocated_str_id(::std::string* str_id) {
  if (str_id != NULL) {
    
  } else {
    
  }
  str_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str_id);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id)
}

// .autodrive.workflow.proto.parking_slot.ParkingReleaseMode parking_release_mode = 15;
inline void ParkingSlotInfo::clear_parking_release_mode() {
  parking_release_mode_ = 0;
}
inline ::autodrive::workflow::proto::parking_slot::ParkingReleaseMode ParkingSlotInfo::parking_release_mode() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_release_mode)
  return static_cast< ::autodrive::workflow::proto::parking_slot::ParkingReleaseMode >(parking_release_mode_);
}
inline void ParkingSlotInfo::set_parking_release_mode(::autodrive::workflow::proto::parking_slot::ParkingReleaseMode value) {
  
  parking_release_mode_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.parking_slot.ParkingSlotInfo.parking_release_mode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace parking_slot
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::parking_slot::ParkingType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::parking_slot::ParkingType>() {
  return ::autodrive::workflow::proto::parking_slot::ParkingType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::parking_slot::OccupancyStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::parking_slot::OccupancyStatus>() {
  return ::autodrive::workflow::proto::parking_slot::OccupancyStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::parking_slot::ParkingSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::parking_slot::ParkingSource>() {
  return ::autodrive::workflow::proto::parking_slot::ParkingSource_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::parking_slot::ParkingStage> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::parking_slot::ParkingStage>() {
  return ::autodrive::workflow::proto::parking_slot::ParkingStage_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::parking_slot::ParkingLockStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::parking_slot::ParkingLockStatus>() {
  return ::autodrive::workflow::proto::parking_slot::ParkingLockStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::parking_slot::BoundaryStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::parking_slot::BoundaryStatus>() {
  return ::autodrive::workflow::proto::parking_slot::BoundaryStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::parking_slot::BoundaryFixStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::parking_slot::BoundaryFixStatus>() {
  return ::autodrive::workflow::proto::parking_slot::BoundaryFixStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::parking_slot::OccupyObjType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::parking_slot::OccupyObjType>() {
  return ::autodrive::workflow::proto::parking_slot::OccupyObjType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::parking_slot::ParkingReleaseMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::parking_slot::ParkingReleaseMode>() {
  return ::autodrive::workflow::proto::parking_slot::ParkingReleaseMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_parking_5fslot_2eproto__INCLUDED
