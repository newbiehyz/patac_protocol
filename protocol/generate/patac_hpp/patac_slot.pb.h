// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: patac_slot.proto

#ifndef PROTOBUF_patac_5fslot_2eproto__INCLUDED
#define PROTOBUF_patac_5fslot_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_patac_5fslot_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPoint2fImpl();
void InitDefaultsPoint2f();
void InitDefaultsParkingSlotImpl();
void InitDefaultsParkingSlot();
void InitDefaultsParkingSlotListImpl();
void InitDefaultsParkingSlotList();
inline void InitDefaults() {
  InitDefaultsPoint2f();
  InitDefaultsParkingSlot();
  InitDefaultsParkingSlotList();
}
}  // namespace protobuf_patac_5fslot_2eproto
namespace patac_hpp {
class ParkingSlot;
class ParkingSlotDefaultTypeInternal;
extern ParkingSlotDefaultTypeInternal _ParkingSlot_default_instance_;
class ParkingSlotList;
class ParkingSlotListDefaultTypeInternal;
extern ParkingSlotListDefaultTypeInternal _ParkingSlotList_default_instance_;
class Point2f;
class Point2fDefaultTypeInternal;
extern Point2fDefaultTypeInternal _Point2f_default_instance_;
}  // namespace patac_hpp
namespace patac_hpp {

enum ParkingSlotType {
  SlotTypeUnknown = 0,
  SlotTypeVertical = 1,
  SlotTypeParallel = 2,
  SlotTypeOblique = 3,
  ParkingSlotType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParkingSlotType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParkingSlotType_IsValid(int value);
const ParkingSlotType ParkingSlotType_MIN = SlotTypeUnknown;
const ParkingSlotType ParkingSlotType_MAX = SlotTypeOblique;
const int ParkingSlotType_ARRAYSIZE = ParkingSlotType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParkingSlotType_descriptor();
inline const ::std::string& ParkingSlotType_Name(ParkingSlotType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParkingSlotType_descriptor(), value);
}
inline bool ParkingSlotType_Parse(
    const ::std::string& name, ParkingSlotType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParkingSlotType>(
    ParkingSlotType_descriptor(), name, value);
}
enum OccupancyStatus {
  OccupancyStatusUnknown = 0,
  OccupancyStatusOccupied = 1,
  OccupancyStatusNotOccupied = 2,
  OccupancyStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OccupancyStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OccupancyStatus_IsValid(int value);
const OccupancyStatus OccupancyStatus_MIN = OccupancyStatusUnknown;
const OccupancyStatus OccupancyStatus_MAX = OccupancyStatusNotOccupied;
const int OccupancyStatus_ARRAYSIZE = OccupancyStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* OccupancyStatus_descriptor();
inline const ::std::string& OccupancyStatus_Name(OccupancyStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    OccupancyStatus_descriptor(), value);
}
inline bool OccupancyStatus_Parse(
    const ::std::string& name, OccupancyStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OccupancyStatus>(
    OccupancyStatus_descriptor(), name, value);
}
enum ParkingSource {
  ParkingSourceUnspecified = 0,
  ParkingSourceIpm = 1,
  ParkingSourceUss = 2,
  ParkingSourceUserSel = 3,
  ParkingSource_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParkingSource_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParkingSource_IsValid(int value);
const ParkingSource ParkingSource_MIN = ParkingSourceUnspecified;
const ParkingSource ParkingSource_MAX = ParkingSourceUserSel;
const int ParkingSource_ARRAYSIZE = ParkingSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParkingSource_descriptor();
inline const ::std::string& ParkingSource_Name(ParkingSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParkingSource_descriptor(), value);
}
inline bool ParkingSource_Parse(
    const ::std::string& name, ParkingSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParkingSource>(
    ParkingSource_descriptor(), name, value);
}
enum ParkingLockStatus {
  ParkingLockStatusUnknown = 0,
  ParkingLockStatusOpen = 1,
  ParkingLockStatusClose = 2,
  ParkingLockStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParkingLockStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParkingLockStatus_IsValid(int value);
const ParkingLockStatus ParkingLockStatus_MIN = ParkingLockStatusUnknown;
const ParkingLockStatus ParkingLockStatus_MAX = ParkingLockStatusClose;
const int ParkingLockStatus_ARRAYSIZE = ParkingLockStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParkingLockStatus_descriptor();
inline const ::std::string& ParkingLockStatus_Name(ParkingLockStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParkingLockStatus_descriptor(), value);
}
inline bool ParkingLockStatus_Parse(
    const ::std::string& name, ParkingLockStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParkingLockStatus>(
    ParkingLockStatus_descriptor(), name, value);
}
// ===================================================================

class Point2f : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:patac_hpp.Point2f) */ {
 public:
  Point2f();
  virtual ~Point2f();

  Point2f(const Point2f& from);

  inline Point2f& operator=(const Point2f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point2f(Point2f&& from) noexcept
    : Point2f() {
    *this = ::std::move(from);
  }

  inline Point2f& operator=(Point2f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point2f* internal_default_instance() {
    return reinterpret_cast<const Point2f*>(
               &_Point2f_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Point2f* other);
  friend void swap(Point2f& a, Point2f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point2f* New() const PROTOBUF_FINAL { return New(NULL); }

  Point2f* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point2f& from);
  void MergeFrom(const Point2f& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point2f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:patac_hpp.Point2f)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  mutable int _cached_size_;
  friend struct ::protobuf_patac_5fslot_2eproto::TableStruct;
  friend void ::protobuf_patac_5fslot_2eproto::InitDefaultsPoint2fImpl();
};
// -------------------------------------------------------------------

class ParkingSlot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:patac_hpp.ParkingSlot) */ {
 public:
  ParkingSlot();
  virtual ~ParkingSlot();

  ParkingSlot(const ParkingSlot& from);

  inline ParkingSlot& operator=(const ParkingSlot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingSlot(ParkingSlot&& from) noexcept
    : ParkingSlot() {
    *this = ::std::move(from);
  }

  inline ParkingSlot& operator=(ParkingSlot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSlot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingSlot* internal_default_instance() {
    return reinterpret_cast<const ParkingSlot*>(
               &_ParkingSlot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ParkingSlot* other);
  friend void swap(ParkingSlot& a, ParkingSlot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingSlot* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSlot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSlot& from);
  void MergeFrom(const ParkingSlot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSlot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .patac_hpp.Point2f points = 6;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 6;
  const ::patac_hpp::Point2f& points(int index) const;
  ::patac_hpp::Point2f* mutable_points(int index);
  ::patac_hpp::Point2f* add_points();
  ::google::protobuf::RepeatedPtrField< ::patac_hpp::Point2f >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::patac_hpp::Point2f >&
      points() const;

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 valid = 2;
  void clear_valid();
  static const int kValidFieldNumber = 2;
  ::google::protobuf::int32 valid() const;
  void set_valid(::google::protobuf::int32 value);

  // float conf = 3;
  void clear_conf();
  static const int kConfFieldNumber = 3;
  float conf() const;
  void set_conf(float value);

  // .patac_hpp.ParkingSlotType type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::patac_hpp::ParkingSlotType type() const;
  void set_type(::patac_hpp::ParkingSlotType value);

  // .patac_hpp.OccupancyStatus occupancy = 5;
  void clear_occupancy();
  static const int kOccupancyFieldNumber = 5;
  ::patac_hpp::OccupancyStatus occupancy() const;
  void set_occupancy(::patac_hpp::OccupancyStatus value);

  // float planning_score = 7;
  void clear_planning_score();
  static const int kPlanningScoreFieldNumber = 7;
  float planning_score() const;
  void set_planning_score(float value);

  // .patac_hpp.ParkingSource source = 8;
  void clear_source();
  static const int kSourceFieldNumber = 8;
  ::patac_hpp::ParkingSource source() const;
  void set_source(::patac_hpp::ParkingSource value);

  // .patac_hpp.ParkingLockStatus lock_status = 9;
  void clear_lock_status();
  static const int kLockStatusFieldNumber = 9;
  ::patac_hpp::ParkingLockStatus lock_status() const;
  void set_lock_status(::patac_hpp::ParkingLockStatus value);

  // @@protoc_insertion_point(class_scope:patac_hpp.ParkingSlot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::patac_hpp::Point2f > points_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 valid_;
  float conf_;
  int type_;
  int occupancy_;
  float planning_score_;
  int source_;
  int lock_status_;
  mutable int _cached_size_;
  friend struct ::protobuf_patac_5fslot_2eproto::TableStruct;
  friend void ::protobuf_patac_5fslot_2eproto::InitDefaultsParkingSlotImpl();
};
// -------------------------------------------------------------------

class ParkingSlotList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:patac_hpp.ParkingSlotList) */ {
 public:
  ParkingSlotList();
  virtual ~ParkingSlotList();

  ParkingSlotList(const ParkingSlotList& from);

  inline ParkingSlotList& operator=(const ParkingSlotList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingSlotList(ParkingSlotList&& from) noexcept
    : ParkingSlotList() {
    *this = ::std::move(from);
  }

  inline ParkingSlotList& operator=(ParkingSlotList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSlotList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingSlotList* internal_default_instance() {
    return reinterpret_cast<const ParkingSlotList*>(
               &_ParkingSlotList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ParkingSlotList* other);
  friend void swap(ParkingSlotList& a, ParkingSlotList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingSlotList* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSlotList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSlotList& from);
  void MergeFrom(const ParkingSlotList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSlotList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .patac_hpp.ParkingSlot parking_slot_list = 2;
  int parking_slot_list_size() const;
  void clear_parking_slot_list();
  static const int kParkingSlotListFieldNumber = 2;
  const ::patac_hpp::ParkingSlot& parking_slot_list(int index) const;
  ::patac_hpp::ParkingSlot* mutable_parking_slot_list(int index);
  ::patac_hpp::ParkingSlot* add_parking_slot_list();
  ::google::protobuf::RepeatedPtrField< ::patac_hpp::ParkingSlot >*
      mutable_parking_slot_list();
  const ::google::protobuf::RepeatedPtrField< ::patac_hpp::ParkingSlot >&
      parking_slot_list() const;

  // uint32 num_parking_slot = 1;
  void clear_num_parking_slot();
  static const int kNumParkingSlotFieldNumber = 1;
  ::google::protobuf::uint32 num_parking_slot() const;
  void set_num_parking_slot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:patac_hpp.ParkingSlotList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::patac_hpp::ParkingSlot > parking_slot_list_;
  ::google::protobuf::uint32 num_parking_slot_;
  mutable int _cached_size_;
  friend struct ::protobuf_patac_5fslot_2eproto::TableStruct;
  friend void ::protobuf_patac_5fslot_2eproto::InitDefaultsParkingSlotListImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point2f

// float x = 1;
inline void Point2f::clear_x() {
  x_ = 0;
}
inline float Point2f::x() const {
  // @@protoc_insertion_point(field_get:patac_hpp.Point2f.x)
  return x_;
}
inline void Point2f::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.Point2f.x)
}

// float y = 2;
inline void Point2f::clear_y() {
  y_ = 0;
}
inline float Point2f::y() const {
  // @@protoc_insertion_point(field_get:patac_hpp.Point2f.y)
  return y_;
}
inline void Point2f::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.Point2f.y)
}

// -------------------------------------------------------------------

// ParkingSlot

// int32 id = 1;
inline void ParkingSlot::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ParkingSlot::id() const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlot.id)
  return id_;
}
inline void ParkingSlot::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.ParkingSlot.id)
}

// int32 valid = 2;
inline void ParkingSlot::clear_valid() {
  valid_ = 0;
}
inline ::google::protobuf::int32 ParkingSlot::valid() const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlot.valid)
  return valid_;
}
inline void ParkingSlot::set_valid(::google::protobuf::int32 value) {
  
  valid_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.ParkingSlot.valid)
}

// float conf = 3;
inline void ParkingSlot::clear_conf() {
  conf_ = 0;
}
inline float ParkingSlot::conf() const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlot.conf)
  return conf_;
}
inline void ParkingSlot::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.ParkingSlot.conf)
}

// .patac_hpp.ParkingSlotType type = 4;
inline void ParkingSlot::clear_type() {
  type_ = 0;
}
inline ::patac_hpp::ParkingSlotType ParkingSlot::type() const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlot.type)
  return static_cast< ::patac_hpp::ParkingSlotType >(type_);
}
inline void ParkingSlot::set_type(::patac_hpp::ParkingSlotType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.ParkingSlot.type)
}

// .patac_hpp.OccupancyStatus occupancy = 5;
inline void ParkingSlot::clear_occupancy() {
  occupancy_ = 0;
}
inline ::patac_hpp::OccupancyStatus ParkingSlot::occupancy() const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlot.occupancy)
  return static_cast< ::patac_hpp::OccupancyStatus >(occupancy_);
}
inline void ParkingSlot::set_occupancy(::patac_hpp::OccupancyStatus value) {
  
  occupancy_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.ParkingSlot.occupancy)
}

// repeated .patac_hpp.Point2f points = 6;
inline int ParkingSlot::points_size() const {
  return points_.size();
}
inline void ParkingSlot::clear_points() {
  points_.Clear();
}
inline const ::patac_hpp::Point2f& ParkingSlot::points(int index) const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlot.points)
  return points_.Get(index);
}
inline ::patac_hpp::Point2f* ParkingSlot::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:patac_hpp.ParkingSlot.points)
  return points_.Mutable(index);
}
inline ::patac_hpp::Point2f* ParkingSlot::add_points() {
  // @@protoc_insertion_point(field_add:patac_hpp.ParkingSlot.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::patac_hpp::Point2f >*
ParkingSlot::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:patac_hpp.ParkingSlot.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::patac_hpp::Point2f >&
ParkingSlot::points() const {
  // @@protoc_insertion_point(field_list:patac_hpp.ParkingSlot.points)
  return points_;
}

// float planning_score = 7;
inline void ParkingSlot::clear_planning_score() {
  planning_score_ = 0;
}
inline float ParkingSlot::planning_score() const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlot.planning_score)
  return planning_score_;
}
inline void ParkingSlot::set_planning_score(float value) {
  
  planning_score_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.ParkingSlot.planning_score)
}

// .patac_hpp.ParkingSource source = 8;
inline void ParkingSlot::clear_source() {
  source_ = 0;
}
inline ::patac_hpp::ParkingSource ParkingSlot::source() const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlot.source)
  return static_cast< ::patac_hpp::ParkingSource >(source_);
}
inline void ParkingSlot::set_source(::patac_hpp::ParkingSource value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.ParkingSlot.source)
}

// .patac_hpp.ParkingLockStatus lock_status = 9;
inline void ParkingSlot::clear_lock_status() {
  lock_status_ = 0;
}
inline ::patac_hpp::ParkingLockStatus ParkingSlot::lock_status() const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlot.lock_status)
  return static_cast< ::patac_hpp::ParkingLockStatus >(lock_status_);
}
inline void ParkingSlot::set_lock_status(::patac_hpp::ParkingLockStatus value) {
  
  lock_status_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.ParkingSlot.lock_status)
}

// -------------------------------------------------------------------

// ParkingSlotList

// uint32 num_parking_slot = 1;
inline void ParkingSlotList::clear_num_parking_slot() {
  num_parking_slot_ = 0u;
}
inline ::google::protobuf::uint32 ParkingSlotList::num_parking_slot() const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlotList.num_parking_slot)
  return num_parking_slot_;
}
inline void ParkingSlotList::set_num_parking_slot(::google::protobuf::uint32 value) {
  
  num_parking_slot_ = value;
  // @@protoc_insertion_point(field_set:patac_hpp.ParkingSlotList.num_parking_slot)
}

// repeated .patac_hpp.ParkingSlot parking_slot_list = 2;
inline int ParkingSlotList::parking_slot_list_size() const {
  return parking_slot_list_.size();
}
inline void ParkingSlotList::clear_parking_slot_list() {
  parking_slot_list_.Clear();
}
inline const ::patac_hpp::ParkingSlot& ParkingSlotList::parking_slot_list(int index) const {
  // @@protoc_insertion_point(field_get:patac_hpp.ParkingSlotList.parking_slot_list)
  return parking_slot_list_.Get(index);
}
inline ::patac_hpp::ParkingSlot* ParkingSlotList::mutable_parking_slot_list(int index) {
  // @@protoc_insertion_point(field_mutable:patac_hpp.ParkingSlotList.parking_slot_list)
  return parking_slot_list_.Mutable(index);
}
inline ::patac_hpp::ParkingSlot* ParkingSlotList::add_parking_slot_list() {
  // @@protoc_insertion_point(field_add:patac_hpp.ParkingSlotList.parking_slot_list)
  return parking_slot_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::patac_hpp::ParkingSlot >*
ParkingSlotList::mutable_parking_slot_list() {
  // @@protoc_insertion_point(field_mutable_list:patac_hpp.ParkingSlotList.parking_slot_list)
  return &parking_slot_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::patac_hpp::ParkingSlot >&
ParkingSlotList::parking_slot_list() const {
  // @@protoc_insertion_point(field_list:patac_hpp.ParkingSlotList.parking_slot_list)
  return parking_slot_list_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace patac_hpp

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::patac_hpp::ParkingSlotType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::patac_hpp::ParkingSlotType>() {
  return ::patac_hpp::ParkingSlotType_descriptor();
}
template <> struct is_proto_enum< ::patac_hpp::OccupancyStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::patac_hpp::OccupancyStatus>() {
  return ::patac_hpp::OccupancyStatus_descriptor();
}
template <> struct is_proto_enum< ::patac_hpp::ParkingSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::patac_hpp::ParkingSource>() {
  return ::patac_hpp::ParkingSource_descriptor();
}
template <> struct is_proto_enum< ::patac_hpp::ParkingLockStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::patac_hpp::ParkingLockStatus>() {
  return ::patac_hpp::ParkingLockStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_patac_5fslot_2eproto__INCLUDED
