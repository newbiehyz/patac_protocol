// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: refrence_lines.proto

#ifndef PROTOBUF_refrence_5flines_2eproto__INCLUDED
#define PROTOBUF_refrence_5flines_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
#include "common.pb.h"
#include "loc_odo.pb.h"
#include "ndm_base.pb.h"
#include "odometry_data.pb.h"
#include "map_display.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_refrence_5flines_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRefLineWayPointGlobalImpl();
void InitDefaultsRefLineWayPointGlobal();
void InitDefaultsRefLineWayPointFrameGlobalImpl();
void InitDefaultsRefLineWayPointFrameGlobal();
void InitDefaultsReferenceLinePointImpl();
void InitDefaultsReferenceLinePoint();
void InitDefaultsRefLineImpl();
void InitDefaultsRefLine();
void InitDefaultsReferenceLinesMsgImpl();
void InitDefaultsReferenceLinesMsg();
inline void InitDefaults() {
  InitDefaultsRefLineWayPointGlobal();
  InitDefaultsRefLineWayPointFrameGlobal();
  InitDefaultsReferenceLinePoint();
  InitDefaultsRefLine();
  InitDefaultsReferenceLinesMsg();
}
}  // namespace protobuf_refrence_5flines_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
class RefLine;
class RefLineDefaultTypeInternal;
extern RefLineDefaultTypeInternal _RefLine_default_instance_;
class RefLineWayPointFrameGlobal;
class RefLineWayPointFrameGlobalDefaultTypeInternal;
extern RefLineWayPointFrameGlobalDefaultTypeInternal _RefLineWayPointFrameGlobal_default_instance_;
class RefLineWayPointGlobal;
class RefLineWayPointGlobalDefaultTypeInternal;
extern RefLineWayPointGlobalDefaultTypeInternal _RefLineWayPointGlobal_default_instance_;
class ReferenceLinePoint;
class ReferenceLinePointDefaultTypeInternal;
extern ReferenceLinePointDefaultTypeInternal _ReferenceLinePoint_default_instance_;
class ReferenceLinesMsg;
class ReferenceLinesMsgDefaultTypeInternal;
extern ReferenceLinesMsgDefaultTypeInternal _ReferenceLinesMsg_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {

enum RefLineWayPointGlobal_WaypointDir {
  RefLineWayPointGlobal_WaypointDir_kWaypointDirForward = 0,
  RefLineWayPointGlobal_WaypointDir_kWaypointDirBackward = 1,
  RefLineWayPointGlobal_WaypointDir_RefLineWayPointGlobal_WaypointDir_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RefLineWayPointGlobal_WaypointDir_RefLineWayPointGlobal_WaypointDir_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RefLineWayPointGlobal_WaypointDir_IsValid(int value);
const RefLineWayPointGlobal_WaypointDir RefLineWayPointGlobal_WaypointDir_WaypointDir_MIN = RefLineWayPointGlobal_WaypointDir_kWaypointDirForward;
const RefLineWayPointGlobal_WaypointDir RefLineWayPointGlobal_WaypointDir_WaypointDir_MAX = RefLineWayPointGlobal_WaypointDir_kWaypointDirBackward;
const int RefLineWayPointGlobal_WaypointDir_WaypointDir_ARRAYSIZE = RefLineWayPointGlobal_WaypointDir_WaypointDir_MAX + 1;

const ::google::protobuf::EnumDescriptor* RefLineWayPointGlobal_WaypointDir_descriptor();
inline const ::std::string& RefLineWayPointGlobal_WaypointDir_Name(RefLineWayPointGlobal_WaypointDir value) {
  return ::google::protobuf::internal::NameOfEnum(
    RefLineWayPointGlobal_WaypointDir_descriptor(), value);
}
inline bool RefLineWayPointGlobal_WaypointDir_Parse(
    const ::std::string& name, RefLineWayPointGlobal_WaypointDir* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RefLineWayPointGlobal_WaypointDir>(
    RefLineWayPointGlobal_WaypointDir_descriptor(), name, value);
}
enum VertexType {
  kVertexTypeUnknown = 0,
  kVertexTypeNoVertex = 1,
  kVertexTypeVertexDist = 2,
  kVertexTypeVertexYaw = 3,
  kVertexTypeVertexPitch = 4,
  VertexType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VertexType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VertexType_IsValid(int value);
const VertexType VertexType_MIN = kVertexTypeUnknown;
const VertexType VertexType_MAX = kVertexTypeVertexPitch;
const int VertexType_ARRAYSIZE = VertexType_MAX + 1;

const ::google::protobuf::EnumDescriptor* VertexType_descriptor();
inline const ::std::string& VertexType_Name(VertexType value) {
  return ::google::protobuf::internal::NameOfEnum(
    VertexType_descriptor(), value);
}
inline bool VertexType_Parse(
    const ::std::string& name, VertexType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VertexType>(
    VertexType_descriptor(), name, value);
}
// ===================================================================

class RefLineWayPointGlobal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.RefLineWayPointGlobal) */ {
 public:
  RefLineWayPointGlobal();
  virtual ~RefLineWayPointGlobal();

  RefLineWayPointGlobal(const RefLineWayPointGlobal& from);

  inline RefLineWayPointGlobal& operator=(const RefLineWayPointGlobal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RefLineWayPointGlobal(RefLineWayPointGlobal&& from) noexcept
    : RefLineWayPointGlobal() {
    *this = ::std::move(from);
  }

  inline RefLineWayPointGlobal& operator=(RefLineWayPointGlobal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RefLineWayPointGlobal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefLineWayPointGlobal* internal_default_instance() {
    return reinterpret_cast<const RefLineWayPointGlobal*>(
               &_RefLineWayPointGlobal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RefLineWayPointGlobal* other);
  friend void swap(RefLineWayPointGlobal& a, RefLineWayPointGlobal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RefLineWayPointGlobal* New() const PROTOBUF_FINAL { return New(NULL); }

  RefLineWayPointGlobal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RefLineWayPointGlobal& from);
  void MergeFrom(const RefLineWayPointGlobal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RefLineWayPointGlobal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RefLineWayPointGlobal_WaypointDir WaypointDir;
  static const WaypointDir kWaypointDirForward =
    RefLineWayPointGlobal_WaypointDir_kWaypointDirForward;
  static const WaypointDir kWaypointDirBackward =
    RefLineWayPointGlobal_WaypointDir_kWaypointDirBackward;
  static inline bool WaypointDir_IsValid(int value) {
    return RefLineWayPointGlobal_WaypointDir_IsValid(value);
  }
  static const WaypointDir WaypointDir_MIN =
    RefLineWayPointGlobal_WaypointDir_WaypointDir_MIN;
  static const WaypointDir WaypointDir_MAX =
    RefLineWayPointGlobal_WaypointDir_WaypointDir_MAX;
  static const int WaypointDir_ARRAYSIZE =
    RefLineWayPointGlobal_WaypointDir_WaypointDir_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WaypointDir_descriptor() {
    return RefLineWayPointGlobal_WaypointDir_descriptor();
  }
  static inline const ::std::string& WaypointDir_Name(WaypointDir value) {
    return RefLineWayPointGlobal_WaypointDir_Name(value);
  }
  static inline bool WaypointDir_Parse(const ::std::string& name,
      WaypointDir* value) {
    return RefLineWayPointGlobal_WaypointDir_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.Vector3f waypoint_position = 1;
  bool has_waypoint_position() const;
  void clear_waypoint_position();
  static const int kWaypointPositionFieldNumber = 1;
  const ::autodrive::workflow::proto::Vector3f& waypoint_position() const;
  ::autodrive::workflow::proto::Vector3f* release_waypoint_position();
  ::autodrive::workflow::proto::Vector3f* mutable_waypoint_position();
  void set_allocated_waypoint_position(::autodrive::workflow::proto::Vector3f* waypoint_position);

  // float waypoint_yaw = 2;
  void clear_waypoint_yaw();
  static const int kWaypointYawFieldNumber = 2;
  float waypoint_yaw() const;
  void set_waypoint_yaw(float value);

  // float waypoint_curv = 3;
  void clear_waypoint_curv();
  static const int kWaypointCurvFieldNumber = 3;
  float waypoint_curv() const;
  void set_waypoint_curv(float value);

  // float waypoint_curvrate = 4;
  void clear_waypoint_curvrate();
  static const int kWaypointCurvrateFieldNumber = 4;
  float waypoint_curvrate() const;
  void set_waypoint_curvrate(float value);

  // float waypoint_speed = 5;
  void clear_waypoint_speed();
  static const int kWaypointSpeedFieldNumber = 5;
  float waypoint_speed() const;
  void set_waypoint_speed(float value);

  // uint32 waypoint_num = 6;
  void clear_waypoint_num();
  static const int kWaypointNumFieldNumber = 6;
  ::google::protobuf::uint32 waypoint_num() const;
  void set_waypoint_num(::google::protobuf::uint32 value);

  // float waypoint_dist = 7;
  void clear_waypoint_dist();
  static const int kWaypointDistFieldNumber = 7;
  float waypoint_dist() const;
  void set_waypoint_dist(float value);

  // .autodrive.workflow.proto.RefLineWayPointGlobal.WaypointDir waypoint_dir = 8;
  void clear_waypoint_dir();
  static const int kWaypointDirFieldNumber = 8;
  ::autodrive::workflow::proto::RefLineWayPointGlobal_WaypointDir waypoint_dir() const;
  void set_waypoint_dir(::autodrive::workflow::proto::RefLineWayPointGlobal_WaypointDir value);

  // bool waypoint_locked = 9;
  void clear_waypoint_locked();
  static const int kWaypointLockedFieldNumber = 9;
  bool waypoint_locked() const;
  void set_waypoint_locked(bool value);

  // bool is_map_origin = 10;
  void clear_is_map_origin();
  static const int kIsMapOriginFieldNumber = 10;
  bool is_map_origin() const;
  void set_is_map_origin(bool value);

  // bool is_intersection = 11;
  void clear_is_intersection();
  static const int kIsIntersectionFieldNumber = 11;
  bool is_intersection() const;
  void set_is_intersection(bool value);

  // bool is_parking_gate = 15;
  void clear_is_parking_gate();
  static const int kIsParkingGateFieldNumber = 15;
  bool is_parking_gate() const;
  void set_is_parking_gate(bool value);

  // .autodrive.workflow.proto.TurningLightStatus left_turning_light_status = 12;
  void clear_left_turning_light_status();
  static const int kLeftTurningLightStatusFieldNumber = 12;
  ::autodrive::workflow::proto::TurningLightStatus left_turning_light_status() const;
  void set_left_turning_light_status(::autodrive::workflow::proto::TurningLightStatus value);

  // .autodrive.workflow.proto.TurningLightStatus right_turning_light_status = 13;
  void clear_right_turning_light_status();
  static const int kRightTurningLightStatusFieldNumber = 13;
  ::autodrive::workflow::proto::TurningLightStatus right_turning_light_status() const;
  void set_right_turning_light_status(::autodrive::workflow::proto::TurningLightStatus value);

  // float waypoint_floor = 14;
  void clear_waypoint_floor();
  static const int kWaypointFloorFieldNumber = 14;
  float waypoint_floor() const;
  void set_waypoint_floor(float value);

  // bool is_speed_bump = 16;
  void clear_is_speed_bump();
  static const int kIsSpeedBumpFieldNumber = 16;
  bool is_speed_bump() const;
  void set_is_speed_bump(bool value);

  // float left_bound_distance = 17;
  void clear_left_bound_distance();
  static const int kLeftBoundDistanceFieldNumber = 17;
  float left_bound_distance() const;
  void set_left_bound_distance(float value);

  // float right_bound_distance = 18;
  void clear_right_bound_distance();
  static const int kRightBoundDistanceFieldNumber = 18;
  float right_bound_distance() const;
  void set_right_bound_distance(float value);

  // float waypoint_pitch = 19;
  void clear_waypoint_pitch();
  static const int kWaypointPitchFieldNumber = 19;
  float waypoint_pitch() const;
  void set_waypoint_pitch(float value);

  // float waypoint_roll = 20;
  void clear_waypoint_roll();
  static const int kWaypointRollFieldNumber = 20;
  float waypoint_roll() const;
  void set_waypoint_roll(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.RefLineWayPointGlobal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::Vector3f* waypoint_position_;
  float waypoint_yaw_;
  float waypoint_curv_;
  float waypoint_curvrate_;
  float waypoint_speed_;
  ::google::protobuf::uint32 waypoint_num_;
  float waypoint_dist_;
  int waypoint_dir_;
  bool waypoint_locked_;
  bool is_map_origin_;
  bool is_intersection_;
  bool is_parking_gate_;
  int left_turning_light_status_;
  int right_turning_light_status_;
  float waypoint_floor_;
  bool is_speed_bump_;
  float left_bound_distance_;
  float right_bound_distance_;
  float waypoint_pitch_;
  float waypoint_roll_;
  mutable int _cached_size_;
  friend struct ::protobuf_refrence_5flines_2eproto::TableStruct;
  friend void ::protobuf_refrence_5flines_2eproto::InitDefaultsRefLineWayPointGlobalImpl();
};
// -------------------------------------------------------------------

class RefLineWayPointFrameGlobal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.RefLineWayPointFrameGlobal) */ {
 public:
  RefLineWayPointFrameGlobal();
  virtual ~RefLineWayPointFrameGlobal();

  RefLineWayPointFrameGlobal(const RefLineWayPointFrameGlobal& from);

  inline RefLineWayPointFrameGlobal& operator=(const RefLineWayPointFrameGlobal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RefLineWayPointFrameGlobal(RefLineWayPointFrameGlobal&& from) noexcept
    : RefLineWayPointFrameGlobal() {
    *this = ::std::move(from);
  }

  inline RefLineWayPointFrameGlobal& operator=(RefLineWayPointFrameGlobal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RefLineWayPointFrameGlobal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefLineWayPointFrameGlobal* internal_default_instance() {
    return reinterpret_cast<const RefLineWayPointFrameGlobal*>(
               &_RefLineWayPointFrameGlobal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RefLineWayPointFrameGlobal* other);
  friend void swap(RefLineWayPointFrameGlobal& a, RefLineWayPointFrameGlobal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RefLineWayPointFrameGlobal* New() const PROTOBUF_FINAL { return New(NULL); }

  RefLineWayPointFrameGlobal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RefLineWayPointFrameGlobal& from);
  void MergeFrom(const RefLineWayPointFrameGlobal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RefLineWayPointFrameGlobal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.RefLineWayPointGlobal way_points = 2;
  int way_points_size() const;
  void clear_way_points();
  static const int kWayPointsFieldNumber = 2;
  const ::autodrive::workflow::proto::RefLineWayPointGlobal& way_points(int index) const;
  ::autodrive::workflow::proto::RefLineWayPointGlobal* mutable_way_points(int index);
  ::autodrive::workflow::proto::RefLineWayPointGlobal* add_way_points();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RefLineWayPointGlobal >*
      mutable_way_points();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RefLineWayPointGlobal >&
      way_points() const;

  // uint32 waypoint_id = 1;
  void clear_waypoint_id();
  static const int kWaypointIdFieldNumber = 1;
  ::google::protobuf::uint32 waypoint_id() const;
  void set_waypoint_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.RefLineWayPointFrameGlobal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RefLineWayPointGlobal > way_points_;
  ::google::protobuf::uint32 waypoint_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_refrence_5flines_2eproto::TableStruct;
  friend void ::protobuf_refrence_5flines_2eproto::InitDefaultsRefLineWayPointFrameGlobalImpl();
};
// -------------------------------------------------------------------

class ReferenceLinePoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ReferenceLinePoint) */ {
 public:
  ReferenceLinePoint();
  virtual ~ReferenceLinePoint();

  ReferenceLinePoint(const ReferenceLinePoint& from);

  inline ReferenceLinePoint& operator=(const ReferenceLinePoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReferenceLinePoint(ReferenceLinePoint&& from) noexcept
    : ReferenceLinePoint() {
    *this = ::std::move(from);
  }

  inline ReferenceLinePoint& operator=(ReferenceLinePoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceLinePoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceLinePoint* internal_default_instance() {
    return reinterpret_cast<const ReferenceLinePoint*>(
               &_ReferenceLinePoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ReferenceLinePoint* other);
  friend void swap(ReferenceLinePoint& a, ReferenceLinePoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReferenceLinePoint* New() const PROTOBUF_FINAL { return New(NULL); }

  ReferenceLinePoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReferenceLinePoint& from);
  void MergeFrom(const ReferenceLinePoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReferenceLinePoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string str_obj_id = 8;
  void clear_str_obj_id();
  static const int kStrObjIdFieldNumber = 8;
  const ::std::string& str_obj_id() const;
  void set_str_obj_id(const ::std::string& value);
  #if LANG_CXX11
  void set_str_obj_id(::std::string&& value);
  #endif
  void set_str_obj_id(const char* value);
  void set_str_obj_id(const char* value, size_t size);
  ::std::string* mutable_str_obj_id();
  ::std::string* release_str_obj_id();
  void set_allocated_str_obj_id(::std::string* str_obj_id);

  // .autodrive.workflow.proto.loc_odo.Odometry odo = 1;
  bool has_odo() const;
  void clear_odo();
  static const int kOdoFieldNumber = 1;
  const ::autodrive::workflow::proto::loc_odo::Odometry& odo() const;
  ::autodrive::workflow::proto::loc_odo::Odometry* release_odo();
  ::autodrive::workflow::proto::loc_odo::Odometry* mutable_odo();
  void set_allocated_odo(::autodrive::workflow::proto::loc_odo::Odometry* odo);

  // float pitch = 2;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  float pitch() const;
  void set_pitch(float value);

  // int32 num_sates = 3;
  void clear_num_sates();
  static const int kNumSatesFieldNumber = 3;
  ::google::protobuf::int32 num_sates() const;
  void set_num_sates(::google::protobuf::int32 value);

  // int32 floor_num = 4;
  void clear_floor_num();
  static const int kFloorNumFieldNumber = 4;
  ::google::protobuf::int32 floor_num() const;
  void set_floor_num(::google::protobuf::int32 value);

  // .autodrive.workflow.proto.VertexType vertex_type = 5;
  void clear_vertex_type();
  static const int kVertexTypeFieldNumber = 5;
  ::autodrive::workflow::proto::VertexType vertex_type() const;
  void set_vertex_type(::autodrive::workflow::proto::VertexType value);

  // bool has_map = 6;
  void clear_has_map();
  static const int kHasMapFieldNumber = 6;
  bool has_map() const;
  void set_has_map(bool value);

  // bool init_loc_region = 7;
  void clear_init_loc_region();
  static const int kInitLocRegionFieldNumber = 7;
  bool init_loc_region() const;
  void set_init_loc_region(bool value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ReferenceLinePoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr str_obj_id_;
  ::autodrive::workflow::proto::loc_odo::Odometry* odo_;
  float pitch_;
  ::google::protobuf::int32 num_sates_;
  ::google::protobuf::int32 floor_num_;
  int vertex_type_;
  bool has_map_;
  bool init_loc_region_;
  mutable int _cached_size_;
  friend struct ::protobuf_refrence_5flines_2eproto::TableStruct;
  friend void ::protobuf_refrence_5flines_2eproto::InitDefaultsReferenceLinePointImpl();
};
// -------------------------------------------------------------------

class RefLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.RefLine) */ {
 public:
  RefLine();
  virtual ~RefLine();

  RefLine(const RefLine& from);

  inline RefLine& operator=(const RefLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RefLine(RefLine&& from) noexcept
    : RefLine() {
    *this = ::std::move(from);
  }

  inline RefLine& operator=(RefLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RefLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefLine* internal_default_instance() {
    return reinterpret_cast<const RefLine*>(
               &_RefLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RefLine* other);
  friend void swap(RefLine& a, RefLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RefLine* New() const PROTOBUF_FINAL { return New(NULL); }

  RefLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RefLine& from);
  void MergeFrom(const RefLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RefLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.ReferenceLinePoint reference_points = 3;
  int reference_points_size() const;
  void clear_reference_points();
  static const int kReferencePointsFieldNumber = 3;
  const ::autodrive::workflow::proto::ReferenceLinePoint& reference_points(int index) const;
  ::autodrive::workflow::proto::ReferenceLinePoint* mutable_reference_points(int index);
  ::autodrive::workflow::proto::ReferenceLinePoint* add_reference_points();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ReferenceLinePoint >*
      mutable_reference_points();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ReferenceLinePoint >&
      reference_points() const;

  // string header = 2;
  void clear_header();
  static const int kHeaderFieldNumber = 2;
  const ::std::string& header() const;
  void set_header(const ::std::string& value);
  #if LANG_CXX11
  void set_header(::std::string&& value);
  #endif
  void set_header(const char* value);
  void set_header(const char* value, size_t size);
  ::std::string* mutable_header();
  ::std::string* release_header();
  void set_allocated_header(::std::string* header);

  // int32 map_floor_num = 1;
  void clear_map_floor_num();
  static const int kMapFloorNumFieldNumber = 1;
  ::google::protobuf::int32 map_floor_num() const;
  void set_map_floor_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.RefLine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ReferenceLinePoint > reference_points_;
  ::google::protobuf::internal::ArenaStringPtr header_;
  ::google::protobuf::int32 map_floor_num_;
  mutable int _cached_size_;
  friend struct ::protobuf_refrence_5flines_2eproto::TableStruct;
  friend void ::protobuf_refrence_5flines_2eproto::InitDefaultsRefLineImpl();
};
// -------------------------------------------------------------------

class ReferenceLinesMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ReferenceLinesMsg) */ {
 public:
  ReferenceLinesMsg();
  virtual ~ReferenceLinesMsg();

  ReferenceLinesMsg(const ReferenceLinesMsg& from);

  inline ReferenceLinesMsg& operator=(const ReferenceLinesMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReferenceLinesMsg(ReferenceLinesMsg&& from) noexcept
    : ReferenceLinesMsg() {
    *this = ::std::move(from);
  }

  inline ReferenceLinesMsg& operator=(ReferenceLinesMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceLinesMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceLinesMsg* internal_default_instance() {
    return reinterpret_cast<const ReferenceLinesMsg*>(
               &_ReferenceLinesMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ReferenceLinesMsg* other);
  friend void swap(ReferenceLinesMsg& a, ReferenceLinesMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReferenceLinesMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  ReferenceLinesMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReferenceLinesMsg& from);
  void MergeFrom(const ReferenceLinesMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReferenceLinesMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.MsgHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::MsgHeader& header() const;
  ::autodrive::workflow::proto::MsgHeader* release_header();
  ::autodrive::workflow::proto::MsgHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::MsgHeader* header);

  // .autodrive.workflow.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::autodrive::workflow::proto::Error& error() const;
  ::autodrive::workflow::proto::Error* release_error();
  ::autodrive::workflow::proto::Error* mutable_error();
  void set_allocated_error(::autodrive::workflow::proto::Error* error);

  // .autodrive.workflow.proto.RefLineWayPointFrameGlobal waypoint_frame_global_raw = 3;
  bool has_waypoint_frame_global_raw() const;
  void clear_waypoint_frame_global_raw();
  static const int kWaypointFrameGlobalRawFieldNumber = 3;
  const ::autodrive::workflow::proto::RefLineWayPointFrameGlobal& waypoint_frame_global_raw() const;
  ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* release_waypoint_frame_global_raw();
  ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* mutable_waypoint_frame_global_raw();
  void set_allocated_waypoint_frame_global_raw(::autodrive::workflow::proto::RefLineWayPointFrameGlobal* waypoint_frame_global_raw);

  // .autodrive.workflow.proto.RefLineWayPointFrameGlobal waypoint_frame_global = 4;
  bool has_waypoint_frame_global() const;
  void clear_waypoint_frame_global();
  static const int kWaypointFrameGlobalFieldNumber = 4;
  const ::autodrive::workflow::proto::RefLineWayPointFrameGlobal& waypoint_frame_global() const;
  ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* release_waypoint_frame_global();
  ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* mutable_waypoint_frame_global();
  void set_allocated_waypoint_frame_global(::autodrive::workflow::proto::RefLineWayPointFrameGlobal* waypoint_frame_global);

  // .autodrive.workflow.proto.GlbPrkgSlot parking_slot = 5;
  bool has_parking_slot() const;
  void clear_parking_slot();
  static const int kParkingSlotFieldNumber = 5;
  const ::autodrive::workflow::proto::GlbPrkgSlot& parking_slot() const;
  ::autodrive::workflow::proto::GlbPrkgSlot* release_parking_slot();
  ::autodrive::workflow::proto::GlbPrkgSlot* mutable_parking_slot();
  void set_allocated_parking_slot(::autodrive::workflow::proto::GlbPrkgSlot* parking_slot);

  // .autodrive.workflow.proto.RefLine reference_line = 6;
  bool has_reference_line() const;
  void clear_reference_line();
  static const int kReferenceLineFieldNumber = 6;
  const ::autodrive::workflow::proto::RefLine& reference_line() const;
  ::autodrive::workflow::proto::RefLine* release_reference_line();
  ::autodrive::workflow::proto::RefLine* mutable_reference_line();
  void set_allocated_reference_line(::autodrive::workflow::proto::RefLine* reference_line);

  // .autodrive.workflow.proto.ndm_base.NdmSpec ndm_header = 7;
  bool has_ndm_header() const;
  void clear_ndm_header();
  static const int kNdmHeaderFieldNumber = 7;
  const ::autodrive::workflow::proto::ndm_base::NdmSpec& ndm_header() const;
  ::autodrive::workflow::proto::ndm_base::NdmSpec* release_ndm_header();
  ::autodrive::workflow::proto::ndm_base::NdmSpec* mutable_ndm_header();
  void set_allocated_ndm_header(::autodrive::workflow::proto::ndm_base::NdmSpec* ndm_header);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ReferenceLinesMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::MsgHeader* header_;
  ::autodrive::workflow::proto::Error* error_;
  ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* waypoint_frame_global_raw_;
  ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* waypoint_frame_global_;
  ::autodrive::workflow::proto::GlbPrkgSlot* parking_slot_;
  ::autodrive::workflow::proto::RefLine* reference_line_;
  ::autodrive::workflow::proto::ndm_base::NdmSpec* ndm_header_;
  mutable int _cached_size_;
  friend struct ::protobuf_refrence_5flines_2eproto::TableStruct;
  friend void ::protobuf_refrence_5flines_2eproto::InitDefaultsReferenceLinesMsgImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RefLineWayPointGlobal

// .autodrive.workflow.proto.Vector3f waypoint_position = 1;
inline bool RefLineWayPointGlobal::has_waypoint_position() const {
  return this != internal_default_instance() && waypoint_position_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& RefLineWayPointGlobal::waypoint_position() const {
  const ::autodrive::workflow::proto::Vector3f* p = waypoint_position_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_position)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* RefLineWayPointGlobal::release_waypoint_position() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_position)
  
  ::autodrive::workflow::proto::Vector3f* temp = waypoint_position_;
  waypoint_position_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* RefLineWayPointGlobal::mutable_waypoint_position() {
  
  if (waypoint_position_ == NULL) {
    waypoint_position_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_position)
  return waypoint_position_;
}
inline void RefLineWayPointGlobal::set_allocated_waypoint_position(::autodrive::workflow::proto::Vector3f* waypoint_position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(waypoint_position_);
  }
  if (waypoint_position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      waypoint_position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, waypoint_position, submessage_arena);
    }
    
  } else {
    
  }
  waypoint_position_ = waypoint_position;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_position)
}

// float waypoint_yaw = 2;
inline void RefLineWayPointGlobal::clear_waypoint_yaw() {
  waypoint_yaw_ = 0;
}
inline float RefLineWayPointGlobal::waypoint_yaw() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_yaw)
  return waypoint_yaw_;
}
inline void RefLineWayPointGlobal::set_waypoint_yaw(float value) {
  
  waypoint_yaw_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_yaw)
}

// float waypoint_curv = 3;
inline void RefLineWayPointGlobal::clear_waypoint_curv() {
  waypoint_curv_ = 0;
}
inline float RefLineWayPointGlobal::waypoint_curv() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_curv)
  return waypoint_curv_;
}
inline void RefLineWayPointGlobal::set_waypoint_curv(float value) {
  
  waypoint_curv_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_curv)
}

// float waypoint_curvrate = 4;
inline void RefLineWayPointGlobal::clear_waypoint_curvrate() {
  waypoint_curvrate_ = 0;
}
inline float RefLineWayPointGlobal::waypoint_curvrate() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_curvrate)
  return waypoint_curvrate_;
}
inline void RefLineWayPointGlobal::set_waypoint_curvrate(float value) {
  
  waypoint_curvrate_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_curvrate)
}

// float waypoint_speed = 5;
inline void RefLineWayPointGlobal::clear_waypoint_speed() {
  waypoint_speed_ = 0;
}
inline float RefLineWayPointGlobal::waypoint_speed() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_speed)
  return waypoint_speed_;
}
inline void RefLineWayPointGlobal::set_waypoint_speed(float value) {
  
  waypoint_speed_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_speed)
}

// uint32 waypoint_num = 6;
inline void RefLineWayPointGlobal::clear_waypoint_num() {
  waypoint_num_ = 0u;
}
inline ::google::protobuf::uint32 RefLineWayPointGlobal::waypoint_num() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_num)
  return waypoint_num_;
}
inline void RefLineWayPointGlobal::set_waypoint_num(::google::protobuf::uint32 value) {
  
  waypoint_num_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_num)
}

// float waypoint_dist = 7;
inline void RefLineWayPointGlobal::clear_waypoint_dist() {
  waypoint_dist_ = 0;
}
inline float RefLineWayPointGlobal::waypoint_dist() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_dist)
  return waypoint_dist_;
}
inline void RefLineWayPointGlobal::set_waypoint_dist(float value) {
  
  waypoint_dist_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_dist)
}

// .autodrive.workflow.proto.RefLineWayPointGlobal.WaypointDir waypoint_dir = 8;
inline void RefLineWayPointGlobal::clear_waypoint_dir() {
  waypoint_dir_ = 0;
}
inline ::autodrive::workflow::proto::RefLineWayPointGlobal_WaypointDir RefLineWayPointGlobal::waypoint_dir() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_dir)
  return static_cast< ::autodrive::workflow::proto::RefLineWayPointGlobal_WaypointDir >(waypoint_dir_);
}
inline void RefLineWayPointGlobal::set_waypoint_dir(::autodrive::workflow::proto::RefLineWayPointGlobal_WaypointDir value) {
  
  waypoint_dir_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_dir)
}

// bool waypoint_locked = 9;
inline void RefLineWayPointGlobal::clear_waypoint_locked() {
  waypoint_locked_ = false;
}
inline bool RefLineWayPointGlobal::waypoint_locked() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_locked)
  return waypoint_locked_;
}
inline void RefLineWayPointGlobal::set_waypoint_locked(bool value) {
  
  waypoint_locked_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_locked)
}

// bool is_map_origin = 10;
inline void RefLineWayPointGlobal::clear_is_map_origin() {
  is_map_origin_ = false;
}
inline bool RefLineWayPointGlobal::is_map_origin() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.is_map_origin)
  return is_map_origin_;
}
inline void RefLineWayPointGlobal::set_is_map_origin(bool value) {
  
  is_map_origin_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.is_map_origin)
}

// bool is_intersection = 11;
inline void RefLineWayPointGlobal::clear_is_intersection() {
  is_intersection_ = false;
}
inline bool RefLineWayPointGlobal::is_intersection() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.is_intersection)
  return is_intersection_;
}
inline void RefLineWayPointGlobal::set_is_intersection(bool value) {
  
  is_intersection_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.is_intersection)
}

// .autodrive.workflow.proto.TurningLightStatus left_turning_light_status = 12;
inline void RefLineWayPointGlobal::clear_left_turning_light_status() {
  left_turning_light_status_ = 0;
}
inline ::autodrive::workflow::proto::TurningLightStatus RefLineWayPointGlobal::left_turning_light_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.left_turning_light_status)
  return static_cast< ::autodrive::workflow::proto::TurningLightStatus >(left_turning_light_status_);
}
inline void RefLineWayPointGlobal::set_left_turning_light_status(::autodrive::workflow::proto::TurningLightStatus value) {
  
  left_turning_light_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.left_turning_light_status)
}

// .autodrive.workflow.proto.TurningLightStatus right_turning_light_status = 13;
inline void RefLineWayPointGlobal::clear_right_turning_light_status() {
  right_turning_light_status_ = 0;
}
inline ::autodrive::workflow::proto::TurningLightStatus RefLineWayPointGlobal::right_turning_light_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.right_turning_light_status)
  return static_cast< ::autodrive::workflow::proto::TurningLightStatus >(right_turning_light_status_);
}
inline void RefLineWayPointGlobal::set_right_turning_light_status(::autodrive::workflow::proto::TurningLightStatus value) {
  
  right_turning_light_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.right_turning_light_status)
}

// float waypoint_floor = 14;
inline void RefLineWayPointGlobal::clear_waypoint_floor() {
  waypoint_floor_ = 0;
}
inline float RefLineWayPointGlobal::waypoint_floor() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_floor)
  return waypoint_floor_;
}
inline void RefLineWayPointGlobal::set_waypoint_floor(float value) {
  
  waypoint_floor_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_floor)
}

// bool is_parking_gate = 15;
inline void RefLineWayPointGlobal::clear_is_parking_gate() {
  is_parking_gate_ = false;
}
inline bool RefLineWayPointGlobal::is_parking_gate() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.is_parking_gate)
  return is_parking_gate_;
}
inline void RefLineWayPointGlobal::set_is_parking_gate(bool value) {
  
  is_parking_gate_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.is_parking_gate)
}

// bool is_speed_bump = 16;
inline void RefLineWayPointGlobal::clear_is_speed_bump() {
  is_speed_bump_ = false;
}
inline bool RefLineWayPointGlobal::is_speed_bump() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.is_speed_bump)
  return is_speed_bump_;
}
inline void RefLineWayPointGlobal::set_is_speed_bump(bool value) {
  
  is_speed_bump_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.is_speed_bump)
}

// float left_bound_distance = 17;
inline void RefLineWayPointGlobal::clear_left_bound_distance() {
  left_bound_distance_ = 0;
}
inline float RefLineWayPointGlobal::left_bound_distance() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.left_bound_distance)
  return left_bound_distance_;
}
inline void RefLineWayPointGlobal::set_left_bound_distance(float value) {
  
  left_bound_distance_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.left_bound_distance)
}

// float right_bound_distance = 18;
inline void RefLineWayPointGlobal::clear_right_bound_distance() {
  right_bound_distance_ = 0;
}
inline float RefLineWayPointGlobal::right_bound_distance() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.right_bound_distance)
  return right_bound_distance_;
}
inline void RefLineWayPointGlobal::set_right_bound_distance(float value) {
  
  right_bound_distance_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.right_bound_distance)
}

// float waypoint_pitch = 19;
inline void RefLineWayPointGlobal::clear_waypoint_pitch() {
  waypoint_pitch_ = 0;
}
inline float RefLineWayPointGlobal::waypoint_pitch() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_pitch)
  return waypoint_pitch_;
}
inline void RefLineWayPointGlobal::set_waypoint_pitch(float value) {
  
  waypoint_pitch_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_pitch)
}

// float waypoint_roll = 20;
inline void RefLineWayPointGlobal::clear_waypoint_roll() {
  waypoint_roll_ = 0;
}
inline float RefLineWayPointGlobal::waypoint_roll() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_roll)
  return waypoint_roll_;
}
inline void RefLineWayPointGlobal::set_waypoint_roll(float value) {
  
  waypoint_roll_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointGlobal.waypoint_roll)
}

// -------------------------------------------------------------------

// RefLineWayPointFrameGlobal

// uint32 waypoint_id = 1;
inline void RefLineWayPointFrameGlobal::clear_waypoint_id() {
  waypoint_id_ = 0u;
}
inline ::google::protobuf::uint32 RefLineWayPointFrameGlobal::waypoint_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointFrameGlobal.waypoint_id)
  return waypoint_id_;
}
inline void RefLineWayPointFrameGlobal::set_waypoint_id(::google::protobuf::uint32 value) {
  
  waypoint_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLineWayPointFrameGlobal.waypoint_id)
}

// repeated .autodrive.workflow.proto.RefLineWayPointGlobal way_points = 2;
inline int RefLineWayPointFrameGlobal::way_points_size() const {
  return way_points_.size();
}
inline void RefLineWayPointFrameGlobal::clear_way_points() {
  way_points_.Clear();
}
inline const ::autodrive::workflow::proto::RefLineWayPointGlobal& RefLineWayPointFrameGlobal::way_points(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLineWayPointFrameGlobal.way_points)
  return way_points_.Get(index);
}
inline ::autodrive::workflow::proto::RefLineWayPointGlobal* RefLineWayPointFrameGlobal::mutable_way_points(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RefLineWayPointFrameGlobal.way_points)
  return way_points_.Mutable(index);
}
inline ::autodrive::workflow::proto::RefLineWayPointGlobal* RefLineWayPointFrameGlobal::add_way_points() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.RefLineWayPointFrameGlobal.way_points)
  return way_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RefLineWayPointGlobal >*
RefLineWayPointFrameGlobal::mutable_way_points() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.RefLineWayPointFrameGlobal.way_points)
  return &way_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RefLineWayPointGlobal >&
RefLineWayPointFrameGlobal::way_points() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.RefLineWayPointFrameGlobal.way_points)
  return way_points_;
}

// -------------------------------------------------------------------

// ReferenceLinePoint

// .autodrive.workflow.proto.loc_odo.Odometry odo = 1;
inline bool ReferenceLinePoint::has_odo() const {
  return this != internal_default_instance() && odo_ != NULL;
}
inline const ::autodrive::workflow::proto::loc_odo::Odometry& ReferenceLinePoint::odo() const {
  const ::autodrive::workflow::proto::loc_odo::Odometry* p = odo_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinePoint.odo)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::loc_odo::Odometry*>(
      &::autodrive::workflow::proto::loc_odo::_Odometry_default_instance_);
}
inline ::autodrive::workflow::proto::loc_odo::Odometry* ReferenceLinePoint::release_odo() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ReferenceLinePoint.odo)
  
  ::autodrive::workflow::proto::loc_odo::Odometry* temp = odo_;
  odo_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::loc_odo::Odometry* ReferenceLinePoint::mutable_odo() {
  
  if (odo_ == NULL) {
    odo_ = new ::autodrive::workflow::proto::loc_odo::Odometry;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ReferenceLinePoint.odo)
  return odo_;
}
inline void ReferenceLinePoint::set_allocated_odo(::autodrive::workflow::proto::loc_odo::Odometry* odo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(odo_);
  }
  if (odo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      odo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, odo, submessage_arena);
    }
    
  } else {
    
  }
  odo_ = odo;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ReferenceLinePoint.odo)
}

// float pitch = 2;
inline void ReferenceLinePoint::clear_pitch() {
  pitch_ = 0;
}
inline float ReferenceLinePoint::pitch() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinePoint.pitch)
  return pitch_;
}
inline void ReferenceLinePoint::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ReferenceLinePoint.pitch)
}

// int32 num_sates = 3;
inline void ReferenceLinePoint::clear_num_sates() {
  num_sates_ = 0;
}
inline ::google::protobuf::int32 ReferenceLinePoint::num_sates() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinePoint.num_sates)
  return num_sates_;
}
inline void ReferenceLinePoint::set_num_sates(::google::protobuf::int32 value) {
  
  num_sates_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ReferenceLinePoint.num_sates)
}

// int32 floor_num = 4;
inline void ReferenceLinePoint::clear_floor_num() {
  floor_num_ = 0;
}
inline ::google::protobuf::int32 ReferenceLinePoint::floor_num() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinePoint.floor_num)
  return floor_num_;
}
inline void ReferenceLinePoint::set_floor_num(::google::protobuf::int32 value) {
  
  floor_num_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ReferenceLinePoint.floor_num)
}

// .autodrive.workflow.proto.VertexType vertex_type = 5;
inline void ReferenceLinePoint::clear_vertex_type() {
  vertex_type_ = 0;
}
inline ::autodrive::workflow::proto::VertexType ReferenceLinePoint::vertex_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinePoint.vertex_type)
  return static_cast< ::autodrive::workflow::proto::VertexType >(vertex_type_);
}
inline void ReferenceLinePoint::set_vertex_type(::autodrive::workflow::proto::VertexType value) {
  
  vertex_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ReferenceLinePoint.vertex_type)
}

// bool has_map = 6;
inline void ReferenceLinePoint::clear_has_map() {
  has_map_ = false;
}
inline bool ReferenceLinePoint::has_map() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinePoint.has_map)
  return has_map_;
}
inline void ReferenceLinePoint::set_has_map(bool value) {
  
  has_map_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ReferenceLinePoint.has_map)
}

// bool init_loc_region = 7;
inline void ReferenceLinePoint::clear_init_loc_region() {
  init_loc_region_ = false;
}
inline bool ReferenceLinePoint::init_loc_region() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinePoint.init_loc_region)
  return init_loc_region_;
}
inline void ReferenceLinePoint::set_init_loc_region(bool value) {
  
  init_loc_region_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ReferenceLinePoint.init_loc_region)
}

// string str_obj_id = 8;
inline void ReferenceLinePoint::clear_str_obj_id() {
  str_obj_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReferenceLinePoint::str_obj_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinePoint.str_obj_id)
  return str_obj_id_.GetNoArena();
}
inline void ReferenceLinePoint::set_str_obj_id(const ::std::string& value) {
  
  str_obj_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ReferenceLinePoint.str_obj_id)
}
#if LANG_CXX11
inline void ReferenceLinePoint::set_str_obj_id(::std::string&& value) {
  
  str_obj_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.ReferenceLinePoint.str_obj_id)
}
#endif
inline void ReferenceLinePoint::set_str_obj_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  str_obj_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.ReferenceLinePoint.str_obj_id)
}
inline void ReferenceLinePoint::set_str_obj_id(const char* value, size_t size) {
  
  str_obj_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.ReferenceLinePoint.str_obj_id)
}
inline ::std::string* ReferenceLinePoint::mutable_str_obj_id() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ReferenceLinePoint.str_obj_id)
  return str_obj_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReferenceLinePoint::release_str_obj_id() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ReferenceLinePoint.str_obj_id)
  
  return str_obj_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReferenceLinePoint::set_allocated_str_obj_id(::std::string* str_obj_id) {
  if (str_obj_id != NULL) {
    
  } else {
    
  }
  str_obj_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str_obj_id);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ReferenceLinePoint.str_obj_id)
}

// -------------------------------------------------------------------

// RefLine

// int32 map_floor_num = 1;
inline void RefLine::clear_map_floor_num() {
  map_floor_num_ = 0;
}
inline ::google::protobuf::int32 RefLine::map_floor_num() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLine.map_floor_num)
  return map_floor_num_;
}
inline void RefLine::set_map_floor_num(::google::protobuf::int32 value) {
  
  map_floor_num_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLine.map_floor_num)
}

// string header = 2;
inline void RefLine::clear_header() {
  header_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RefLine::header() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLine.header)
  return header_.GetNoArena();
}
inline void RefLine::set_header(const ::std::string& value) {
  
  header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RefLine.header)
}
#if LANG_CXX11
inline void RefLine::set_header(::std::string&& value) {
  
  header_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.RefLine.header)
}
#endif
inline void RefLine::set_header(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.RefLine.header)
}
inline void RefLine::set_header(const char* value, size_t size) {
  
  header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.RefLine.header)
}
inline ::std::string* RefLine::mutable_header() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RefLine.header)
  return header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RefLine::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RefLine.header)
  
  return header_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RefLine::set_allocated_header(::std::string* header) {
  if (header != NULL) {
    
  } else {
    
  }
  header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), header);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RefLine.header)
}

// repeated .autodrive.workflow.proto.ReferenceLinePoint reference_points = 3;
inline int RefLine::reference_points_size() const {
  return reference_points_.size();
}
inline void RefLine::clear_reference_points() {
  reference_points_.Clear();
}
inline const ::autodrive::workflow::proto::ReferenceLinePoint& RefLine::reference_points(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RefLine.reference_points)
  return reference_points_.Get(index);
}
inline ::autodrive::workflow::proto::ReferenceLinePoint* RefLine::mutable_reference_points(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RefLine.reference_points)
  return reference_points_.Mutable(index);
}
inline ::autodrive::workflow::proto::ReferenceLinePoint* RefLine::add_reference_points() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.RefLine.reference_points)
  return reference_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ReferenceLinePoint >*
RefLine::mutable_reference_points() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.RefLine.reference_points)
  return &reference_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ReferenceLinePoint >&
RefLine::reference_points() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.RefLine.reference_points)
  return reference_points_;
}

// -------------------------------------------------------------------

// ReferenceLinesMsg

// .autodrive.workflow.proto.MsgHeader header = 1;
inline bool ReferenceLinesMsg::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::MsgHeader& ReferenceLinesMsg::header() const {
  const ::autodrive::workflow::proto::MsgHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinesMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::MsgHeader*>(
      &::autodrive::workflow::proto::_MsgHeader_default_instance_);
}
inline ::autodrive::workflow::proto::MsgHeader* ReferenceLinesMsg::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ReferenceLinesMsg.header)
  
  ::autodrive::workflow::proto::MsgHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::MsgHeader* ReferenceLinesMsg::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::MsgHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ReferenceLinesMsg.header)
  return header_;
}
inline void ReferenceLinesMsg::set_allocated_header(::autodrive::workflow::proto::MsgHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ReferenceLinesMsg.header)
}

// .autodrive.workflow.proto.Error error = 2;
inline bool ReferenceLinesMsg::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::autodrive::workflow::proto::Error& ReferenceLinesMsg::error() const {
  const ::autodrive::workflow::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinesMsg.error)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Error*>(
      &::autodrive::workflow::proto::_Error_default_instance_);
}
inline ::autodrive::workflow::proto::Error* ReferenceLinesMsg::release_error() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ReferenceLinesMsg.error)
  
  ::autodrive::workflow::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Error* ReferenceLinesMsg::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::autodrive::workflow::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ReferenceLinesMsg.error)
  return error_;
}
inline void ReferenceLinesMsg::set_allocated_error(::autodrive::workflow::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ReferenceLinesMsg.error)
}

// .autodrive.workflow.proto.RefLineWayPointFrameGlobal waypoint_frame_global_raw = 3;
inline bool ReferenceLinesMsg::has_waypoint_frame_global_raw() const {
  return this != internal_default_instance() && waypoint_frame_global_raw_ != NULL;
}
inline void ReferenceLinesMsg::clear_waypoint_frame_global_raw() {
  if (GetArenaNoVirtual() == NULL && waypoint_frame_global_raw_ != NULL) {
    delete waypoint_frame_global_raw_;
  }
  waypoint_frame_global_raw_ = NULL;
}
inline const ::autodrive::workflow::proto::RefLineWayPointFrameGlobal& ReferenceLinesMsg::waypoint_frame_global_raw() const {
  const ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* p = waypoint_frame_global_raw_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinesMsg.waypoint_frame_global_raw)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::RefLineWayPointFrameGlobal*>(
      &::autodrive::workflow::proto::_RefLineWayPointFrameGlobal_default_instance_);
}
inline ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* ReferenceLinesMsg::release_waypoint_frame_global_raw() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ReferenceLinesMsg.waypoint_frame_global_raw)
  
  ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* temp = waypoint_frame_global_raw_;
  waypoint_frame_global_raw_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* ReferenceLinesMsg::mutable_waypoint_frame_global_raw() {
  
  if (waypoint_frame_global_raw_ == NULL) {
    waypoint_frame_global_raw_ = new ::autodrive::workflow::proto::RefLineWayPointFrameGlobal;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ReferenceLinesMsg.waypoint_frame_global_raw)
  return waypoint_frame_global_raw_;
}
inline void ReferenceLinesMsg::set_allocated_waypoint_frame_global_raw(::autodrive::workflow::proto::RefLineWayPointFrameGlobal* waypoint_frame_global_raw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete waypoint_frame_global_raw_;
  }
  if (waypoint_frame_global_raw) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      waypoint_frame_global_raw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, waypoint_frame_global_raw, submessage_arena);
    }
    
  } else {
    
  }
  waypoint_frame_global_raw_ = waypoint_frame_global_raw;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ReferenceLinesMsg.waypoint_frame_global_raw)
}

// .autodrive.workflow.proto.RefLineWayPointFrameGlobal waypoint_frame_global = 4;
inline bool ReferenceLinesMsg::has_waypoint_frame_global() const {
  return this != internal_default_instance() && waypoint_frame_global_ != NULL;
}
inline void ReferenceLinesMsg::clear_waypoint_frame_global() {
  if (GetArenaNoVirtual() == NULL && waypoint_frame_global_ != NULL) {
    delete waypoint_frame_global_;
  }
  waypoint_frame_global_ = NULL;
}
inline const ::autodrive::workflow::proto::RefLineWayPointFrameGlobal& ReferenceLinesMsg::waypoint_frame_global() const {
  const ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* p = waypoint_frame_global_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinesMsg.waypoint_frame_global)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::RefLineWayPointFrameGlobal*>(
      &::autodrive::workflow::proto::_RefLineWayPointFrameGlobal_default_instance_);
}
inline ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* ReferenceLinesMsg::release_waypoint_frame_global() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ReferenceLinesMsg.waypoint_frame_global)
  
  ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* temp = waypoint_frame_global_;
  waypoint_frame_global_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::RefLineWayPointFrameGlobal* ReferenceLinesMsg::mutable_waypoint_frame_global() {
  
  if (waypoint_frame_global_ == NULL) {
    waypoint_frame_global_ = new ::autodrive::workflow::proto::RefLineWayPointFrameGlobal;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ReferenceLinesMsg.waypoint_frame_global)
  return waypoint_frame_global_;
}
inline void ReferenceLinesMsg::set_allocated_waypoint_frame_global(::autodrive::workflow::proto::RefLineWayPointFrameGlobal* waypoint_frame_global) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete waypoint_frame_global_;
  }
  if (waypoint_frame_global) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      waypoint_frame_global = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, waypoint_frame_global, submessage_arena);
    }
    
  } else {
    
  }
  waypoint_frame_global_ = waypoint_frame_global;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ReferenceLinesMsg.waypoint_frame_global)
}

// .autodrive.workflow.proto.GlbPrkgSlot parking_slot = 5;
inline bool ReferenceLinesMsg::has_parking_slot() const {
  return this != internal_default_instance() && parking_slot_ != NULL;
}
inline const ::autodrive::workflow::proto::GlbPrkgSlot& ReferenceLinesMsg::parking_slot() const {
  const ::autodrive::workflow::proto::GlbPrkgSlot* p = parking_slot_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinesMsg.parking_slot)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::GlbPrkgSlot*>(
      &::autodrive::workflow::proto::_GlbPrkgSlot_default_instance_);
}
inline ::autodrive::workflow::proto::GlbPrkgSlot* ReferenceLinesMsg::release_parking_slot() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ReferenceLinesMsg.parking_slot)
  
  ::autodrive::workflow::proto::GlbPrkgSlot* temp = parking_slot_;
  parking_slot_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::GlbPrkgSlot* ReferenceLinesMsg::mutable_parking_slot() {
  
  if (parking_slot_ == NULL) {
    parking_slot_ = new ::autodrive::workflow::proto::GlbPrkgSlot;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ReferenceLinesMsg.parking_slot)
  return parking_slot_;
}
inline void ReferenceLinesMsg::set_allocated_parking_slot(::autodrive::workflow::proto::GlbPrkgSlot* parking_slot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(parking_slot_);
  }
  if (parking_slot) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parking_slot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parking_slot, submessage_arena);
    }
    
  } else {
    
  }
  parking_slot_ = parking_slot;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ReferenceLinesMsg.parking_slot)
}

// .autodrive.workflow.proto.RefLine reference_line = 6;
inline bool ReferenceLinesMsg::has_reference_line() const {
  return this != internal_default_instance() && reference_line_ != NULL;
}
inline void ReferenceLinesMsg::clear_reference_line() {
  if (GetArenaNoVirtual() == NULL && reference_line_ != NULL) {
    delete reference_line_;
  }
  reference_line_ = NULL;
}
inline const ::autodrive::workflow::proto::RefLine& ReferenceLinesMsg::reference_line() const {
  const ::autodrive::workflow::proto::RefLine* p = reference_line_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinesMsg.reference_line)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::RefLine*>(
      &::autodrive::workflow::proto::_RefLine_default_instance_);
}
inline ::autodrive::workflow::proto::RefLine* ReferenceLinesMsg::release_reference_line() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ReferenceLinesMsg.reference_line)
  
  ::autodrive::workflow::proto::RefLine* temp = reference_line_;
  reference_line_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::RefLine* ReferenceLinesMsg::mutable_reference_line() {
  
  if (reference_line_ == NULL) {
    reference_line_ = new ::autodrive::workflow::proto::RefLine;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ReferenceLinesMsg.reference_line)
  return reference_line_;
}
inline void ReferenceLinesMsg::set_allocated_reference_line(::autodrive::workflow::proto::RefLine* reference_line) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reference_line_;
  }
  if (reference_line) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reference_line = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reference_line, submessage_arena);
    }
    
  } else {
    
  }
  reference_line_ = reference_line;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ReferenceLinesMsg.reference_line)
}

// .autodrive.workflow.proto.ndm_base.NdmSpec ndm_header = 7;
inline bool ReferenceLinesMsg::has_ndm_header() const {
  return this != internal_default_instance() && ndm_header_ != NULL;
}
inline const ::autodrive::workflow::proto::ndm_base::NdmSpec& ReferenceLinesMsg::ndm_header() const {
  const ::autodrive::workflow::proto::ndm_base::NdmSpec* p = ndm_header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ReferenceLinesMsg.ndm_header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::ndm_base::NdmSpec*>(
      &::autodrive::workflow::proto::ndm_base::_NdmSpec_default_instance_);
}
inline ::autodrive::workflow::proto::ndm_base::NdmSpec* ReferenceLinesMsg::release_ndm_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ReferenceLinesMsg.ndm_header)
  
  ::autodrive::workflow::proto::ndm_base::NdmSpec* temp = ndm_header_;
  ndm_header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::ndm_base::NdmSpec* ReferenceLinesMsg::mutable_ndm_header() {
  
  if (ndm_header_ == NULL) {
    ndm_header_ = new ::autodrive::workflow::proto::ndm_base::NdmSpec;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ReferenceLinesMsg.ndm_header)
  return ndm_header_;
}
inline void ReferenceLinesMsg::set_allocated_ndm_header(::autodrive::workflow::proto::ndm_base::NdmSpec* ndm_header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ndm_header_);
  }
  if (ndm_header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ndm_header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ndm_header, submessage_arena);
    }
    
  } else {
    
  }
  ndm_header_ = ndm_header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ReferenceLinesMsg.ndm_header)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::RefLineWayPointGlobal_WaypointDir> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::RefLineWayPointGlobal_WaypointDir>() {
  return ::autodrive::workflow::proto::RefLineWayPointGlobal_WaypointDir_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::VertexType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::VertexType>() {
  return ::autodrive::workflow::proto::VertexType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_refrence_5flines_2eproto__INCLUDED
