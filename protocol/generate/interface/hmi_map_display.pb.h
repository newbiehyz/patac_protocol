// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hmi_map_display.proto

#ifndef PROTOBUF_hmi_5fmap_5fdisplay_2eproto__INCLUDED
#define PROTOBUF_hmi_5fmap_5fdisplay_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "fusion_obstacle.pb.h"
#include "localization.pb.h"
#include "map_display.pb.h"
#include "vpa_state.pb.h"
#include "ndm_base.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_hmi_5fmap_5fdisplay_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHmdGlbPrcpPrkgSlotsImpl();
void InitDefaultsHmdGlbPrcpPrkgSlots();
void InitDefaultsHmdGlbPrcpObstacleImpl();
void InitDefaultsHmdGlbPrcpObstacle();
void InitDefaultsHmdGlbRoadMakMapImpl();
void InitDefaultsHmdGlbRoadMakMap();
void InitDefaultsHmdMapCommonHeaderImpl();
void InitDefaultsHmdMapCommonHeader();
void InitDefaultsHmdMapInfoImpl();
void InitDefaultsHmdMapInfo();
void InitDefaultsHmdMapDisplayImpl();
void InitDefaultsHmdMapDisplay();
void InitDefaultsHmiMapDisplayMsgImpl();
void InitDefaultsHmiMapDisplayMsg();
inline void InitDefaults() {
  InitDefaultsHmdGlbPrcpPrkgSlots();
  InitDefaultsHmdGlbPrcpObstacle();
  InitDefaultsHmdGlbRoadMakMap();
  InitDefaultsHmdMapCommonHeader();
  InitDefaultsHmdMapInfo();
  InitDefaultsHmdMapDisplay();
  InitDefaultsHmiMapDisplayMsg();
}
}  // namespace protobuf_hmi_5fmap_5fdisplay_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
class HmdGlbPrcpObstacle;
class HmdGlbPrcpObstacleDefaultTypeInternal;
extern HmdGlbPrcpObstacleDefaultTypeInternal _HmdGlbPrcpObstacle_default_instance_;
class HmdGlbPrcpPrkgSlots;
class HmdGlbPrcpPrkgSlotsDefaultTypeInternal;
extern HmdGlbPrcpPrkgSlotsDefaultTypeInternal _HmdGlbPrcpPrkgSlots_default_instance_;
class HmdGlbRoadMakMap;
class HmdGlbRoadMakMapDefaultTypeInternal;
extern HmdGlbRoadMakMapDefaultTypeInternal _HmdGlbRoadMakMap_default_instance_;
class HmdMapCommonHeader;
class HmdMapCommonHeaderDefaultTypeInternal;
extern HmdMapCommonHeaderDefaultTypeInternal _HmdMapCommonHeader_default_instance_;
class HmdMapDisplay;
class HmdMapDisplayDefaultTypeInternal;
extern HmdMapDisplayDefaultTypeInternal _HmdMapDisplay_default_instance_;
class HmdMapInfo;
class HmdMapInfoDefaultTypeInternal;
extern HmdMapInfoDefaultTypeInternal _HmdMapInfo_default_instance_;
class HmiMapDisplayMsg;
class HmiMapDisplayMsgDefaultTypeInternal;
extern HmiMapDisplayMsgDefaultTypeInternal _HmiMapDisplayMsg_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {

// ===================================================================

class HmdGlbPrcpPrkgSlots : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmdGlbPrcpPrkgSlots) */ {
 public:
  HmdGlbPrcpPrkgSlots();
  virtual ~HmdGlbPrcpPrkgSlots();

  HmdGlbPrcpPrkgSlots(const HmdGlbPrcpPrkgSlots& from);

  inline HmdGlbPrcpPrkgSlots& operator=(const HmdGlbPrcpPrkgSlots& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmdGlbPrcpPrkgSlots(HmdGlbPrcpPrkgSlots&& from) noexcept
    : HmdGlbPrcpPrkgSlots() {
    *this = ::std::move(from);
  }

  inline HmdGlbPrcpPrkgSlots& operator=(HmdGlbPrcpPrkgSlots&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmdGlbPrcpPrkgSlots& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmdGlbPrcpPrkgSlots* internal_default_instance() {
    return reinterpret_cast<const HmdGlbPrcpPrkgSlots*>(
               &_HmdGlbPrcpPrkgSlots_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HmdGlbPrcpPrkgSlots* other);
  friend void swap(HmdGlbPrcpPrkgSlots& a, HmdGlbPrcpPrkgSlots& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmdGlbPrcpPrkgSlots* New() const PROTOBUF_FINAL { return New(NULL); }

  HmdGlbPrcpPrkgSlots* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmdGlbPrcpPrkgSlots& from);
  void MergeFrom(const HmdGlbPrcpPrkgSlots& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmdGlbPrcpPrkgSlots* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.GlbPrkgSlot glb_prkg_slots = 1;
  int glb_prkg_slots_size() const;
  void clear_glb_prkg_slots();
  static const int kGlbPrkgSlotsFieldNumber = 1;
  const ::autodrive::workflow::proto::GlbPrkgSlot& glb_prkg_slots(int index) const;
  ::autodrive::workflow::proto::GlbPrkgSlot* mutable_glb_prkg_slots(int index);
  ::autodrive::workflow::proto::GlbPrkgSlot* add_glb_prkg_slots();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbPrkgSlot >*
      mutable_glb_prkg_slots();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbPrkgSlot >&
      glb_prkg_slots() const;

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmdGlbPrcpPrkgSlots)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbPrkgSlot > glb_prkg_slots_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fmap_5fdisplay_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fmap_5fdisplay_2eproto::InitDefaultsHmdGlbPrcpPrkgSlotsImpl();
};
// -------------------------------------------------------------------

class HmdGlbPrcpObstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmdGlbPrcpObstacle) */ {
 public:
  HmdGlbPrcpObstacle();
  virtual ~HmdGlbPrcpObstacle();

  HmdGlbPrcpObstacle(const HmdGlbPrcpObstacle& from);

  inline HmdGlbPrcpObstacle& operator=(const HmdGlbPrcpObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmdGlbPrcpObstacle(HmdGlbPrcpObstacle&& from) noexcept
    : HmdGlbPrcpObstacle() {
    *this = ::std::move(from);
  }

  inline HmdGlbPrcpObstacle& operator=(HmdGlbPrcpObstacle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmdGlbPrcpObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmdGlbPrcpObstacle* internal_default_instance() {
    return reinterpret_cast<const HmdGlbPrcpObstacle*>(
               &_HmdGlbPrcpObstacle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HmdGlbPrcpObstacle* other);
  friend void swap(HmdGlbPrcpObstacle& a, HmdGlbPrcpObstacle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmdGlbPrcpObstacle* New() const PROTOBUF_FINAL { return New(NULL); }

  HmdGlbPrcpObstacle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmdGlbPrcpObstacle& from);
  void MergeFrom(const HmdGlbPrcpObstacle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmdGlbPrcpObstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.GlbObstacle glb_prcp_obstacle = 1;
  int glb_prcp_obstacle_size() const;
  void clear_glb_prcp_obstacle();
  static const int kGlbPrcpObstacleFieldNumber = 1;
  const ::autodrive::workflow::proto::GlbObstacle& glb_prcp_obstacle(int index) const;
  ::autodrive::workflow::proto::GlbObstacle* mutable_glb_prcp_obstacle(int index);
  ::autodrive::workflow::proto::GlbObstacle* add_glb_prcp_obstacle();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbObstacle >*
      mutable_glb_prcp_obstacle();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbObstacle >&
      glb_prcp_obstacle() const;

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmdGlbPrcpObstacle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbObstacle > glb_prcp_obstacle_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fmap_5fdisplay_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fmap_5fdisplay_2eproto::InitDefaultsHmdGlbPrcpObstacleImpl();
};
// -------------------------------------------------------------------

class HmdGlbRoadMakMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmdGlbRoadMakMap) */ {
 public:
  HmdGlbRoadMakMap();
  virtual ~HmdGlbRoadMakMap();

  HmdGlbRoadMakMap(const HmdGlbRoadMakMap& from);

  inline HmdGlbRoadMakMap& operator=(const HmdGlbRoadMakMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmdGlbRoadMakMap(HmdGlbRoadMakMap&& from) noexcept
    : HmdGlbRoadMakMap() {
    *this = ::std::move(from);
  }

  inline HmdGlbRoadMakMap& operator=(HmdGlbRoadMakMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmdGlbRoadMakMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmdGlbRoadMakMap* internal_default_instance() {
    return reinterpret_cast<const HmdGlbRoadMakMap*>(
               &_HmdGlbRoadMakMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(HmdGlbRoadMakMap* other);
  friend void swap(HmdGlbRoadMakMap& a, HmdGlbRoadMakMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmdGlbRoadMakMap* New() const PROTOBUF_FINAL { return New(NULL); }

  HmdGlbRoadMakMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmdGlbRoadMakMap& from);
  void MergeFrom(const HmdGlbRoadMakMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmdGlbRoadMakMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.GlbRoadMark glb_road_mak_map = 1;
  int glb_road_mak_map_size() const;
  void clear_glb_road_mak_map();
  static const int kGlbRoadMakMapFieldNumber = 1;
  const ::autodrive::workflow::proto::GlbRoadMark& glb_road_mak_map(int index) const;
  ::autodrive::workflow::proto::GlbRoadMark* mutable_glb_road_mak_map(int index);
  ::autodrive::workflow::proto::GlbRoadMark* add_glb_road_mak_map();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbRoadMark >*
      mutable_glb_road_mak_map();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbRoadMark >&
      glb_road_mak_map() const;

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmdGlbRoadMakMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbRoadMark > glb_road_mak_map_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fmap_5fdisplay_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fmap_5fdisplay_2eproto::InitDefaultsHmdGlbRoadMakMapImpl();
};
// -------------------------------------------------------------------

class HmdMapCommonHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmdMapCommonHeader) */ {
 public:
  HmdMapCommonHeader();
  virtual ~HmdMapCommonHeader();

  HmdMapCommonHeader(const HmdMapCommonHeader& from);

  inline HmdMapCommonHeader& operator=(const HmdMapCommonHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmdMapCommonHeader(HmdMapCommonHeader&& from) noexcept
    : HmdMapCommonHeader() {
    *this = ::std::move(from);
  }

  inline HmdMapCommonHeader& operator=(HmdMapCommonHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmdMapCommonHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmdMapCommonHeader* internal_default_instance() {
    return reinterpret_cast<const HmdMapCommonHeader*>(
               &_HmdMapCommonHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(HmdMapCommonHeader* other);
  friend void swap(HmdMapCommonHeader& a, HmdMapCommonHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmdMapCommonHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  HmdMapCommonHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmdMapCommonHeader& from);
  void MergeFrom(const HmdMapCommonHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmdMapCommonHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 map_id = 1;
  void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  ::google::protobuf::int32 map_id() const;
  void set_map_id(::google::protobuf::int32 value);

  // .autodrive.workflow.proto.MapDataType map_type = 2;
  void clear_map_type();
  static const int kMapTypeFieldNumber = 2;
  ::autodrive::workflow::proto::MapDataType map_type() const;
  void set_map_type(::autodrive::workflow::proto::MapDataType value);

  // uint64 utc_time = 3;
  void clear_utc_time();
  static const int kUtcTimeFieldNumber = 3;
  ::google::protobuf::uint64 utc_time() const;
  void set_utc_time(::google::protobuf::uint64 value);

  // int32 latitude = 4;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  ::google::protobuf::int32 latitude() const;
  void set_latitude(::google::protobuf::int32 value);

  // int32 longitude = 5;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  ::google::protobuf::int32 longitude() const;
  void set_longitude(::google::protobuf::int32 value);

  // uint32 num_glb_trajectory_point = 6;
  void clear_num_glb_trajectory_point();
  static const int kNumGlbTrajectoryPointFieldNumber = 6;
  ::google::protobuf::uint32 num_glb_trajectory_point() const;
  void set_num_glb_trajectory_point(::google::protobuf::uint32 value);

  // float map_total_height = 7;
  void clear_map_total_height();
  static const int kMapTotalHeightFieldNumber = 7;
  float map_total_height() const;
  void set_map_total_height(float value);

  // float map_total_floor = 8;
  void clear_map_total_floor();
  static const int kMapTotalFloorFieldNumber = 8;
  float map_total_floor() const;
  void set_map_total_floor(float value);

  // int32 slot_parking_times = 9;
  void clear_slot_parking_times();
  static const int kSlotParkingTimesFieldNumber = 9;
  ::google::protobuf::int32 slot_parking_times() const;
  void set_slot_parking_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmdMapCommonHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 map_id_;
  int map_type_;
  ::google::protobuf::uint64 utc_time_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 longitude_;
  ::google::protobuf::uint32 num_glb_trajectory_point_;
  float map_total_height_;
  float map_total_floor_;
  ::google::protobuf::int32 slot_parking_times_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fmap_5fdisplay_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fmap_5fdisplay_2eproto::InitDefaultsHmdMapCommonHeaderImpl();
};
// -------------------------------------------------------------------

class HmdMapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmdMapInfo) */ {
 public:
  HmdMapInfo();
  virtual ~HmdMapInfo();

  HmdMapInfo(const HmdMapInfo& from);

  inline HmdMapInfo& operator=(const HmdMapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmdMapInfo(HmdMapInfo&& from) noexcept
    : HmdMapInfo() {
    *this = ::std::move(from);
  }

  inline HmdMapInfo& operator=(HmdMapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmdMapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmdMapInfo* internal_default_instance() {
    return reinterpret_cast<const HmdMapInfo*>(
               &_HmdMapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(HmdMapInfo* other);
  friend void swap(HmdMapInfo& a, HmdMapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmdMapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  HmdMapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmdMapInfo& from);
  void MergeFrom(const HmdMapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmdMapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.HmdMapCommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::HmdMapCommonHeader& header() const;
  ::autodrive::workflow::proto::HmdMapCommonHeader* release_header();
  ::autodrive::workflow::proto::HmdMapCommonHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::HmdMapCommonHeader* header);

  // .autodrive.workflow.proto.GlbTrajectory global_trajectory = 2;
  bool has_global_trajectory() const;
  void clear_global_trajectory();
  static const int kGlobalTrajectoryFieldNumber = 2;
  const ::autodrive::workflow::proto::GlbTrajectory& global_trajectory() const;
  ::autodrive::workflow::proto::GlbTrajectory* release_global_trajectory();
  ::autodrive::workflow::proto::GlbTrajectory* mutable_global_trajectory();
  void set_allocated_global_trajectory(::autodrive::workflow::proto::GlbTrajectory* global_trajectory);

  // .autodrive.workflow.proto.HmdGlbPrcpPrkgSlots global_percep_parking_slots = 3;
  bool has_global_percep_parking_slots() const;
  void clear_global_percep_parking_slots();
  static const int kGlobalPercepParkingSlotsFieldNumber = 3;
  const ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots& global_percep_parking_slots() const;
  ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots* release_global_percep_parking_slots();
  ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots* mutable_global_percep_parking_slots();
  void set_allocated_global_percep_parking_slots(::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots* global_percep_parking_slots);

  // .autodrive.workflow.proto.HmdGlbRoadMakMap global_road_mark_map = 4;
  bool has_global_road_mark_map() const;
  void clear_global_road_mark_map();
  static const int kGlobalRoadMarkMapFieldNumber = 4;
  const ::autodrive::workflow::proto::HmdGlbRoadMakMap& global_road_mark_map() const;
  ::autodrive::workflow::proto::HmdGlbRoadMakMap* release_global_road_mark_map();
  ::autodrive::workflow::proto::HmdGlbRoadMakMap* mutable_global_road_mark_map();
  void set_allocated_global_road_mark_map(::autodrive::workflow::proto::HmdGlbRoadMakMap* global_road_mark_map);

  // .autodrive.workflow.proto.HmdGlbPrcpObstacle global_perception_obstacle = 5;
  bool has_global_perception_obstacle() const;
  void clear_global_perception_obstacle();
  static const int kGlobalPerceptionObstacleFieldNumber = 5;
  const ::autodrive::workflow::proto::HmdGlbPrcpObstacle& global_perception_obstacle() const;
  ::autodrive::workflow::proto::HmdGlbPrcpObstacle* release_global_perception_obstacle();
  ::autodrive::workflow::proto::HmdGlbPrcpObstacle* mutable_global_perception_obstacle();
  void set_allocated_global_perception_obstacle(::autodrive::workflow::proto::HmdGlbPrcpObstacle* global_perception_obstacle);

  // float map_distance = 6;
  void clear_map_distance();
  static const int kMapDistanceFieldNumber = 6;
  float map_distance() const;
  void set_map_distance(float value);

  // float rest_map_distance = 7;
  void clear_rest_map_distance();
  static const int kRestMapDistanceFieldNumber = 7;
  float rest_map_distance() const;
  void set_rest_map_distance(float value);

  // int32 num_speed_bumps = 8;
  void clear_num_speed_bumps();
  static const int kNumSpeedBumpsFieldNumber = 8;
  ::google::protobuf::int32 num_speed_bumps() const;
  void set_num_speed_bumps(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmdMapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::HmdMapCommonHeader* header_;
  ::autodrive::workflow::proto::GlbTrajectory* global_trajectory_;
  ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots* global_percep_parking_slots_;
  ::autodrive::workflow::proto::HmdGlbRoadMakMap* global_road_mark_map_;
  ::autodrive::workflow::proto::HmdGlbPrcpObstacle* global_perception_obstacle_;
  float map_distance_;
  float rest_map_distance_;
  ::google::protobuf::int32 num_speed_bumps_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fmap_5fdisplay_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fmap_5fdisplay_2eproto::InitDefaultsHmdMapInfoImpl();
};
// -------------------------------------------------------------------

class HmdMapDisplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmdMapDisplay) */ {
 public:
  HmdMapDisplay();
  virtual ~HmdMapDisplay();

  HmdMapDisplay(const HmdMapDisplay& from);

  inline HmdMapDisplay& operator=(const HmdMapDisplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmdMapDisplay(HmdMapDisplay&& from) noexcept
    : HmdMapDisplay() {
    *this = ::std::move(from);
  }

  inline HmdMapDisplay& operator=(HmdMapDisplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmdMapDisplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmdMapDisplay* internal_default_instance() {
    return reinterpret_cast<const HmdMapDisplay*>(
               &_HmdMapDisplay_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(HmdMapDisplay* other);
  friend void swap(HmdMapDisplay& a, HmdMapDisplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmdMapDisplay* New() const PROTOBUF_FINAL { return New(NULL); }

  HmdMapDisplay* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmdMapDisplay& from);
  void MergeFrom(const HmdMapDisplay& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmdMapDisplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.HmdMapCommonHeader all_map_headers = 4;
  int all_map_headers_size() const;
  void clear_all_map_headers();
  static const int kAllMapHeadersFieldNumber = 4;
  const ::autodrive::workflow::proto::HmdMapCommonHeader& all_map_headers(int index) const;
  ::autodrive::workflow::proto::HmdMapCommonHeader* mutable_all_map_headers(int index);
  ::autodrive::workflow::proto::HmdMapCommonHeader* add_all_map_headers();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::HmdMapCommonHeader >*
      mutable_all_map_headers();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::HmdMapCommonHeader >&
      all_map_headers() const;

  // .autodrive.workflow.proto.HmdMapInfo map_info = 1;
  bool has_map_info() const;
  void clear_map_info();
  static const int kMapInfoFieldNumber = 1;
  const ::autodrive::workflow::proto::HmdMapInfo& map_info() const;
  ::autodrive::workflow::proto::HmdMapInfo* release_map_info();
  ::autodrive::workflow::proto::HmdMapInfo* mutable_map_info();
  void set_allocated_map_info(::autodrive::workflow::proto::HmdMapInfo* map_info);

  // bool update_map_info = 2;
  void clear_update_map_info();
  static const int kUpdateMapInfoFieldNumber = 2;
  bool update_map_info() const;
  void set_update_map_info(bool value);

  // int32 num_maps = 3;
  void clear_num_maps();
  static const int kNumMapsFieldNumber = 3;
  ::google::protobuf::int32 num_maps() const;
  void set_num_maps(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmdMapDisplay)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::HmdMapCommonHeader > all_map_headers_;
  ::autodrive::workflow::proto::HmdMapInfo* map_info_;
  bool update_map_info_;
  ::google::protobuf::int32 num_maps_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fmap_5fdisplay_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fmap_5fdisplay_2eproto::InitDefaultsHmdMapDisplayImpl();
};
// -------------------------------------------------------------------

class HmiMapDisplayMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmiMapDisplayMsg) */ {
 public:
  HmiMapDisplayMsg();
  virtual ~HmiMapDisplayMsg();

  HmiMapDisplayMsg(const HmiMapDisplayMsg& from);

  inline HmiMapDisplayMsg& operator=(const HmiMapDisplayMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmiMapDisplayMsg(HmiMapDisplayMsg&& from) noexcept
    : HmiMapDisplayMsg() {
    *this = ::std::move(from);
  }

  inline HmiMapDisplayMsg& operator=(HmiMapDisplayMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmiMapDisplayMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmiMapDisplayMsg* internal_default_instance() {
    return reinterpret_cast<const HmiMapDisplayMsg*>(
               &_HmiMapDisplayMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(HmiMapDisplayMsg* other);
  friend void swap(HmiMapDisplayMsg& a, HmiMapDisplayMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmiMapDisplayMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  HmiMapDisplayMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmiMapDisplayMsg& from);
  void MergeFrom(const HmiMapDisplayMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmiMapDisplayMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.MsgHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::MsgHeader& header() const;
  ::autodrive::workflow::proto::MsgHeader* release_header();
  ::autodrive::workflow::proto::MsgHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::MsgHeader* header);

  // .autodrive.workflow.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::autodrive::workflow::proto::Error& error() const;
  ::autodrive::workflow::proto::Error* release_error();
  ::autodrive::workflow::proto::Error* mutable_error();
  void set_allocated_error(::autodrive::workflow::proto::Error* error);

  // .autodrive.workflow.proto.HmdMapDisplay map_display = 3;
  bool has_map_display() const;
  void clear_map_display();
  static const int kMapDisplayFieldNumber = 3;
  const ::autodrive::workflow::proto::HmdMapDisplay& map_display() const;
  ::autodrive::workflow::proto::HmdMapDisplay* release_map_display();
  ::autodrive::workflow::proto::HmdMapDisplay* mutable_map_display();
  void set_allocated_map_display(::autodrive::workflow::proto::HmdMapDisplay* map_display);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmiMapDisplayMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::MsgHeader* header_;
  ::autodrive::workflow::proto::Error* error_;
  ::autodrive::workflow::proto::HmdMapDisplay* map_display_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fmap_5fdisplay_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fmap_5fdisplay_2eproto::InitDefaultsHmiMapDisplayMsgImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HmdGlbPrcpPrkgSlots

// repeated .autodrive.workflow.proto.GlbPrkgSlot glb_prkg_slots = 1;
inline int HmdGlbPrcpPrkgSlots::glb_prkg_slots_size() const {
  return glb_prkg_slots_.size();
}
inline const ::autodrive::workflow::proto::GlbPrkgSlot& HmdGlbPrcpPrkgSlots::glb_prkg_slots(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdGlbPrcpPrkgSlots.glb_prkg_slots)
  return glb_prkg_slots_.Get(index);
}
inline ::autodrive::workflow::proto::GlbPrkgSlot* HmdGlbPrcpPrkgSlots::mutable_glb_prkg_slots(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmdGlbPrcpPrkgSlots.glb_prkg_slots)
  return glb_prkg_slots_.Mutable(index);
}
inline ::autodrive::workflow::proto::GlbPrkgSlot* HmdGlbPrcpPrkgSlots::add_glb_prkg_slots() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.HmdGlbPrcpPrkgSlots.glb_prkg_slots)
  return glb_prkg_slots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbPrkgSlot >*
HmdGlbPrcpPrkgSlots::mutable_glb_prkg_slots() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.HmdGlbPrcpPrkgSlots.glb_prkg_slots)
  return &glb_prkg_slots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbPrkgSlot >&
HmdGlbPrcpPrkgSlots::glb_prkg_slots() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.HmdGlbPrcpPrkgSlots.glb_prkg_slots)
  return glb_prkg_slots_;
}

// -------------------------------------------------------------------

// HmdGlbPrcpObstacle

// repeated .autodrive.workflow.proto.GlbObstacle glb_prcp_obstacle = 1;
inline int HmdGlbPrcpObstacle::glb_prcp_obstacle_size() const {
  return glb_prcp_obstacle_.size();
}
inline const ::autodrive::workflow::proto::GlbObstacle& HmdGlbPrcpObstacle::glb_prcp_obstacle(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdGlbPrcpObstacle.glb_prcp_obstacle)
  return glb_prcp_obstacle_.Get(index);
}
inline ::autodrive::workflow::proto::GlbObstacle* HmdGlbPrcpObstacle::mutable_glb_prcp_obstacle(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmdGlbPrcpObstacle.glb_prcp_obstacle)
  return glb_prcp_obstacle_.Mutable(index);
}
inline ::autodrive::workflow::proto::GlbObstacle* HmdGlbPrcpObstacle::add_glb_prcp_obstacle() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.HmdGlbPrcpObstacle.glb_prcp_obstacle)
  return glb_prcp_obstacle_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbObstacle >*
HmdGlbPrcpObstacle::mutable_glb_prcp_obstacle() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.HmdGlbPrcpObstacle.glb_prcp_obstacle)
  return &glb_prcp_obstacle_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbObstacle >&
HmdGlbPrcpObstacle::glb_prcp_obstacle() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.HmdGlbPrcpObstacle.glb_prcp_obstacle)
  return glb_prcp_obstacle_;
}

// -------------------------------------------------------------------

// HmdGlbRoadMakMap

// repeated .autodrive.workflow.proto.GlbRoadMark glb_road_mak_map = 1;
inline int HmdGlbRoadMakMap::glb_road_mak_map_size() const {
  return glb_road_mak_map_.size();
}
inline const ::autodrive::workflow::proto::GlbRoadMark& HmdGlbRoadMakMap::glb_road_mak_map(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdGlbRoadMakMap.glb_road_mak_map)
  return glb_road_mak_map_.Get(index);
}
inline ::autodrive::workflow::proto::GlbRoadMark* HmdGlbRoadMakMap::mutable_glb_road_mak_map(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmdGlbRoadMakMap.glb_road_mak_map)
  return glb_road_mak_map_.Mutable(index);
}
inline ::autodrive::workflow::proto::GlbRoadMark* HmdGlbRoadMakMap::add_glb_road_mak_map() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.HmdGlbRoadMakMap.glb_road_mak_map)
  return glb_road_mak_map_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbRoadMark >*
HmdGlbRoadMakMap::mutable_glb_road_mak_map() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.HmdGlbRoadMakMap.glb_road_mak_map)
  return &glb_road_mak_map_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbRoadMark >&
HmdGlbRoadMakMap::glb_road_mak_map() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.HmdGlbRoadMakMap.glb_road_mak_map)
  return glb_road_mak_map_;
}

// -------------------------------------------------------------------

// HmdMapCommonHeader

// int32 map_id = 1;
inline void HmdMapCommonHeader::clear_map_id() {
  map_id_ = 0;
}
inline ::google::protobuf::int32 HmdMapCommonHeader::map_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapCommonHeader.map_id)
  return map_id_;
}
inline void HmdMapCommonHeader::set_map_id(::google::protobuf::int32 value) {
  
  map_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapCommonHeader.map_id)
}

// .autodrive.workflow.proto.MapDataType map_type = 2;
inline void HmdMapCommonHeader::clear_map_type() {
  map_type_ = 0;
}
inline ::autodrive::workflow::proto::MapDataType HmdMapCommonHeader::map_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapCommonHeader.map_type)
  return static_cast< ::autodrive::workflow::proto::MapDataType >(map_type_);
}
inline void HmdMapCommonHeader::set_map_type(::autodrive::workflow::proto::MapDataType value) {
  
  map_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapCommonHeader.map_type)
}

// uint64 utc_time = 3;
inline void HmdMapCommonHeader::clear_utc_time() {
  utc_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HmdMapCommonHeader::utc_time() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapCommonHeader.utc_time)
  return utc_time_;
}
inline void HmdMapCommonHeader::set_utc_time(::google::protobuf::uint64 value) {
  
  utc_time_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapCommonHeader.utc_time)
}

// int32 latitude = 4;
inline void HmdMapCommonHeader::clear_latitude() {
  latitude_ = 0;
}
inline ::google::protobuf::int32 HmdMapCommonHeader::latitude() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapCommonHeader.latitude)
  return latitude_;
}
inline void HmdMapCommonHeader::set_latitude(::google::protobuf::int32 value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapCommonHeader.latitude)
}

// int32 longitude = 5;
inline void HmdMapCommonHeader::clear_longitude() {
  longitude_ = 0;
}
inline ::google::protobuf::int32 HmdMapCommonHeader::longitude() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapCommonHeader.longitude)
  return longitude_;
}
inline void HmdMapCommonHeader::set_longitude(::google::protobuf::int32 value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapCommonHeader.longitude)
}

// uint32 num_glb_trajectory_point = 6;
inline void HmdMapCommonHeader::clear_num_glb_trajectory_point() {
  num_glb_trajectory_point_ = 0u;
}
inline ::google::protobuf::uint32 HmdMapCommonHeader::num_glb_trajectory_point() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapCommonHeader.num_glb_trajectory_point)
  return num_glb_trajectory_point_;
}
inline void HmdMapCommonHeader::set_num_glb_trajectory_point(::google::protobuf::uint32 value) {
  
  num_glb_trajectory_point_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapCommonHeader.num_glb_trajectory_point)
}

// float map_total_height = 7;
inline void HmdMapCommonHeader::clear_map_total_height() {
  map_total_height_ = 0;
}
inline float HmdMapCommonHeader::map_total_height() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapCommonHeader.map_total_height)
  return map_total_height_;
}
inline void HmdMapCommonHeader::set_map_total_height(float value) {
  
  map_total_height_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapCommonHeader.map_total_height)
}

// float map_total_floor = 8;
inline void HmdMapCommonHeader::clear_map_total_floor() {
  map_total_floor_ = 0;
}
inline float HmdMapCommonHeader::map_total_floor() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapCommonHeader.map_total_floor)
  return map_total_floor_;
}
inline void HmdMapCommonHeader::set_map_total_floor(float value) {
  
  map_total_floor_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapCommonHeader.map_total_floor)
}

// int32 slot_parking_times = 9;
inline void HmdMapCommonHeader::clear_slot_parking_times() {
  slot_parking_times_ = 0;
}
inline ::google::protobuf::int32 HmdMapCommonHeader::slot_parking_times() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapCommonHeader.slot_parking_times)
  return slot_parking_times_;
}
inline void HmdMapCommonHeader::set_slot_parking_times(::google::protobuf::int32 value) {
  
  slot_parking_times_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapCommonHeader.slot_parking_times)
}

// -------------------------------------------------------------------

// HmdMapInfo

// .autodrive.workflow.proto.HmdMapCommonHeader header = 1;
inline bool HmdMapInfo::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void HmdMapInfo::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
inline const ::autodrive::workflow::proto::HmdMapCommonHeader& HmdMapInfo::header() const {
  const ::autodrive::workflow::proto::HmdMapCommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapInfo.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmdMapCommonHeader*>(
      &::autodrive::workflow::proto::_HmdMapCommonHeader_default_instance_);
}
inline ::autodrive::workflow::proto::HmdMapCommonHeader* HmdMapInfo::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmdMapInfo.header)
  
  ::autodrive::workflow::proto::HmdMapCommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmdMapCommonHeader* HmdMapInfo::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::HmdMapCommonHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmdMapInfo.header)
  return header_;
}
inline void HmdMapInfo::set_allocated_header(::autodrive::workflow::proto::HmdMapCommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmdMapInfo.header)
}

// .autodrive.workflow.proto.GlbTrajectory global_trajectory = 2;
inline bool HmdMapInfo::has_global_trajectory() const {
  return this != internal_default_instance() && global_trajectory_ != NULL;
}
inline const ::autodrive::workflow::proto::GlbTrajectory& HmdMapInfo::global_trajectory() const {
  const ::autodrive::workflow::proto::GlbTrajectory* p = global_trajectory_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapInfo.global_trajectory)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::GlbTrajectory*>(
      &::autodrive::workflow::proto::_GlbTrajectory_default_instance_);
}
inline ::autodrive::workflow::proto::GlbTrajectory* HmdMapInfo::release_global_trajectory() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmdMapInfo.global_trajectory)
  
  ::autodrive::workflow::proto::GlbTrajectory* temp = global_trajectory_;
  global_trajectory_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::GlbTrajectory* HmdMapInfo::mutable_global_trajectory() {
  
  if (global_trajectory_ == NULL) {
    global_trajectory_ = new ::autodrive::workflow::proto::GlbTrajectory;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmdMapInfo.global_trajectory)
  return global_trajectory_;
}
inline void HmdMapInfo::set_allocated_global_trajectory(::autodrive::workflow::proto::GlbTrajectory* global_trajectory) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(global_trajectory_);
  }
  if (global_trajectory) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      global_trajectory = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, global_trajectory, submessage_arena);
    }
    
  } else {
    
  }
  global_trajectory_ = global_trajectory;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmdMapInfo.global_trajectory)
}

// .autodrive.workflow.proto.HmdGlbPrcpPrkgSlots global_percep_parking_slots = 3;
inline bool HmdMapInfo::has_global_percep_parking_slots() const {
  return this != internal_default_instance() && global_percep_parking_slots_ != NULL;
}
inline void HmdMapInfo::clear_global_percep_parking_slots() {
  if (GetArenaNoVirtual() == NULL && global_percep_parking_slots_ != NULL) {
    delete global_percep_parking_slots_;
  }
  global_percep_parking_slots_ = NULL;
}
inline const ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots& HmdMapInfo::global_percep_parking_slots() const {
  const ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots* p = global_percep_parking_slots_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapInfo.global_percep_parking_slots)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots*>(
      &::autodrive::workflow::proto::_HmdGlbPrcpPrkgSlots_default_instance_);
}
inline ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots* HmdMapInfo::release_global_percep_parking_slots() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmdMapInfo.global_percep_parking_slots)
  
  ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots* temp = global_percep_parking_slots_;
  global_percep_parking_slots_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots* HmdMapInfo::mutable_global_percep_parking_slots() {
  
  if (global_percep_parking_slots_ == NULL) {
    global_percep_parking_slots_ = new ::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmdMapInfo.global_percep_parking_slots)
  return global_percep_parking_slots_;
}
inline void HmdMapInfo::set_allocated_global_percep_parking_slots(::autodrive::workflow::proto::HmdGlbPrcpPrkgSlots* global_percep_parking_slots) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete global_percep_parking_slots_;
  }
  if (global_percep_parking_slots) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      global_percep_parking_slots = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, global_percep_parking_slots, submessage_arena);
    }
    
  } else {
    
  }
  global_percep_parking_slots_ = global_percep_parking_slots;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmdMapInfo.global_percep_parking_slots)
}

// .autodrive.workflow.proto.HmdGlbRoadMakMap global_road_mark_map = 4;
inline bool HmdMapInfo::has_global_road_mark_map() const {
  return this != internal_default_instance() && global_road_mark_map_ != NULL;
}
inline void HmdMapInfo::clear_global_road_mark_map() {
  if (GetArenaNoVirtual() == NULL && global_road_mark_map_ != NULL) {
    delete global_road_mark_map_;
  }
  global_road_mark_map_ = NULL;
}
inline const ::autodrive::workflow::proto::HmdGlbRoadMakMap& HmdMapInfo::global_road_mark_map() const {
  const ::autodrive::workflow::proto::HmdGlbRoadMakMap* p = global_road_mark_map_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapInfo.global_road_mark_map)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmdGlbRoadMakMap*>(
      &::autodrive::workflow::proto::_HmdGlbRoadMakMap_default_instance_);
}
inline ::autodrive::workflow::proto::HmdGlbRoadMakMap* HmdMapInfo::release_global_road_mark_map() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmdMapInfo.global_road_mark_map)
  
  ::autodrive::workflow::proto::HmdGlbRoadMakMap* temp = global_road_mark_map_;
  global_road_mark_map_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmdGlbRoadMakMap* HmdMapInfo::mutable_global_road_mark_map() {
  
  if (global_road_mark_map_ == NULL) {
    global_road_mark_map_ = new ::autodrive::workflow::proto::HmdGlbRoadMakMap;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmdMapInfo.global_road_mark_map)
  return global_road_mark_map_;
}
inline void HmdMapInfo::set_allocated_global_road_mark_map(::autodrive::workflow::proto::HmdGlbRoadMakMap* global_road_mark_map) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete global_road_mark_map_;
  }
  if (global_road_mark_map) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      global_road_mark_map = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, global_road_mark_map, submessage_arena);
    }
    
  } else {
    
  }
  global_road_mark_map_ = global_road_mark_map;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmdMapInfo.global_road_mark_map)
}

// .autodrive.workflow.proto.HmdGlbPrcpObstacle global_perception_obstacle = 5;
inline bool HmdMapInfo::has_global_perception_obstacle() const {
  return this != internal_default_instance() && global_perception_obstacle_ != NULL;
}
inline void HmdMapInfo::clear_global_perception_obstacle() {
  if (GetArenaNoVirtual() == NULL && global_perception_obstacle_ != NULL) {
    delete global_perception_obstacle_;
  }
  global_perception_obstacle_ = NULL;
}
inline const ::autodrive::workflow::proto::HmdGlbPrcpObstacle& HmdMapInfo::global_perception_obstacle() const {
  const ::autodrive::workflow::proto::HmdGlbPrcpObstacle* p = global_perception_obstacle_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapInfo.global_perception_obstacle)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmdGlbPrcpObstacle*>(
      &::autodrive::workflow::proto::_HmdGlbPrcpObstacle_default_instance_);
}
inline ::autodrive::workflow::proto::HmdGlbPrcpObstacle* HmdMapInfo::release_global_perception_obstacle() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmdMapInfo.global_perception_obstacle)
  
  ::autodrive::workflow::proto::HmdGlbPrcpObstacle* temp = global_perception_obstacle_;
  global_perception_obstacle_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmdGlbPrcpObstacle* HmdMapInfo::mutable_global_perception_obstacle() {
  
  if (global_perception_obstacle_ == NULL) {
    global_perception_obstacle_ = new ::autodrive::workflow::proto::HmdGlbPrcpObstacle;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmdMapInfo.global_perception_obstacle)
  return global_perception_obstacle_;
}
inline void HmdMapInfo::set_allocated_global_perception_obstacle(::autodrive::workflow::proto::HmdGlbPrcpObstacle* global_perception_obstacle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete global_perception_obstacle_;
  }
  if (global_perception_obstacle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      global_perception_obstacle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, global_perception_obstacle, submessage_arena);
    }
    
  } else {
    
  }
  global_perception_obstacle_ = global_perception_obstacle;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmdMapInfo.global_perception_obstacle)
}

// float map_distance = 6;
inline void HmdMapInfo::clear_map_distance() {
  map_distance_ = 0;
}
inline float HmdMapInfo::map_distance() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapInfo.map_distance)
  return map_distance_;
}
inline void HmdMapInfo::set_map_distance(float value) {
  
  map_distance_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapInfo.map_distance)
}

// float rest_map_distance = 7;
inline void HmdMapInfo::clear_rest_map_distance() {
  rest_map_distance_ = 0;
}
inline float HmdMapInfo::rest_map_distance() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapInfo.rest_map_distance)
  return rest_map_distance_;
}
inline void HmdMapInfo::set_rest_map_distance(float value) {
  
  rest_map_distance_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapInfo.rest_map_distance)
}

// int32 num_speed_bumps = 8;
inline void HmdMapInfo::clear_num_speed_bumps() {
  num_speed_bumps_ = 0;
}
inline ::google::protobuf::int32 HmdMapInfo::num_speed_bumps() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapInfo.num_speed_bumps)
  return num_speed_bumps_;
}
inline void HmdMapInfo::set_num_speed_bumps(::google::protobuf::int32 value) {
  
  num_speed_bumps_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapInfo.num_speed_bumps)
}

// -------------------------------------------------------------------

// HmdMapDisplay

// .autodrive.workflow.proto.HmdMapInfo map_info = 1;
inline bool HmdMapDisplay::has_map_info() const {
  return this != internal_default_instance() && map_info_ != NULL;
}
inline void HmdMapDisplay::clear_map_info() {
  if (GetArenaNoVirtual() == NULL && map_info_ != NULL) {
    delete map_info_;
  }
  map_info_ = NULL;
}
inline const ::autodrive::workflow::proto::HmdMapInfo& HmdMapDisplay::map_info() const {
  const ::autodrive::workflow::proto::HmdMapInfo* p = map_info_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapDisplay.map_info)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmdMapInfo*>(
      &::autodrive::workflow::proto::_HmdMapInfo_default_instance_);
}
inline ::autodrive::workflow::proto::HmdMapInfo* HmdMapDisplay::release_map_info() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmdMapDisplay.map_info)
  
  ::autodrive::workflow::proto::HmdMapInfo* temp = map_info_;
  map_info_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmdMapInfo* HmdMapDisplay::mutable_map_info() {
  
  if (map_info_ == NULL) {
    map_info_ = new ::autodrive::workflow::proto::HmdMapInfo;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmdMapDisplay.map_info)
  return map_info_;
}
inline void HmdMapDisplay::set_allocated_map_info(::autodrive::workflow::proto::HmdMapInfo* map_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_info_;
  }
  if (map_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_info, submessage_arena);
    }
    
  } else {
    
  }
  map_info_ = map_info;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmdMapDisplay.map_info)
}

// bool update_map_info = 2;
inline void HmdMapDisplay::clear_update_map_info() {
  update_map_info_ = false;
}
inline bool HmdMapDisplay::update_map_info() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapDisplay.update_map_info)
  return update_map_info_;
}
inline void HmdMapDisplay::set_update_map_info(bool value) {
  
  update_map_info_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapDisplay.update_map_info)
}

// int32 num_maps = 3;
inline void HmdMapDisplay::clear_num_maps() {
  num_maps_ = 0;
}
inline ::google::protobuf::int32 HmdMapDisplay::num_maps() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapDisplay.num_maps)
  return num_maps_;
}
inline void HmdMapDisplay::set_num_maps(::google::protobuf::int32 value) {
  
  num_maps_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmdMapDisplay.num_maps)
}

// repeated .autodrive.workflow.proto.HmdMapCommonHeader all_map_headers = 4;
inline int HmdMapDisplay::all_map_headers_size() const {
  return all_map_headers_.size();
}
inline void HmdMapDisplay::clear_all_map_headers() {
  all_map_headers_.Clear();
}
inline const ::autodrive::workflow::proto::HmdMapCommonHeader& HmdMapDisplay::all_map_headers(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmdMapDisplay.all_map_headers)
  return all_map_headers_.Get(index);
}
inline ::autodrive::workflow::proto::HmdMapCommonHeader* HmdMapDisplay::mutable_all_map_headers(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmdMapDisplay.all_map_headers)
  return all_map_headers_.Mutable(index);
}
inline ::autodrive::workflow::proto::HmdMapCommonHeader* HmdMapDisplay::add_all_map_headers() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.HmdMapDisplay.all_map_headers)
  return all_map_headers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::HmdMapCommonHeader >*
HmdMapDisplay::mutable_all_map_headers() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.HmdMapDisplay.all_map_headers)
  return &all_map_headers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::HmdMapCommonHeader >&
HmdMapDisplay::all_map_headers() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.HmdMapDisplay.all_map_headers)
  return all_map_headers_;
}

// -------------------------------------------------------------------

// HmiMapDisplayMsg

// .autodrive.workflow.proto.MsgHeader header = 1;
inline bool HmiMapDisplayMsg::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::MsgHeader& HmiMapDisplayMsg::header() const {
  const ::autodrive::workflow::proto::MsgHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapDisplayMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::MsgHeader*>(
      &::autodrive::workflow::proto::_MsgHeader_default_instance_);
}
inline ::autodrive::workflow::proto::MsgHeader* HmiMapDisplayMsg::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiMapDisplayMsg.header)
  
  ::autodrive::workflow::proto::MsgHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::MsgHeader* HmiMapDisplayMsg::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::MsgHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiMapDisplayMsg.header)
  return header_;
}
inline void HmiMapDisplayMsg::set_allocated_header(::autodrive::workflow::proto::MsgHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiMapDisplayMsg.header)
}

// .autodrive.workflow.proto.Error error = 2;
inline bool HmiMapDisplayMsg::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::autodrive::workflow::proto::Error& HmiMapDisplayMsg::error() const {
  const ::autodrive::workflow::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapDisplayMsg.error)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Error*>(
      &::autodrive::workflow::proto::_Error_default_instance_);
}
inline ::autodrive::workflow::proto::Error* HmiMapDisplayMsg::release_error() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiMapDisplayMsg.error)
  
  ::autodrive::workflow::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Error* HmiMapDisplayMsg::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::autodrive::workflow::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiMapDisplayMsg.error)
  return error_;
}
inline void HmiMapDisplayMsg::set_allocated_error(::autodrive::workflow::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiMapDisplayMsg.error)
}

// .autodrive.workflow.proto.HmdMapDisplay map_display = 3;
inline bool HmiMapDisplayMsg::has_map_display() const {
  return this != internal_default_instance() && map_display_ != NULL;
}
inline void HmiMapDisplayMsg::clear_map_display() {
  if (GetArenaNoVirtual() == NULL && map_display_ != NULL) {
    delete map_display_;
  }
  map_display_ = NULL;
}
inline const ::autodrive::workflow::proto::HmdMapDisplay& HmiMapDisplayMsg::map_display() const {
  const ::autodrive::workflow::proto::HmdMapDisplay* p = map_display_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapDisplayMsg.map_display)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmdMapDisplay*>(
      &::autodrive::workflow::proto::_HmdMapDisplay_default_instance_);
}
inline ::autodrive::workflow::proto::HmdMapDisplay* HmiMapDisplayMsg::release_map_display() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiMapDisplayMsg.map_display)
  
  ::autodrive::workflow::proto::HmdMapDisplay* temp = map_display_;
  map_display_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmdMapDisplay* HmiMapDisplayMsg::mutable_map_display() {
  
  if (map_display_ == NULL) {
    map_display_ = new ::autodrive::workflow::proto::HmdMapDisplay;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiMapDisplayMsg.map_display)
  return map_display_;
}
inline void HmiMapDisplayMsg::set_allocated_map_display(::autodrive::workflow::proto::HmdMapDisplay* map_display) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_display_;
  }
  if (map_display) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_display = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_display, submessage_arena);
    }
    
  } else {
    
  }
  map_display_ = map_display;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiMapDisplayMsg.map_display)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hmi_5fmap_5fdisplay_2eproto__INCLUDED
