// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fusion_obstacle.proto

#ifndef PROTOBUF_fusion_5fobstacle_2eproto__INCLUDED
#define PROTOBUF_fusion_5fobstacle_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_fusion_5fobstacle_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsTwoPointsImpl();
void InitDefaultsTwoPoints();
void InitDefaultsFusionObstacleOutPutImpl();
void InitDefaultsFusionObstacleOutPut();
void InitDefaultsFusionObstaclesImpl();
void InitDefaultsFusionObstacles();
void InitDefaultsFusionObstacleMsgImpl();
void InitDefaultsFusionObstacleMsg();
inline void InitDefaults() {
  InitDefaultsTwoPoints();
  InitDefaultsFusionObstacleOutPut();
  InitDefaultsFusionObstacles();
  InitDefaultsFusionObstacleMsg();
}
}  // namespace protobuf_fusion_5fobstacle_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
class FusionObstacleMsg;
class FusionObstacleMsgDefaultTypeInternal;
extern FusionObstacleMsgDefaultTypeInternal _FusionObstacleMsg_default_instance_;
class FusionObstacleOutPut;
class FusionObstacleOutPutDefaultTypeInternal;
extern FusionObstacleOutPutDefaultTypeInternal _FusionObstacleOutPut_default_instance_;
class FusionObstacles;
class FusionObstaclesDefaultTypeInternal;
extern FusionObstaclesDefaultTypeInternal _FusionObstacles_default_instance_;
class TwoPoints;
class TwoPointsDefaultTypeInternal;
extern TwoPointsDefaultTypeInternal _TwoPoints_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {

enum FusionObstacleType {
  kFusionObstacleTypeVehicle = 0,
  kFusionObstacleTypePedestrain = 1,
  kFusionObstacleTypeCyclist = 2,
  kFusionObstacleTypeAnimal = 3,
  kFusionObstacleTypeTrafficCone = 50,
  kFusionObstacleTypeCementColumn = 51,
  kFusionObstacleTypeParkingLock = 52,
  kFusionObstacleTypeAFrameSign = 53,
  kFusionObstacleTypeCurb = 54,
  kFusionObstacleTypeFence = 55,
  kFusionObstacleTypeWaterBarrier = 56,
  kFusionObstacleTypeTrolley = 57,
  kFusionObstacleTypeWall = 58,
  kFusionObstacleTypeUnknown = 100,
  FusionObstacleType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FusionObstacleType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FusionObstacleType_IsValid(int value);
const FusionObstacleType FusionObstacleType_MIN = kFusionObstacleTypeVehicle;
const FusionObstacleType FusionObstacleType_MAX = kFusionObstacleTypeUnknown;
const int FusionObstacleType_ARRAYSIZE = FusionObstacleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FusionObstacleType_descriptor();
inline const ::std::string& FusionObstacleType_Name(FusionObstacleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FusionObstacleType_descriptor(), value);
}
inline bool FusionObstacleType_Parse(
    const ::std::string& name, FusionObstacleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FusionObstacleType>(
    FusionObstacleType_descriptor(), name, value);
}
enum ObstacleMotionCategory {
  kObstacleMotionCategoryInvalid = 0,
  kObstacleMotionCategoryUndefined = 1,
  kObstacleMotionCategoryPassing = 2,
  kObstacleMotionCategoryPassingIn = 3,
  kObstacleMotionCategoryPassingOut = 4,
  kObstacleMotionCategoryCloseCutIn = 5,
  kObstacleMotionCategoryMovingIn = 6,
  kObstacleMotionCategoryMovingOut = 7,
  kObstacleMotionCategoryCrossing = 8,
  kObstacleMotionCategoryLeftTurnAP = 9,
  kObstacleMotionCategoryRightTurnAP = 10,
  kObstacleMotionCategoryMoving = 11,
  kObstacleMotionCategoryPreceding = 12,
  kObstacleMotionCategoryOncoming = 13,
  kObstacleMotionCategoryEnumSize = 14,
  ObstacleMotionCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObstacleMotionCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObstacleMotionCategory_IsValid(int value);
const ObstacleMotionCategory ObstacleMotionCategory_MIN = kObstacleMotionCategoryInvalid;
const ObstacleMotionCategory ObstacleMotionCategory_MAX = kObstacleMotionCategoryEnumSize;
const int ObstacleMotionCategory_ARRAYSIZE = ObstacleMotionCategory_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObstacleMotionCategory_descriptor();
inline const ::std::string& ObstacleMotionCategory_Name(ObstacleMotionCategory value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObstacleMotionCategory_descriptor(), value);
}
inline bool ObstacleMotionCategory_Parse(
    const ::std::string& name, ObstacleMotionCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstacleMotionCategory>(
    ObstacleMotionCategory_descriptor(), name, value);
}
enum ObstacleMotionOrientation {
  kObstacleMotionOrientationUndefined = 0,
  kObstacleMotionOrientationDriftingRight = 1,
  kObstacleMotionOrientationCrossingRight = 2,
  kObstacleMotionOrientationOncomingDriftRight = 3,
  kObstacleMotionOrientationOncoming = 4,
  kObstacleMotionOrientationOncomingDriftLeft = 5,
  kObstacleMotionOrientationCrossingLeft = 6,
  kObstacleMotionOrientationDriftingLeft = 7,
  kObstacleMotionOrientationPreceding = 8,
  ObstacleMotionOrientation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObstacleMotionOrientation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObstacleMotionOrientation_IsValid(int value);
const ObstacleMotionOrientation ObstacleMotionOrientation_MIN = kObstacleMotionOrientationUndefined;
const ObstacleMotionOrientation ObstacleMotionOrientation_MAX = kObstacleMotionOrientationPreceding;
const int ObstacleMotionOrientation_ARRAYSIZE = ObstacleMotionOrientation_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObstacleMotionOrientation_descriptor();
inline const ::std::string& ObstacleMotionOrientation_Name(ObstacleMotionOrientation value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObstacleMotionOrientation_descriptor(), value);
}
inline bool ObstacleMotionOrientation_Parse(
    const ::std::string& name, ObstacleMotionOrientation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstacleMotionOrientation>(
    ObstacleMotionOrientation_descriptor(), name, value);
}
enum ObstacleMotionStatus {
  kObstacleMotionStatusUnknown = 0,
  kObstacleMotionStatusMoving = 1,
  kObstacleMotionStatusOncoming = 2,
  kObstacleMotionStatusStopped = 3,
  kObstacleMotionStatusStationary = 4,
  ObstacleMotionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObstacleMotionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObstacleMotionStatus_IsValid(int value);
const ObstacleMotionStatus ObstacleMotionStatus_MIN = kObstacleMotionStatusUnknown;
const ObstacleMotionStatus ObstacleMotionStatus_MAX = kObstacleMotionStatusStationary;
const int ObstacleMotionStatus_ARRAYSIZE = ObstacleMotionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObstacleMotionStatus_descriptor();
inline const ::std::string& ObstacleMotionStatus_Name(ObstacleMotionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObstacleMotionStatus_descriptor(), value);
}
inline bool ObstacleMotionStatus_Parse(
    const ::std::string& name, ObstacleMotionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstacleMotionStatus>(
    ObstacleMotionStatus_descriptor(), name, value);
}
enum VehicleSubType {
  kVehicleSubTypeUnknown = 0,
  kVehicleSubTypeCar = 1,
  kVehicleSubTypeSUV = 2,
  kVehicleSubTypeVan = 3,
  kVehicleSubTypeBus = 4,
  kVehicleSubTypeTruck = 5,
  kVehicleSubTypeAmbulance = 6,
  kVehicleSubTypePoliceCar = 7,
  kVehicleSubTypeFireTruck = 8,
  kVehicleSubTypeTricycle = 9,
  kVehicleSubTypeSpecialCar = 10,
  kVehicleSubTypeTinyCar = 11,
  kVehicleSubTypeMotor = 12,
  VehicleSubType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VehicleSubType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VehicleSubType_IsValid(int value);
const VehicleSubType VehicleSubType_MIN = kVehicleSubTypeUnknown;
const VehicleSubType VehicleSubType_MAX = kVehicleSubTypeMotor;
const int VehicleSubType_ARRAYSIZE = VehicleSubType_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleSubType_descriptor();
inline const ::std::string& VehicleSubType_Name(VehicleSubType value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleSubType_descriptor(), value);
}
inline bool VehicleSubType_Parse(
    const ::std::string& name, VehicleSubType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleSubType>(
    VehicleSubType_descriptor(), name, value);
}
enum FusionObstacleStaticSubType {
  kSubTypeParkLockTypeUnknown = 0,
  kSubTypeParkLockTypeOpen = 1,
  kSubTypeParkLockTypeClose = 2,
  kSubTypeFireHydrantTypeAir = 3,
  kSubTypeFireHydrantTypeGnd = 4,
  FusionObstacleStaticSubType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FusionObstacleStaticSubType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FusionObstacleStaticSubType_IsValid(int value);
const FusionObstacleStaticSubType FusionObstacleStaticSubType_MIN = kSubTypeParkLockTypeUnknown;
const FusionObstacleStaticSubType FusionObstacleStaticSubType_MAX = kSubTypeFireHydrantTypeGnd;
const int FusionObstacleStaticSubType_ARRAYSIZE = FusionObstacleStaticSubType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FusionObstacleStaticSubType_descriptor();
inline const ::std::string& FusionObstacleStaticSubType_Name(FusionObstacleStaticSubType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FusionObstacleStaticSubType_descriptor(), value);
}
inline bool FusionObstacleStaticSubType_Parse(
    const ::std::string& name, FusionObstacleStaticSubType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FusionObstacleStaticSubType>(
    FusionObstacleStaticSubType_descriptor(), name, value);
}
// ===================================================================

class TwoPoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.TwoPoints) */ {
 public:
  TwoPoints();
  virtual ~TwoPoints();

  TwoPoints(const TwoPoints& from);

  inline TwoPoints& operator=(const TwoPoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TwoPoints(TwoPoints&& from) noexcept
    : TwoPoints() {
    *this = ::std::move(from);
  }

  inline TwoPoints& operator=(TwoPoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TwoPoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TwoPoints* internal_default_instance() {
    return reinterpret_cast<const TwoPoints*>(
               &_TwoPoints_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TwoPoints* other);
  friend void swap(TwoPoints& a, TwoPoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TwoPoints* New() const PROTOBUF_FINAL { return New(NULL); }

  TwoPoints* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TwoPoints& from);
  void MergeFrom(const TwoPoints& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TwoPoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.Vector3f pos1 = 1;
  bool has_pos1() const;
  void clear_pos1();
  static const int kPos1FieldNumber = 1;
  const ::autodrive::workflow::proto::Vector3f& pos1() const;
  ::autodrive::workflow::proto::Vector3f* release_pos1();
  ::autodrive::workflow::proto::Vector3f* mutable_pos1();
  void set_allocated_pos1(::autodrive::workflow::proto::Vector3f* pos1);

  // .autodrive.workflow.proto.Vector3f pos2 = 2;
  bool has_pos2() const;
  void clear_pos2();
  static const int kPos2FieldNumber = 2;
  const ::autodrive::workflow::proto::Vector3f& pos2() const;
  ::autodrive::workflow::proto::Vector3f* release_pos2();
  ::autodrive::workflow::proto::Vector3f* mutable_pos2();
  void set_allocated_pos2(::autodrive::workflow::proto::Vector3f* pos2);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.TwoPoints)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::Vector3f* pos1_;
  ::autodrive::workflow::proto::Vector3f* pos2_;
  mutable int _cached_size_;
  friend struct ::protobuf_fusion_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_fusion_5fobstacle_2eproto::InitDefaultsTwoPointsImpl();
};
// -------------------------------------------------------------------

class FusionObstacleOutPut : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.FusionObstacleOutPut) */ {
 public:
  FusionObstacleOutPut();
  virtual ~FusionObstacleOutPut();

  FusionObstacleOutPut(const FusionObstacleOutPut& from);

  inline FusionObstacleOutPut& operator=(const FusionObstacleOutPut& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FusionObstacleOutPut(FusionObstacleOutPut&& from) noexcept
    : FusionObstacleOutPut() {
    *this = ::std::move(from);
  }

  inline FusionObstacleOutPut& operator=(FusionObstacleOutPut&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FusionObstacleOutPut& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FusionObstacleOutPut* internal_default_instance() {
    return reinterpret_cast<const FusionObstacleOutPut*>(
               &_FusionObstacleOutPut_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(FusionObstacleOutPut* other);
  friend void swap(FusionObstacleOutPut& a, FusionObstacleOutPut& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FusionObstacleOutPut* New() const PROTOBUF_FINAL { return New(NULL); }

  FusionObstacleOutPut* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FusionObstacleOutPut& from);
  void MergeFrom(const FusionObstacleOutPut& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FusionObstacleOutPut* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.Vector3f pos = 7;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 7;
  const ::autodrive::workflow::proto::Vector3f& pos() const;
  ::autodrive::workflow::proto::Vector3f* release_pos();
  ::autodrive::workflow::proto::Vector3f* mutable_pos();
  void set_allocated_pos(::autodrive::workflow::proto::Vector3f* pos);

  // .autodrive.workflow.proto.Vector3f vel = 8;
  bool has_vel() const;
  void clear_vel();
  static const int kVelFieldNumber = 8;
  const ::autodrive::workflow::proto::Vector3f& vel() const;
  ::autodrive::workflow::proto::Vector3f* release_vel();
  ::autodrive::workflow::proto::Vector3f* mutable_vel();
  void set_allocated_vel(::autodrive::workflow::proto::Vector3f* vel);

  // .autodrive.workflow.proto.Vector3f acc = 9;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 9;
  const ::autodrive::workflow::proto::Vector3f& acc() const;
  ::autodrive::workflow::proto::Vector3f* release_acc();
  ::autodrive::workflow::proto::Vector3f* mutable_acc();
  void set_allocated_acc(::autodrive::workflow::proto::Vector3f* acc);

  // .autodrive.workflow.proto.TwoPoints uss_pos = 19;
  bool has_uss_pos() const;
  void clear_uss_pos();
  static const int kUssPosFieldNumber = 19;
  const ::autodrive::workflow::proto::TwoPoints& uss_pos() const;
  ::autodrive::workflow::proto::TwoPoints* release_uss_pos();
  ::autodrive::workflow::proto::TwoPoints* mutable_uss_pos();
  void set_allocated_uss_pos(::autodrive::workflow::proto::TwoPoints* uss_pos);

  // .autodrive.workflow.proto.Vector3f pos_std = 21;
  bool has_pos_std() const;
  void clear_pos_std();
  static const int kPosStdFieldNumber = 21;
  const ::autodrive::workflow::proto::Vector3f& pos_std() const;
  ::autodrive::workflow::proto::Vector3f* release_pos_std();
  ::autodrive::workflow::proto::Vector3f* mutable_pos_std();
  void set_allocated_pos_std(::autodrive::workflow::proto::Vector3f* pos_std);

  // .autodrive.workflow.proto.Vector3f vel_abs_world = 26;
  bool has_vel_abs_world() const;
  void clear_vel_abs_world();
  static const int kVelAbsWorldFieldNumber = 26;
  const ::autodrive::workflow::proto::Vector3f& vel_abs_world() const;
  ::autodrive::workflow::proto::Vector3f* release_vel_abs_world();
  ::autodrive::workflow::proto::Vector3f* mutable_vel_abs_world();
  void set_allocated_vel_abs_world(::autodrive::workflow::proto::Vector3f* vel_abs_world);

  // .autodrive.workflow.proto.Vector3f acc_abs_world = 27;
  bool has_acc_abs_world() const;
  void clear_acc_abs_world();
  static const int kAccAbsWorldFieldNumber = 27;
  const ::autodrive::workflow::proto::Vector3f& acc_abs_world() const;
  ::autodrive::workflow::proto::Vector3f* release_acc_abs_world();
  ::autodrive::workflow::proto::Vector3f* mutable_acc_abs_world();
  void set_allocated_acc_abs_world(::autodrive::workflow::proto::Vector3f* acc_abs_world);

  // bool is_updated = 1;
  void clear_is_updated();
  static const int kIsUpdatedFieldNumber = 1;
  bool is_updated() const;
  void set_is_updated(bool value);

  // uint32 sensor_source = 2;
  void clear_sensor_source();
  static const int kSensorSourceFieldNumber = 2;
  ::google::protobuf::uint32 sensor_source() const;
  void set_sensor_source(::google::protobuf::uint32 value);

  // uint32 id = 3;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // uint32 vision_id = 4;
  void clear_vision_id();
  static const int kVisionIdFieldNumber = 4;
  ::google::protobuf::uint32 vision_id() const;
  void set_vision_id(::google::protobuf::uint32 value);

  // uint32 uss_id = 5;
  void clear_uss_id();
  static const int kUssIdFieldNumber = 5;
  ::google::protobuf::uint32 uss_id() const;
  void set_uss_id(::google::protobuf::uint32 value);

  // uint32 mono_id = 6;
  void clear_mono_id();
  static const int kMonoIdFieldNumber = 6;
  ::google::protobuf::uint32 mono_id() const;
  void set_mono_id(::google::protobuf::uint32 value);

  // float heading = 10;
  void clear_heading();
  static const int kHeadingFieldNumber = 10;
  float heading() const;
  void set_heading(float value);

  // float obstacle_conf = 11;
  void clear_obstacle_conf();
  static const int kObstacleConfFieldNumber = 11;
  float obstacle_conf() const;
  void set_obstacle_conf(float value);

  // float width = 12;
  void clear_width();
  static const int kWidthFieldNumber = 12;
  float width() const;
  void set_width(float value);

  // float length = 13;
  void clear_length();
  static const int kLengthFieldNumber = 13;
  float length() const;
  void set_length(float value);

  // float height = 14;
  void clear_height();
  static const int kHeightFieldNumber = 14;
  float height() const;
  void set_height(float value);

  // .autodrive.workflow.proto.FusionObstacleType type = 15;
  void clear_type();
  static const int kTypeFieldNumber = 15;
  ::autodrive::workflow::proto::FusionObstacleType type() const;
  void set_type(::autodrive::workflow::proto::FusionObstacleType value);

  // .autodrive.workflow.proto.VehicleSubType veh_sub_type = 16;
  void clear_veh_sub_type();
  static const int kVehSubTypeFieldNumber = 16;
  ::autodrive::workflow::proto::VehicleSubType veh_sub_type() const;
  void set_veh_sub_type(::autodrive::workflow::proto::VehicleSubType value);

  // .autodrive.workflow.proto.FusionObstacleStaticSubType static_sub_type = 17;
  void clear_static_sub_type();
  static const int kStaticSubTypeFieldNumber = 17;
  ::autodrive::workflow::proto::FusionObstacleStaticSubType static_sub_type() const;
  void set_static_sub_type(::autodrive::workflow::proto::FusionObstacleStaticSubType value);

  // .autodrive.workflow.proto.ObstacleMotionStatus motion_state = 18;
  void clear_motion_state();
  static const int kMotionStateFieldNumber = 18;
  ::autodrive::workflow::proto::ObstacleMotionStatus motion_state() const;
  void set_motion_state(::autodrive::workflow::proto::ObstacleMotionStatus value);

  // uint32 age = 20;
  void clear_age();
  static const int kAgeFieldNumber = 20;
  ::google::protobuf::uint32 age() const;
  void set_age(::google::protobuf::uint32 value);

  // float angular_speed = 22;
  void clear_angular_speed();
  static const int kAngularSpeedFieldNumber = 22;
  float angular_speed() const;
  void set_angular_speed(float value);

  // float ttc = 23;
  void clear_ttc();
  static const int kTtcFieldNumber = 23;
  float ttc() const;
  void set_ttc(float value);

  // .autodrive.workflow.proto.ObstacleMotionCategory motion_category = 24;
  void clear_motion_category();
  static const int kMotionCategoryFieldNumber = 24;
  ::autodrive::workflow::proto::ObstacleMotionCategory motion_category() const;
  void set_motion_category(::autodrive::workflow::proto::ObstacleMotionCategory value);

  // .autodrive.workflow.proto.ObstacleMotionOrientation motion_orientation = 25;
  void clear_motion_orientation();
  static const int kMotionOrientationFieldNumber = 25;
  ::autodrive::workflow::proto::ObstacleMotionOrientation motion_orientation() const;
  void set_motion_orientation(::autodrive::workflow::proto::ObstacleMotionOrientation value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.FusionObstacleOutPut)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::Vector3f* pos_;
  ::autodrive::workflow::proto::Vector3f* vel_;
  ::autodrive::workflow::proto::Vector3f* acc_;
  ::autodrive::workflow::proto::TwoPoints* uss_pos_;
  ::autodrive::workflow::proto::Vector3f* pos_std_;
  ::autodrive::workflow::proto::Vector3f* vel_abs_world_;
  ::autodrive::workflow::proto::Vector3f* acc_abs_world_;
  bool is_updated_;
  ::google::protobuf::uint32 sensor_source_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 vision_id_;
  ::google::protobuf::uint32 uss_id_;
  ::google::protobuf::uint32 mono_id_;
  float heading_;
  float obstacle_conf_;
  float width_;
  float length_;
  float height_;
  int type_;
  int veh_sub_type_;
  int static_sub_type_;
  int motion_state_;
  ::google::protobuf::uint32 age_;
  float angular_speed_;
  float ttc_;
  int motion_category_;
  int motion_orientation_;
  mutable int _cached_size_;
  friend struct ::protobuf_fusion_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_fusion_5fobstacle_2eproto::InitDefaultsFusionObstacleOutPutImpl();
};
// -------------------------------------------------------------------

class FusionObstacles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.FusionObstacles) */ {
 public:
  FusionObstacles();
  virtual ~FusionObstacles();

  FusionObstacles(const FusionObstacles& from);

  inline FusionObstacles& operator=(const FusionObstacles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FusionObstacles(FusionObstacles&& from) noexcept
    : FusionObstacles() {
    *this = ::std::move(from);
  }

  inline FusionObstacles& operator=(FusionObstacles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FusionObstacles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FusionObstacles* internal_default_instance() {
    return reinterpret_cast<const FusionObstacles*>(
               &_FusionObstacles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(FusionObstacles* other);
  friend void swap(FusionObstacles& a, FusionObstacles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FusionObstacles* New() const PROTOBUF_FINAL { return New(NULL); }

  FusionObstacles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FusionObstacles& from);
  void MergeFrom(const FusionObstacles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FusionObstacles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.FusionObstacleOutPut obstacle_list = 2;
  int obstacle_list_size() const;
  void clear_obstacle_list();
  static const int kObstacleListFieldNumber = 2;
  const ::autodrive::workflow::proto::FusionObstacleOutPut& obstacle_list(int index) const;
  ::autodrive::workflow::proto::FusionObstacleOutPut* mutable_obstacle_list(int index);
  ::autodrive::workflow::proto::FusionObstacleOutPut* add_obstacle_list();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::FusionObstacleOutPut >*
      mutable_obstacle_list();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::FusionObstacleOutPut >&
      obstacle_list() const;

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.FusionObstacles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::FusionObstacleOutPut > obstacle_list_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_fusion_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_fusion_5fobstacle_2eproto::InitDefaultsFusionObstaclesImpl();
};
// -------------------------------------------------------------------

class FusionObstacleMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.FusionObstacleMsg) */ {
 public:
  FusionObstacleMsg();
  virtual ~FusionObstacleMsg();

  FusionObstacleMsg(const FusionObstacleMsg& from);

  inline FusionObstacleMsg& operator=(const FusionObstacleMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FusionObstacleMsg(FusionObstacleMsg&& from) noexcept
    : FusionObstacleMsg() {
    *this = ::std::move(from);
  }

  inline FusionObstacleMsg& operator=(FusionObstacleMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FusionObstacleMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FusionObstacleMsg* internal_default_instance() {
    return reinterpret_cast<const FusionObstacleMsg*>(
               &_FusionObstacleMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FusionObstacleMsg* other);
  friend void swap(FusionObstacleMsg& a, FusionObstacleMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FusionObstacleMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  FusionObstacleMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FusionObstacleMsg& from);
  void MergeFrom(const FusionObstacleMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FusionObstacleMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.MsgHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::MsgHeader& header() const;
  ::autodrive::workflow::proto::MsgHeader* release_header();
  ::autodrive::workflow::proto::MsgHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::MsgHeader* header);

  // .autodrive.workflow.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::autodrive::workflow::proto::Error& error() const;
  ::autodrive::workflow::proto::Error* release_error();
  ::autodrive::workflow::proto::Error* mutable_error();
  void set_allocated_error(::autodrive::workflow::proto::Error* error);

  // .autodrive.workflow.proto.FusionObstacles fusion_obstacles = 3;
  bool has_fusion_obstacles() const;
  void clear_fusion_obstacles();
  static const int kFusionObstaclesFieldNumber = 3;
  const ::autodrive::workflow::proto::FusionObstacles& fusion_obstacles() const;
  ::autodrive::workflow::proto::FusionObstacles* release_fusion_obstacles();
  ::autodrive::workflow::proto::FusionObstacles* mutable_fusion_obstacles();
  void set_allocated_fusion_obstacles(::autodrive::workflow::proto::FusionObstacles* fusion_obstacles);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.FusionObstacleMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::MsgHeader* header_;
  ::autodrive::workflow::proto::Error* error_;
  ::autodrive::workflow::proto::FusionObstacles* fusion_obstacles_;
  mutable int _cached_size_;
  friend struct ::protobuf_fusion_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_fusion_5fobstacle_2eproto::InitDefaultsFusionObstacleMsgImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TwoPoints

// .autodrive.workflow.proto.Vector3f pos1 = 1;
inline bool TwoPoints::has_pos1() const {
  return this != internal_default_instance() && pos1_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& TwoPoints::pos1() const {
  const ::autodrive::workflow::proto::Vector3f* p = pos1_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.TwoPoints.pos1)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* TwoPoints::release_pos1() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.TwoPoints.pos1)
  
  ::autodrive::workflow::proto::Vector3f* temp = pos1_;
  pos1_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* TwoPoints::mutable_pos1() {
  
  if (pos1_ == NULL) {
    pos1_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.TwoPoints.pos1)
  return pos1_;
}
inline void TwoPoints::set_allocated_pos1(::autodrive::workflow::proto::Vector3f* pos1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos1_);
  }
  if (pos1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos1, submessage_arena);
    }
    
  } else {
    
  }
  pos1_ = pos1;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.TwoPoints.pos1)
}

// .autodrive.workflow.proto.Vector3f pos2 = 2;
inline bool TwoPoints::has_pos2() const {
  return this != internal_default_instance() && pos2_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& TwoPoints::pos2() const {
  const ::autodrive::workflow::proto::Vector3f* p = pos2_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.TwoPoints.pos2)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* TwoPoints::release_pos2() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.TwoPoints.pos2)
  
  ::autodrive::workflow::proto::Vector3f* temp = pos2_;
  pos2_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* TwoPoints::mutable_pos2() {
  
  if (pos2_ == NULL) {
    pos2_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.TwoPoints.pos2)
  return pos2_;
}
inline void TwoPoints::set_allocated_pos2(::autodrive::workflow::proto::Vector3f* pos2) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos2_);
  }
  if (pos2) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos2 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos2, submessage_arena);
    }
    
  } else {
    
  }
  pos2_ = pos2;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.TwoPoints.pos2)
}

// -------------------------------------------------------------------

// FusionObstacleOutPut

// bool is_updated = 1;
inline void FusionObstacleOutPut::clear_is_updated() {
  is_updated_ = false;
}
inline bool FusionObstacleOutPut::is_updated() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.is_updated)
  return is_updated_;
}
inline void FusionObstacleOutPut::set_is_updated(bool value) {
  
  is_updated_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.is_updated)
}

// uint32 sensor_source = 2;
inline void FusionObstacleOutPut::clear_sensor_source() {
  sensor_source_ = 0u;
}
inline ::google::protobuf::uint32 FusionObstacleOutPut::sensor_source() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.sensor_source)
  return sensor_source_;
}
inline void FusionObstacleOutPut::set_sensor_source(::google::protobuf::uint32 value) {
  
  sensor_source_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.sensor_source)
}

// uint32 id = 3;
inline void FusionObstacleOutPut::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 FusionObstacleOutPut::id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.id)
  return id_;
}
inline void FusionObstacleOutPut::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.id)
}

// uint32 vision_id = 4;
inline void FusionObstacleOutPut::clear_vision_id() {
  vision_id_ = 0u;
}
inline ::google::protobuf::uint32 FusionObstacleOutPut::vision_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.vision_id)
  return vision_id_;
}
inline void FusionObstacleOutPut::set_vision_id(::google::protobuf::uint32 value) {
  
  vision_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.vision_id)
}

// uint32 uss_id = 5;
inline void FusionObstacleOutPut::clear_uss_id() {
  uss_id_ = 0u;
}
inline ::google::protobuf::uint32 FusionObstacleOutPut::uss_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.uss_id)
  return uss_id_;
}
inline void FusionObstacleOutPut::set_uss_id(::google::protobuf::uint32 value) {
  
  uss_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.uss_id)
}

// uint32 mono_id = 6;
inline void FusionObstacleOutPut::clear_mono_id() {
  mono_id_ = 0u;
}
inline ::google::protobuf::uint32 FusionObstacleOutPut::mono_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.mono_id)
  return mono_id_;
}
inline void FusionObstacleOutPut::set_mono_id(::google::protobuf::uint32 value) {
  
  mono_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.mono_id)
}

// .autodrive.workflow.proto.Vector3f pos = 7;
inline bool FusionObstacleOutPut::has_pos() const {
  return this != internal_default_instance() && pos_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& FusionObstacleOutPut::pos() const {
  const ::autodrive::workflow::proto::Vector3f* p = pos_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::release_pos() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.FusionObstacleOutPut.pos)
  
  ::autodrive::workflow::proto::Vector3f* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::mutable_pos() {
  
  if (pos_ == NULL) {
    pos_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacleOutPut.pos)
  return pos_;
}
inline void FusionObstacleOutPut::set_allocated_pos(::autodrive::workflow::proto::Vector3f* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.FusionObstacleOutPut.pos)
}

// .autodrive.workflow.proto.Vector3f vel = 8;
inline bool FusionObstacleOutPut::has_vel() const {
  return this != internal_default_instance() && vel_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& FusionObstacleOutPut::vel() const {
  const ::autodrive::workflow::proto::Vector3f* p = vel_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.vel)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::release_vel() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.FusionObstacleOutPut.vel)
  
  ::autodrive::workflow::proto::Vector3f* temp = vel_;
  vel_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::mutable_vel() {
  
  if (vel_ == NULL) {
    vel_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacleOutPut.vel)
  return vel_;
}
inline void FusionObstacleOutPut::set_allocated_vel(::autodrive::workflow::proto::Vector3f* vel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(vel_);
  }
  if (vel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vel, submessage_arena);
    }
    
  } else {
    
  }
  vel_ = vel;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.FusionObstacleOutPut.vel)
}

// .autodrive.workflow.proto.Vector3f acc = 9;
inline bool FusionObstacleOutPut::has_acc() const {
  return this != internal_default_instance() && acc_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& FusionObstacleOutPut::acc() const {
  const ::autodrive::workflow::proto::Vector3f* p = acc_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.acc)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::release_acc() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.FusionObstacleOutPut.acc)
  
  ::autodrive::workflow::proto::Vector3f* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::mutable_acc() {
  
  if (acc_ == NULL) {
    acc_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacleOutPut.acc)
  return acc_;
}
inline void FusionObstacleOutPut::set_allocated_acc(::autodrive::workflow::proto::Vector3f* acc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(acc_);
  }
  if (acc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    
  } else {
    
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.FusionObstacleOutPut.acc)
}

// float heading = 10;
inline void FusionObstacleOutPut::clear_heading() {
  heading_ = 0;
}
inline float FusionObstacleOutPut::heading() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.heading)
  return heading_;
}
inline void FusionObstacleOutPut::set_heading(float value) {
  
  heading_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.heading)
}

// float obstacle_conf = 11;
inline void FusionObstacleOutPut::clear_obstacle_conf() {
  obstacle_conf_ = 0;
}
inline float FusionObstacleOutPut::obstacle_conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.obstacle_conf)
  return obstacle_conf_;
}
inline void FusionObstacleOutPut::set_obstacle_conf(float value) {
  
  obstacle_conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.obstacle_conf)
}

// float width = 12;
inline void FusionObstacleOutPut::clear_width() {
  width_ = 0;
}
inline float FusionObstacleOutPut::width() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.width)
  return width_;
}
inline void FusionObstacleOutPut::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.width)
}

// float length = 13;
inline void FusionObstacleOutPut::clear_length() {
  length_ = 0;
}
inline float FusionObstacleOutPut::length() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.length)
  return length_;
}
inline void FusionObstacleOutPut::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.length)
}

// float height = 14;
inline void FusionObstacleOutPut::clear_height() {
  height_ = 0;
}
inline float FusionObstacleOutPut::height() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.height)
  return height_;
}
inline void FusionObstacleOutPut::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.height)
}

// .autodrive.workflow.proto.FusionObstacleType type = 15;
inline void FusionObstacleOutPut::clear_type() {
  type_ = 0;
}
inline ::autodrive::workflow::proto::FusionObstacleType FusionObstacleOutPut::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.type)
  return static_cast< ::autodrive::workflow::proto::FusionObstacleType >(type_);
}
inline void FusionObstacleOutPut::set_type(::autodrive::workflow::proto::FusionObstacleType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.type)
}

// .autodrive.workflow.proto.VehicleSubType veh_sub_type = 16;
inline void FusionObstacleOutPut::clear_veh_sub_type() {
  veh_sub_type_ = 0;
}
inline ::autodrive::workflow::proto::VehicleSubType FusionObstacleOutPut::veh_sub_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.veh_sub_type)
  return static_cast< ::autodrive::workflow::proto::VehicleSubType >(veh_sub_type_);
}
inline void FusionObstacleOutPut::set_veh_sub_type(::autodrive::workflow::proto::VehicleSubType value) {
  
  veh_sub_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.veh_sub_type)
}

// .autodrive.workflow.proto.FusionObstacleStaticSubType static_sub_type = 17;
inline void FusionObstacleOutPut::clear_static_sub_type() {
  static_sub_type_ = 0;
}
inline ::autodrive::workflow::proto::FusionObstacleStaticSubType FusionObstacleOutPut::static_sub_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.static_sub_type)
  return static_cast< ::autodrive::workflow::proto::FusionObstacleStaticSubType >(static_sub_type_);
}
inline void FusionObstacleOutPut::set_static_sub_type(::autodrive::workflow::proto::FusionObstacleStaticSubType value) {
  
  static_sub_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.static_sub_type)
}

// .autodrive.workflow.proto.ObstacleMotionStatus motion_state = 18;
inline void FusionObstacleOutPut::clear_motion_state() {
  motion_state_ = 0;
}
inline ::autodrive::workflow::proto::ObstacleMotionStatus FusionObstacleOutPut::motion_state() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.motion_state)
  return static_cast< ::autodrive::workflow::proto::ObstacleMotionStatus >(motion_state_);
}
inline void FusionObstacleOutPut::set_motion_state(::autodrive::workflow::proto::ObstacleMotionStatus value) {
  
  motion_state_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.motion_state)
}

// .autodrive.workflow.proto.TwoPoints uss_pos = 19;
inline bool FusionObstacleOutPut::has_uss_pos() const {
  return this != internal_default_instance() && uss_pos_ != NULL;
}
inline void FusionObstacleOutPut::clear_uss_pos() {
  if (GetArenaNoVirtual() == NULL && uss_pos_ != NULL) {
    delete uss_pos_;
  }
  uss_pos_ = NULL;
}
inline const ::autodrive::workflow::proto::TwoPoints& FusionObstacleOutPut::uss_pos() const {
  const ::autodrive::workflow::proto::TwoPoints* p = uss_pos_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.uss_pos)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::TwoPoints*>(
      &::autodrive::workflow::proto::_TwoPoints_default_instance_);
}
inline ::autodrive::workflow::proto::TwoPoints* FusionObstacleOutPut::release_uss_pos() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.FusionObstacleOutPut.uss_pos)
  
  ::autodrive::workflow::proto::TwoPoints* temp = uss_pos_;
  uss_pos_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::TwoPoints* FusionObstacleOutPut::mutable_uss_pos() {
  
  if (uss_pos_ == NULL) {
    uss_pos_ = new ::autodrive::workflow::proto::TwoPoints;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacleOutPut.uss_pos)
  return uss_pos_;
}
inline void FusionObstacleOutPut::set_allocated_uss_pos(::autodrive::workflow::proto::TwoPoints* uss_pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete uss_pos_;
  }
  if (uss_pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      uss_pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uss_pos, submessage_arena);
    }
    
  } else {
    
  }
  uss_pos_ = uss_pos;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.FusionObstacleOutPut.uss_pos)
}

// uint32 age = 20;
inline void FusionObstacleOutPut::clear_age() {
  age_ = 0u;
}
inline ::google::protobuf::uint32 FusionObstacleOutPut::age() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.age)
  return age_;
}
inline void FusionObstacleOutPut::set_age(::google::protobuf::uint32 value) {
  
  age_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.age)
}

// .autodrive.workflow.proto.Vector3f pos_std = 21;
inline bool FusionObstacleOutPut::has_pos_std() const {
  return this != internal_default_instance() && pos_std_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& FusionObstacleOutPut::pos_std() const {
  const ::autodrive::workflow::proto::Vector3f* p = pos_std_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.pos_std)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::release_pos_std() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.FusionObstacleOutPut.pos_std)
  
  ::autodrive::workflow::proto::Vector3f* temp = pos_std_;
  pos_std_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::mutable_pos_std() {
  
  if (pos_std_ == NULL) {
    pos_std_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacleOutPut.pos_std)
  return pos_std_;
}
inline void FusionObstacleOutPut::set_allocated_pos_std(::autodrive::workflow::proto::Vector3f* pos_std) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_std_);
  }
  if (pos_std) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos_std = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos_std, submessage_arena);
    }
    
  } else {
    
  }
  pos_std_ = pos_std;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.FusionObstacleOutPut.pos_std)
}

// float angular_speed = 22;
inline void FusionObstacleOutPut::clear_angular_speed() {
  angular_speed_ = 0;
}
inline float FusionObstacleOutPut::angular_speed() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.angular_speed)
  return angular_speed_;
}
inline void FusionObstacleOutPut::set_angular_speed(float value) {
  
  angular_speed_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.angular_speed)
}

// float ttc = 23;
inline void FusionObstacleOutPut::clear_ttc() {
  ttc_ = 0;
}
inline float FusionObstacleOutPut::ttc() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.ttc)
  return ttc_;
}
inline void FusionObstacleOutPut::set_ttc(float value) {
  
  ttc_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.ttc)
}

// .autodrive.workflow.proto.ObstacleMotionCategory motion_category = 24;
inline void FusionObstacleOutPut::clear_motion_category() {
  motion_category_ = 0;
}
inline ::autodrive::workflow::proto::ObstacleMotionCategory FusionObstacleOutPut::motion_category() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.motion_category)
  return static_cast< ::autodrive::workflow::proto::ObstacleMotionCategory >(motion_category_);
}
inline void FusionObstacleOutPut::set_motion_category(::autodrive::workflow::proto::ObstacleMotionCategory value) {
  
  motion_category_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.motion_category)
}

// .autodrive.workflow.proto.ObstacleMotionOrientation motion_orientation = 25;
inline void FusionObstacleOutPut::clear_motion_orientation() {
  motion_orientation_ = 0;
}
inline ::autodrive::workflow::proto::ObstacleMotionOrientation FusionObstacleOutPut::motion_orientation() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.motion_orientation)
  return static_cast< ::autodrive::workflow::proto::ObstacleMotionOrientation >(motion_orientation_);
}
inline void FusionObstacleOutPut::set_motion_orientation(::autodrive::workflow::proto::ObstacleMotionOrientation value) {
  
  motion_orientation_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacleOutPut.motion_orientation)
}

// .autodrive.workflow.proto.Vector3f vel_abs_world = 26;
inline bool FusionObstacleOutPut::has_vel_abs_world() const {
  return this != internal_default_instance() && vel_abs_world_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& FusionObstacleOutPut::vel_abs_world() const {
  const ::autodrive::workflow::proto::Vector3f* p = vel_abs_world_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.vel_abs_world)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::release_vel_abs_world() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.FusionObstacleOutPut.vel_abs_world)
  
  ::autodrive::workflow::proto::Vector3f* temp = vel_abs_world_;
  vel_abs_world_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::mutable_vel_abs_world() {
  
  if (vel_abs_world_ == NULL) {
    vel_abs_world_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacleOutPut.vel_abs_world)
  return vel_abs_world_;
}
inline void FusionObstacleOutPut::set_allocated_vel_abs_world(::autodrive::workflow::proto::Vector3f* vel_abs_world) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(vel_abs_world_);
  }
  if (vel_abs_world) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vel_abs_world = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vel_abs_world, submessage_arena);
    }
    
  } else {
    
  }
  vel_abs_world_ = vel_abs_world;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.FusionObstacleOutPut.vel_abs_world)
}

// .autodrive.workflow.proto.Vector3f acc_abs_world = 27;
inline bool FusionObstacleOutPut::has_acc_abs_world() const {
  return this != internal_default_instance() && acc_abs_world_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& FusionObstacleOutPut::acc_abs_world() const {
  const ::autodrive::workflow::proto::Vector3f* p = acc_abs_world_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleOutPut.acc_abs_world)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::release_acc_abs_world() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.FusionObstacleOutPut.acc_abs_world)
  
  ::autodrive::workflow::proto::Vector3f* temp = acc_abs_world_;
  acc_abs_world_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* FusionObstacleOutPut::mutable_acc_abs_world() {
  
  if (acc_abs_world_ == NULL) {
    acc_abs_world_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacleOutPut.acc_abs_world)
  return acc_abs_world_;
}
inline void FusionObstacleOutPut::set_allocated_acc_abs_world(::autodrive::workflow::proto::Vector3f* acc_abs_world) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(acc_abs_world_);
  }
  if (acc_abs_world) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acc_abs_world = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acc_abs_world, submessage_arena);
    }
    
  } else {
    
  }
  acc_abs_world_ = acc_abs_world;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.FusionObstacleOutPut.acc_abs_world)
}

// -------------------------------------------------------------------

// FusionObstacles

// int64 timestamp = 1;
inline void FusionObstacles::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FusionObstacles::timestamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacles.timestamp)
  return timestamp_;
}
inline void FusionObstacles::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.FusionObstacles.timestamp)
}

// repeated .autodrive.workflow.proto.FusionObstacleOutPut obstacle_list = 2;
inline int FusionObstacles::obstacle_list_size() const {
  return obstacle_list_.size();
}
inline void FusionObstacles::clear_obstacle_list() {
  obstacle_list_.Clear();
}
inline const ::autodrive::workflow::proto::FusionObstacleOutPut& FusionObstacles::obstacle_list(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacles.obstacle_list)
  return obstacle_list_.Get(index);
}
inline ::autodrive::workflow::proto::FusionObstacleOutPut* FusionObstacles::mutable_obstacle_list(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacles.obstacle_list)
  return obstacle_list_.Mutable(index);
}
inline ::autodrive::workflow::proto::FusionObstacleOutPut* FusionObstacles::add_obstacle_list() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.FusionObstacles.obstacle_list)
  return obstacle_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::FusionObstacleOutPut >*
FusionObstacles::mutable_obstacle_list() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.FusionObstacles.obstacle_list)
  return &obstacle_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::FusionObstacleOutPut >&
FusionObstacles::obstacle_list() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.FusionObstacles.obstacle_list)
  return obstacle_list_;
}

// -------------------------------------------------------------------

// FusionObstacleMsg

// .autodrive.workflow.proto.MsgHeader header = 1;
inline bool FusionObstacleMsg::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::MsgHeader& FusionObstacleMsg::header() const {
  const ::autodrive::workflow::proto::MsgHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::MsgHeader*>(
      &::autodrive::workflow::proto::_MsgHeader_default_instance_);
}
inline ::autodrive::workflow::proto::MsgHeader* FusionObstacleMsg::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.FusionObstacleMsg.header)
  
  ::autodrive::workflow::proto::MsgHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::MsgHeader* FusionObstacleMsg::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::MsgHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacleMsg.header)
  return header_;
}
inline void FusionObstacleMsg::set_allocated_header(::autodrive::workflow::proto::MsgHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.FusionObstacleMsg.header)
}

// .autodrive.workflow.proto.Error error = 2;
inline bool FusionObstacleMsg::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::autodrive::workflow::proto::Error& FusionObstacleMsg::error() const {
  const ::autodrive::workflow::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleMsg.error)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Error*>(
      &::autodrive::workflow::proto::_Error_default_instance_);
}
inline ::autodrive::workflow::proto::Error* FusionObstacleMsg::release_error() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.FusionObstacleMsg.error)
  
  ::autodrive::workflow::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Error* FusionObstacleMsg::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::autodrive::workflow::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacleMsg.error)
  return error_;
}
inline void FusionObstacleMsg::set_allocated_error(::autodrive::workflow::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.FusionObstacleMsg.error)
}

// .autodrive.workflow.proto.FusionObstacles fusion_obstacles = 3;
inline bool FusionObstacleMsg::has_fusion_obstacles() const {
  return this != internal_default_instance() && fusion_obstacles_ != NULL;
}
inline void FusionObstacleMsg::clear_fusion_obstacles() {
  if (GetArenaNoVirtual() == NULL && fusion_obstacles_ != NULL) {
    delete fusion_obstacles_;
  }
  fusion_obstacles_ = NULL;
}
inline const ::autodrive::workflow::proto::FusionObstacles& FusionObstacleMsg::fusion_obstacles() const {
  const ::autodrive::workflow::proto::FusionObstacles* p = fusion_obstacles_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.FusionObstacleMsg.fusion_obstacles)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::FusionObstacles*>(
      &::autodrive::workflow::proto::_FusionObstacles_default_instance_);
}
inline ::autodrive::workflow::proto::FusionObstacles* FusionObstacleMsg::release_fusion_obstacles() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.FusionObstacleMsg.fusion_obstacles)
  
  ::autodrive::workflow::proto::FusionObstacles* temp = fusion_obstacles_;
  fusion_obstacles_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::FusionObstacles* FusionObstacleMsg::mutable_fusion_obstacles() {
  
  if (fusion_obstacles_ == NULL) {
    fusion_obstacles_ = new ::autodrive::workflow::proto::FusionObstacles;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.FusionObstacleMsg.fusion_obstacles)
  return fusion_obstacles_;
}
inline void FusionObstacleMsg::set_allocated_fusion_obstacles(::autodrive::workflow::proto::FusionObstacles* fusion_obstacles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fusion_obstacles_;
  }
  if (fusion_obstacles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fusion_obstacles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fusion_obstacles, submessage_arena);
    }
    
  } else {
    
  }
  fusion_obstacles_ = fusion_obstacles;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.FusionObstacleMsg.fusion_obstacles)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::FusionObstacleType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::FusionObstacleType>() {
  return ::autodrive::workflow::proto::FusionObstacleType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ObstacleMotionCategory> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ObstacleMotionCategory>() {
  return ::autodrive::workflow::proto::ObstacleMotionCategory_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ObstacleMotionOrientation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ObstacleMotionOrientation>() {
  return ::autodrive::workflow::proto::ObstacleMotionOrientation_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ObstacleMotionStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ObstacleMotionStatus>() {
  return ::autodrive::workflow::proto::ObstacleMotionStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::VehicleSubType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::VehicleSubType>() {
  return ::autodrive::workflow::proto::VehicleSubType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::FusionObstacleStaticSubType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::FusionObstacleStaticSubType>() {
  return ::autodrive::workflow::proto::FusionObstacleStaticSubType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fusion_5fobstacle_2eproto__INCLUDED
