// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: odometry_data.proto

#ifndef PROTOBUF_odometry_5fdata_2eproto__INCLUDED
#define PROTOBUF_odometry_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_odometry_5fdata_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsStableDataPitchImpl();
void InitDefaultsStableDataPitch();
void InitDefaultsVehicleImpl();
void InitDefaultsVehicle();
void InitDefaultsOdometryMsgImpl();
void InitDefaultsOdometryMsg();
inline void InitDefaults() {
  InitDefaultsStableDataPitch();
  InitDefaultsVehicle();
  InitDefaultsOdometryMsg();
}
}  // namespace protobuf_odometry_5fdata_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
class OdometryMsg;
class OdometryMsgDefaultTypeInternal;
extern OdometryMsgDefaultTypeInternal _OdometryMsg_default_instance_;
class StableDataPitch;
class StableDataPitchDefaultTypeInternal;
extern StableDataPitchDefaultTypeInternal _StableDataPitch_default_instance_;
class Vehicle;
class VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {

enum OdometryDataSource {
  kOdometrySourceUnknown = 0,
  kOdometrySourceTwoWheel = 1,
  kOdometrySourceFourWheel = 2,
  kOdometrySourceSpeed = 4,
  kOdometrySourceYawRate = 8,
  kOdometrySourceSteeringAngle = 16,
  kOdometrySourceWheelSpeed = 32,
  kOdometrySourceWheelPulse = 64,
  kOdometrySourceGear = 128,
  OdometryDataSource_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OdometryDataSource_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OdometryDataSource_IsValid(int value);
const OdometryDataSource OdometryDataSource_MIN = kOdometrySourceUnknown;
const OdometryDataSource OdometryDataSource_MAX = kOdometrySourceGear;
const int OdometryDataSource_ARRAYSIZE = OdometryDataSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* OdometryDataSource_descriptor();
inline const ::std::string& OdometryDataSource_Name(OdometryDataSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    OdometryDataSource_descriptor(), value);
}
inline bool OdometryDataSource_Parse(
    const ::std::string& name, OdometryDataSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OdometryDataSource>(
    OdometryDataSource_descriptor(), name, value);
}
enum OdometryDataType {
  kOdometryDataTypeCan = 0,
  kOdometryDataTypeOfflineOptimized = 1,
  kOdometryDataTypeOnlineIns = 2,
  OdometryDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OdometryDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OdometryDataType_IsValid(int value);
const OdometryDataType OdometryDataType_MIN = kOdometryDataTypeCan;
const OdometryDataType OdometryDataType_MAX = kOdometryDataTypeOnlineIns;
const int OdometryDataType_ARRAYSIZE = OdometryDataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OdometryDataType_descriptor();
inline const ::std::string& OdometryDataType_Name(OdometryDataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OdometryDataType_descriptor(), value);
}
inline bool OdometryDataType_Parse(
    const ::std::string& name, OdometryDataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OdometryDataType>(
    OdometryDataType_descriptor(), name, value);
}
enum OdometryDataState {
  kOdometryDataStateNormal = 0,
  kOdometryDataStateUnnormal = 1,
  kOdometryDataStateReset = 2,
  OdometryDataState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OdometryDataState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OdometryDataState_IsValid(int value);
const OdometryDataState OdometryDataState_MIN = kOdometryDataStateNormal;
const OdometryDataState OdometryDataState_MAX = kOdometryDataStateReset;
const int OdometryDataState_ARRAYSIZE = OdometryDataState_MAX + 1;

const ::google::protobuf::EnumDescriptor* OdometryDataState_descriptor();
inline const ::std::string& OdometryDataState_Name(OdometryDataState value) {
  return ::google::protobuf::internal::NameOfEnum(
    OdometryDataState_descriptor(), value);
}
inline bool OdometryDataState_Parse(
    const ::std::string& name, OdometryDataState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OdometryDataState>(
    OdometryDataState_descriptor(), name, value);
}
enum OdometryDataErrorCode {
  kOdometryDataErrorCodeNoError = 0,
  kOdometryDataErrorCodeErrorCanTimeout = 1,
  kOdometryDataErrorCodeErrorCanOdomOutrange = 2,
  kOdometryDataErrorCodeErrorCanHugeDiff = 3,
  kOdometryDataErrorCodeErrorCanAbnormalValue = 4,
  kOdometryDataErrorCodeErrorNoImu = 5,
  kOdometryDataErrorCodeErrorNoGnss = 6,
  kOdometryDataErrorCodeErrorNoCan = 7,
  kOdometryDataErrorCodeErrorNoImage = 8,
  kOdometryDataErrorCodeErrorGnssLost = 9,
  kOdometryDataErrorCodeErrorImageTimestamp = 10,
  OdometryDataErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OdometryDataErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OdometryDataErrorCode_IsValid(int value);
const OdometryDataErrorCode OdometryDataErrorCode_MIN = kOdometryDataErrorCodeNoError;
const OdometryDataErrorCode OdometryDataErrorCode_MAX = kOdometryDataErrorCodeErrorImageTimestamp;
const int OdometryDataErrorCode_ARRAYSIZE = OdometryDataErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* OdometryDataErrorCode_descriptor();
inline const ::std::string& OdometryDataErrorCode_Name(OdometryDataErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    OdometryDataErrorCode_descriptor(), value);
}
inline bool OdometryDataErrorCode_Parse(
    const ::std::string& name, OdometryDataErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OdometryDataErrorCode>(
    OdometryDataErrorCode_descriptor(), name, value);
}
enum OdometryDataYawRateBiasEstimateState {
  kYawRateBiasEstimateStateNormal = 0,
  kYawRateBiasEstimateStateStaticUpdate = 1,
  kYawRateBiasEstimateStateLaneUpdate = 2,
  kYawRateBiasEstimateStateOnCurve = 3,
  kYawRateBiasEstimateStateLaneNotSatisfied = 4,
  OdometryDataYawRateBiasEstimateState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OdometryDataYawRateBiasEstimateState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OdometryDataYawRateBiasEstimateState_IsValid(int value);
const OdometryDataYawRateBiasEstimateState OdometryDataYawRateBiasEstimateState_MIN = kYawRateBiasEstimateStateNormal;
const OdometryDataYawRateBiasEstimateState OdometryDataYawRateBiasEstimateState_MAX = kYawRateBiasEstimateStateLaneNotSatisfied;
const int OdometryDataYawRateBiasEstimateState_ARRAYSIZE = OdometryDataYawRateBiasEstimateState_MAX + 1;

const ::google::protobuf::EnumDescriptor* OdometryDataYawRateBiasEstimateState_descriptor();
inline const ::std::string& OdometryDataYawRateBiasEstimateState_Name(OdometryDataYawRateBiasEstimateState value) {
  return ::google::protobuf::internal::NameOfEnum(
    OdometryDataYawRateBiasEstimateState_descriptor(), value);
}
inline bool OdometryDataYawRateBiasEstimateState_Parse(
    const ::std::string& name, OdometryDataYawRateBiasEstimateState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OdometryDataYawRateBiasEstimateState>(
    OdometryDataYawRateBiasEstimateState_descriptor(), name, value);
}
enum Gear {
  kGearTypeN = 0,
  KGearTypeP = 1,
  kGearTypeR = 2,
  kGearTypeD = 3,
  Gear_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Gear_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Gear_IsValid(int value);
const Gear Gear_MIN = kGearTypeN;
const Gear Gear_MAX = kGearTypeD;
const int Gear_ARRAYSIZE = Gear_MAX + 1;

const ::google::protobuf::EnumDescriptor* Gear_descriptor();
inline const ::std::string& Gear_Name(Gear value) {
  return ::google::protobuf::internal::NameOfEnum(
    Gear_descriptor(), value);
}
inline bool Gear_Parse(
    const ::std::string& name, Gear* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Gear>(
    Gear_descriptor(), name, value);
}
enum LightIntensityValidity {
  kUndefinedDataAccuracy = 0,
  kTemporaryUndefinedData = 1,
  kDataAccuracyNotWithinSpecification = 2,
  kAccurateData = 3,
  LightIntensityValidity_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LightIntensityValidity_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LightIntensityValidity_IsValid(int value);
const LightIntensityValidity LightIntensityValidity_MIN = kUndefinedDataAccuracy;
const LightIntensityValidity LightIntensityValidity_MAX = kAccurateData;
const int LightIntensityValidity_ARRAYSIZE = LightIntensityValidity_MAX + 1;

const ::google::protobuf::EnumDescriptor* LightIntensityValidity_descriptor();
inline const ::std::string& LightIntensityValidity_Name(LightIntensityValidity value) {
  return ::google::protobuf::internal::NameOfEnum(
    LightIntensityValidity_descriptor(), value);
}
inline bool LightIntensityValidity_Parse(
    const ::std::string& name, LightIntensityValidity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LightIntensityValidity>(
    LightIntensityValidity_descriptor(), name, value);
}
enum TurningLightStatus {
  kOff = 0,
  kOn = 1,
  kError = 2,
  kReserved = 3,
  TurningLightStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TurningLightStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TurningLightStatus_IsValid(int value);
const TurningLightStatus TurningLightStatus_MIN = kOff;
const TurningLightStatus TurningLightStatus_MAX = kReserved;
const int TurningLightStatus_ARRAYSIZE = TurningLightStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TurningLightStatus_descriptor();
inline const ::std::string& TurningLightStatus_Name(TurningLightStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TurningLightStatus_descriptor(), value);
}
inline bool TurningLightStatus_Parse(
    const ::std::string& name, TurningLightStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TurningLightStatus>(
    TurningLightStatus_descriptor(), name, value);
}
enum RainFallLevel {
  kAmntSnsrAmnt = 0,
  kAmntSnsrInitValue = 14,
  kAmntSnsrError = 15,
  RainFallLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RainFallLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RainFallLevel_IsValid(int value);
const RainFallLevel RainFallLevel_MIN = kAmntSnsrAmnt;
const RainFallLevel RainFallLevel_MAX = kAmntSnsrError;
const int RainFallLevel_ARRAYSIZE = RainFallLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* RainFallLevel_descriptor();
inline const ::std::string& RainFallLevel_Name(RainFallLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    RainFallLevel_descriptor(), value);
}
inline bool RainFallLevel_Parse(
    const ::std::string& name, RainFallLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RainFallLevel>(
    RainFallLevel_descriptor(), name, value);
}
// ===================================================================

class StableDataPitch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.StableDataPitch) */ {
 public:
  StableDataPitch();
  virtual ~StableDataPitch();

  StableDataPitch(const StableDataPitch& from);

  inline StableDataPitch& operator=(const StableDataPitch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StableDataPitch(StableDataPitch&& from) noexcept
    : StableDataPitch() {
    *this = ::std::move(from);
  }

  inline StableDataPitch& operator=(StableDataPitch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StableDataPitch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StableDataPitch* internal_default_instance() {
    return reinterpret_cast<const StableDataPitch*>(
               &_StableDataPitch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(StableDataPitch* other);
  friend void swap(StableDataPitch& a, StableDataPitch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StableDataPitch* New() const PROTOBUF_FINAL { return New(NULL); }

  StableDataPitch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StableDataPitch& from);
  void MergeFrom(const StableDataPitch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StableDataPitch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float pitch = 1;
  void clear_pitch();
  static const int kPitchFieldNumber = 1;
  float pitch() const;
  void set_pitch(float value);

  // bool is_valid = 2;
  void clear_is_valid();
  static const int kIsValidFieldNumber = 2;
  bool is_valid() const;
  void set_is_valid(bool value);

  // bool is_jitter = 3;
  void clear_is_jitter();
  static const int kIsJitterFieldNumber = 3;
  bool is_jitter() const;
  void set_is_jitter(bool value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.StableDataPitch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float pitch_;
  bool is_valid_;
  bool is_jitter_;
  mutable int _cached_size_;
  friend struct ::protobuf_odometry_5fdata_2eproto::TableStruct;
  friend void ::protobuf_odometry_5fdata_2eproto::InitDefaultsStableDataPitchImpl();
};
// -------------------------------------------------------------------

class Vehicle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.Vehicle) */ {
 public:
  Vehicle();
  virtual ~Vehicle();

  Vehicle(const Vehicle& from);

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Vehicle* other);
  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle* New() const PROTOBUF_FINAL { return New(NULL); }

  Vehicle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vehicle& from);
  void MergeFrom(const Vehicle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vehicle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 whl_pulse = 7;
  int whl_pulse_size() const;
  void clear_whl_pulse();
  static const int kWhlPulseFieldNumber = 7;
  ::google::protobuf::uint32 whl_pulse(int index) const;
  void set_whl_pulse(int index, ::google::protobuf::uint32 value);
  void add_whl_pulse(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      whl_pulse() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_whl_pulse();

  // repeated uint32 whl_pulse_valid = 8;
  int whl_pulse_valid_size() const;
  void clear_whl_pulse_valid();
  static const int kWhlPulseValidFieldNumber = 8;
  ::google::protobuf::uint32 whl_pulse_valid(int index) const;
  void set_whl_pulse_valid(int index, ::google::protobuf::uint32 value);
  void add_whl_pulse_valid(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      whl_pulse_valid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_whl_pulse_valid();

  // repeated float whl_speed = 9;
  int whl_speed_size() const;
  void clear_whl_speed();
  static const int kWhlSpeedFieldNumber = 9;
  float whl_speed(int index) const;
  void set_whl_speed(int index, float value);
  void add_whl_speed(float value);
  const ::google::protobuf::RepeatedField< float >&
      whl_speed() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_whl_speed();

  // repeated uint32 wl_pluse_direction = 13;
  int wl_pluse_direction_size() const;
  void clear_wl_pluse_direction();
  static const int kWlPluseDirectionFieldNumber = 13;
  ::google::protobuf::uint32 wl_pluse_direction(int index) const;
  void set_wl_pluse_direction(int index, ::google::protobuf::uint32 value);
  void add_wl_pluse_direction(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      wl_pluse_direction() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_wl_pluse_direction();

  // repeated uint32 tire_pressure_valid = 14;
  int tire_pressure_valid_size() const;
  void clear_tire_pressure_valid();
  static const int kTirePressureValidFieldNumber = 14;
  ::google::protobuf::uint32 tire_pressure_valid(int index) const;
  void set_tire_pressure_valid(int index, ::google::protobuf::uint32 value);
  void add_tire_pressure_valid(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tire_pressure_valid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tire_pressure_valid();

  // repeated float tire_pressure = 15;
  int tire_pressure_size() const;
  void clear_tire_pressure();
  static const int kTirePressureFieldNumber = 15;
  float tire_pressure(int index) const;
  void set_tire_pressure(int index, float value);
  void add_tire_pressure(float value);
  const ::google::protobuf::RepeatedField< float >&
      tire_pressure() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_tire_pressure();

  // uint32 light_brightness_raw = 1;
  void clear_light_brightness_raw();
  static const int kLightBrightnessRawFieldNumber = 1;
  ::google::protobuf::uint32 light_brightness_raw() const;
  void set_light_brightness_raw(::google::protobuf::uint32 value);

  // .autodrive.workflow.proto.LightIntensityValidity lignt_validity = 2;
  void clear_lignt_validity();
  static const int kLigntValidityFieldNumber = 2;
  ::autodrive::workflow::proto::LightIntensityValidity lignt_validity() const;
  void set_lignt_validity(::autodrive::workflow::proto::LightIntensityValidity value);

  // .autodrive.workflow.proto.TurningLightStatus left_turning_light_status = 3;
  void clear_left_turning_light_status();
  static const int kLeftTurningLightStatusFieldNumber = 3;
  ::autodrive::workflow::proto::TurningLightStatus left_turning_light_status() const;
  void set_left_turning_light_status(::autodrive::workflow::proto::TurningLightStatus value);

  // .autodrive.workflow.proto.TurningLightStatus right_turning_light_status = 4;
  void clear_right_turning_light_status();
  static const int kRightTurningLightStatusFieldNumber = 4;
  ::autodrive::workflow::proto::TurningLightStatus right_turning_light_status() const;
  void set_right_turning_light_status(::autodrive::workflow::proto::TurningLightStatus value);

  // .autodrive.workflow.proto.RainFallLevel rain_fall_level = 5;
  void clear_rain_fall_level();
  static const int kRainFallLevelFieldNumber = 5;
  ::autodrive::workflow::proto::RainFallLevel rain_fall_level() const;
  void set_rain_fall_level(::autodrive::workflow::proto::RainFallLevel value);

  // .autodrive.workflow.proto.Gear gear = 6;
  void clear_gear();
  static const int kGearFieldNumber = 6;
  ::autodrive::workflow::proto::Gear gear() const;
  void set_gear(::autodrive::workflow::proto::Gear value);

  // uint32 yaw_rate_valid = 10;
  void clear_yaw_rate_valid();
  static const int kYawRateValidFieldNumber = 10;
  ::google::protobuf::uint32 yaw_rate_valid() const;
  void set_yaw_rate_valid(::google::protobuf::uint32 value);

  // uint32 speed_valid = 11;
  void clear_speed_valid();
  static const int kSpeedValidFieldNumber = 11;
  ::google::protobuf::uint32 speed_valid() const;
  void set_speed_valid(::google::protobuf::uint32 value);

  // uint32 gear_valid = 12;
  void clear_gear_valid();
  static const int kGearValidFieldNumber = 12;
  ::google::protobuf::uint32 gear_valid() const;
  void set_gear_valid(::google::protobuf::uint32 value);

  // uint32 wheel_size = 16;
  void clear_wheel_size();
  static const int kWheelSizeFieldNumber = 16;
  ::google::protobuf::uint32 wheel_size() const;
  void set_wheel_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.Vehicle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > whl_pulse_;
  mutable int _whl_pulse_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > whl_pulse_valid_;
  mutable int _whl_pulse_valid_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > whl_speed_;
  mutable int _whl_speed_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > wl_pluse_direction_;
  mutable int _wl_pluse_direction_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tire_pressure_valid_;
  mutable int _tire_pressure_valid_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > tire_pressure_;
  mutable int _tire_pressure_cached_byte_size_;
  ::google::protobuf::uint32 light_brightness_raw_;
  int lignt_validity_;
  int left_turning_light_status_;
  int right_turning_light_status_;
  int rain_fall_level_;
  int gear_;
  ::google::protobuf::uint32 yaw_rate_valid_;
  ::google::protobuf::uint32 speed_valid_;
  ::google::protobuf::uint32 gear_valid_;
  ::google::protobuf::uint32 wheel_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_odometry_5fdata_2eproto::TableStruct;
  friend void ::protobuf_odometry_5fdata_2eproto::InitDefaultsVehicleImpl();
};
// -------------------------------------------------------------------

class OdometryMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.OdometryMsg) */ {
 public:
  OdometryMsg();
  virtual ~OdometryMsg();

  OdometryMsg(const OdometryMsg& from);

  inline OdometryMsg& operator=(const OdometryMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OdometryMsg(OdometryMsg&& from) noexcept
    : OdometryMsg() {
    *this = ::std::move(from);
  }

  inline OdometryMsg& operator=(OdometryMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OdometryMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OdometryMsg* internal_default_instance() {
    return reinterpret_cast<const OdometryMsg*>(
               &_OdometryMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(OdometryMsg* other);
  friend void swap(OdometryMsg& a, OdometryMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OdometryMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  OdometryMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OdometryMsg& from);
  void MergeFrom(const OdometryMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OdometryMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.MsgHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::MsgHeader& header() const;
  ::autodrive::workflow::proto::MsgHeader* release_header();
  ::autodrive::workflow::proto::MsgHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::MsgHeader* header);

  // .autodrive.workflow.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::autodrive::workflow::proto::Error& error() const;
  ::autodrive::workflow::proto::Error* release_error();
  ::autodrive::workflow::proto::Error* mutable_error();
  void set_allocated_error(::autodrive::workflow::proto::Error* error);

  // .autodrive.workflow.proto.Vector3f position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::autodrive::workflow::proto::Vector3f& position() const;
  ::autodrive::workflow::proto::Vector3f* release_position();
  ::autodrive::workflow::proto::Vector3f* mutable_position();
  void set_allocated_position(::autodrive::workflow::proto::Vector3f* position);

  // .autodrive.workflow.proto.Vector3f orientation = 4;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  const ::autodrive::workflow::proto::Vector3f& orientation() const;
  ::autodrive::workflow::proto::Vector3f* release_orientation();
  ::autodrive::workflow::proto::Vector3f* mutable_orientation();
  void set_allocated_orientation(::autodrive::workflow::proto::Vector3f* orientation);

  // .autodrive.workflow.proto.Vector2f acceleration = 7;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 7;
  const ::autodrive::workflow::proto::Vector2f& acceleration() const;
  ::autodrive::workflow::proto::Vector2f* release_acceleration();
  ::autodrive::workflow::proto::Vector2f* mutable_acceleration();
  void set_allocated_acceleration(::autodrive::workflow::proto::Vector2f* acceleration);

  // .autodrive.workflow.proto.StableDataPitch stable_pitch = 12;
  bool has_stable_pitch() const;
  void clear_stable_pitch();
  static const int kStablePitchFieldNumber = 12;
  const ::autodrive::workflow::proto::StableDataPitch& stable_pitch() const;
  ::autodrive::workflow::proto::StableDataPitch* release_stable_pitch();
  ::autodrive::workflow::proto::StableDataPitch* mutable_stable_pitch();
  void set_allocated_stable_pitch(::autodrive::workflow::proto::StableDataPitch* stable_pitch);

  // .autodrive.workflow.proto.Vector3d cov_translation = 15;
  bool has_cov_translation() const;
  void clear_cov_translation();
  static const int kCovTranslationFieldNumber = 15;
  const ::autodrive::workflow::proto::Vector3d& cov_translation() const;
  ::autodrive::workflow::proto::Vector3d* release_cov_translation();
  ::autodrive::workflow::proto::Vector3d* mutable_cov_translation();
  void set_allocated_cov_translation(::autodrive::workflow::proto::Vector3d* cov_translation);

  // .autodrive.workflow.proto.Vector3d cov_eular_angle = 16;
  bool has_cov_eular_angle() const;
  void clear_cov_eular_angle();
  static const int kCovEularAngleFieldNumber = 16;
  const ::autodrive::workflow::proto::Vector3d& cov_eular_angle() const;
  ::autodrive::workflow::proto::Vector3d* release_cov_eular_angle();
  ::autodrive::workflow::proto::Vector3d* mutable_cov_eular_angle();
  void set_allocated_cov_eular_angle(::autodrive::workflow::proto::Vector3d* cov_eular_angle);

  // .autodrive.workflow.proto.Vector3d position_hr = 17;
  bool has_position_hr() const;
  void clear_position_hr();
  static const int kPositionHrFieldNumber = 17;
  const ::autodrive::workflow::proto::Vector3d& position_hr() const;
  ::autodrive::workflow::proto::Vector3d* release_position_hr();
  ::autodrive::workflow::proto::Vector3d* mutable_position_hr();
  void set_allocated_position_hr(::autodrive::workflow::proto::Vector3d* position_hr);

  // .autodrive.workflow.proto.Vehicle vehicle_info = 24;
  bool has_vehicle_info() const;
  void clear_vehicle_info();
  static const int kVehicleInfoFieldNumber = 24;
  const ::autodrive::workflow::proto::Vehicle& vehicle_info() const;
  ::autodrive::workflow::proto::Vehicle* release_vehicle_info();
  ::autodrive::workflow::proto::Vehicle* mutable_vehicle_info();
  void set_allocated_vehicle_info(::autodrive::workflow::proto::Vehicle* vehicle_info);

  // float speed = 5;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  float speed() const;
  void set_speed(float value);

  // float speed_scale = 6;
  void clear_speed_scale();
  static const int kSpeedScaleFieldNumber = 6;
  float speed_scale() const;
  void set_speed_scale(float value);

  // float yaw_rate = 8;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 8;
  float yaw_rate() const;
  void set_yaw_rate(float value);

  // float yaw_rate_bias = 9;
  void clear_yaw_rate_bias();
  static const int kYawRateBiasFieldNumber = 9;
  float yaw_rate_bias() const;
  void set_yaw_rate_bias(float value);

  // float wheel_angle = 10;
  void clear_wheel_angle();
  static const int kWheelAngleFieldNumber = 10;
  float wheel_angle() const;
  void set_wheel_angle(float value);

  // float slope = 11;
  void clear_slope();
  static const int kSlopeFieldNumber = 11;
  float slope() const;
  void set_slope(float value);

  // float slope_confidence = 13;
  void clear_slope_confidence();
  static const int kSlopeConfidenceFieldNumber = 13;
  float slope_confidence() const;
  void set_slope_confidence(float value);

  // uint32 diagnostic_code = 14;
  void clear_diagnostic_code();
  static const int kDiagnosticCodeFieldNumber = 14;
  ::google::protobuf::uint32 diagnostic_code() const;
  void set_diagnostic_code(::google::protobuf::uint32 value);

  // uint32 source = 18;
  void clear_source();
  static const int kSourceFieldNumber = 18;
  ::google::protobuf::uint32 source() const;
  void set_source(::google::protobuf::uint32 value);

  // bool is_slope_available = 19;
  void clear_is_slope_available();
  static const int kIsSlopeAvailableFieldNumber = 19;
  bool is_slope_available() const;
  void set_is_slope_available(bool value);

  // .autodrive.workflow.proto.OdometryDataType type = 20;
  void clear_type();
  static const int kTypeFieldNumber = 20;
  ::autodrive::workflow::proto::OdometryDataType type() const;
  void set_type(::autodrive::workflow::proto::OdometryDataType value);

  // .autodrive.workflow.proto.OdometryDataState state = 21;
  void clear_state();
  static const int kStateFieldNumber = 21;
  ::autodrive::workflow::proto::OdometryDataState state() const;
  void set_state(::autodrive::workflow::proto::OdometryDataState value);

  // .autodrive.workflow.proto.OdometryDataErrorCode error_code = 22;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 22;
  ::autodrive::workflow::proto::OdometryDataErrorCode error_code() const;
  void set_error_code(::autodrive::workflow::proto::OdometryDataErrorCode value);

  // .autodrive.workflow.proto.OdometryDataYawRateBiasEstimateState yaw_rate_bias_estimate_state = 23;
  void clear_yaw_rate_bias_estimate_state();
  static const int kYawRateBiasEstimateStateFieldNumber = 23;
  ::autodrive::workflow::proto::OdometryDataYawRateBiasEstimateState yaw_rate_bias_estimate_state() const;
  void set_yaw_rate_bias_estimate_state(::autodrive::workflow::proto::OdometryDataYawRateBiasEstimateState value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.OdometryMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::MsgHeader* header_;
  ::autodrive::workflow::proto::Error* error_;
  ::autodrive::workflow::proto::Vector3f* position_;
  ::autodrive::workflow::proto::Vector3f* orientation_;
  ::autodrive::workflow::proto::Vector2f* acceleration_;
  ::autodrive::workflow::proto::StableDataPitch* stable_pitch_;
  ::autodrive::workflow::proto::Vector3d* cov_translation_;
  ::autodrive::workflow::proto::Vector3d* cov_eular_angle_;
  ::autodrive::workflow::proto::Vector3d* position_hr_;
  ::autodrive::workflow::proto::Vehicle* vehicle_info_;
  float speed_;
  float speed_scale_;
  float yaw_rate_;
  float yaw_rate_bias_;
  float wheel_angle_;
  float slope_;
  float slope_confidence_;
  ::google::protobuf::uint32 diagnostic_code_;
  ::google::protobuf::uint32 source_;
  bool is_slope_available_;
  int type_;
  int state_;
  int error_code_;
  int yaw_rate_bias_estimate_state_;
  mutable int _cached_size_;
  friend struct ::protobuf_odometry_5fdata_2eproto::TableStruct;
  friend void ::protobuf_odometry_5fdata_2eproto::InitDefaultsOdometryMsgImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StableDataPitch

// float pitch = 1;
inline void StableDataPitch::clear_pitch() {
  pitch_ = 0;
}
inline float StableDataPitch::pitch() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StableDataPitch.pitch)
  return pitch_;
}
inline void StableDataPitch::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StableDataPitch.pitch)
}

// bool is_valid = 2;
inline void StableDataPitch::clear_is_valid() {
  is_valid_ = false;
}
inline bool StableDataPitch::is_valid() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StableDataPitch.is_valid)
  return is_valid_;
}
inline void StableDataPitch::set_is_valid(bool value) {
  
  is_valid_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StableDataPitch.is_valid)
}

// bool is_jitter = 3;
inline void StableDataPitch::clear_is_jitter() {
  is_jitter_ = false;
}
inline bool StableDataPitch::is_jitter() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StableDataPitch.is_jitter)
  return is_jitter_;
}
inline void StableDataPitch::set_is_jitter(bool value) {
  
  is_jitter_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StableDataPitch.is_jitter)
}

// -------------------------------------------------------------------

// Vehicle

// uint32 light_brightness_raw = 1;
inline void Vehicle::clear_light_brightness_raw() {
  light_brightness_raw_ = 0u;
}
inline ::google::protobuf::uint32 Vehicle::light_brightness_raw() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.light_brightness_raw)
  return light_brightness_raw_;
}
inline void Vehicle::set_light_brightness_raw(::google::protobuf::uint32 value) {
  
  light_brightness_raw_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.light_brightness_raw)
}

// .autodrive.workflow.proto.LightIntensityValidity lignt_validity = 2;
inline void Vehicle::clear_lignt_validity() {
  lignt_validity_ = 0;
}
inline ::autodrive::workflow::proto::LightIntensityValidity Vehicle::lignt_validity() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.lignt_validity)
  return static_cast< ::autodrive::workflow::proto::LightIntensityValidity >(lignt_validity_);
}
inline void Vehicle::set_lignt_validity(::autodrive::workflow::proto::LightIntensityValidity value) {
  
  lignt_validity_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.lignt_validity)
}

// .autodrive.workflow.proto.TurningLightStatus left_turning_light_status = 3;
inline void Vehicle::clear_left_turning_light_status() {
  left_turning_light_status_ = 0;
}
inline ::autodrive::workflow::proto::TurningLightStatus Vehicle::left_turning_light_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.left_turning_light_status)
  return static_cast< ::autodrive::workflow::proto::TurningLightStatus >(left_turning_light_status_);
}
inline void Vehicle::set_left_turning_light_status(::autodrive::workflow::proto::TurningLightStatus value) {
  
  left_turning_light_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.left_turning_light_status)
}

// .autodrive.workflow.proto.TurningLightStatus right_turning_light_status = 4;
inline void Vehicle::clear_right_turning_light_status() {
  right_turning_light_status_ = 0;
}
inline ::autodrive::workflow::proto::TurningLightStatus Vehicle::right_turning_light_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.right_turning_light_status)
  return static_cast< ::autodrive::workflow::proto::TurningLightStatus >(right_turning_light_status_);
}
inline void Vehicle::set_right_turning_light_status(::autodrive::workflow::proto::TurningLightStatus value) {
  
  right_turning_light_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.right_turning_light_status)
}

// .autodrive.workflow.proto.RainFallLevel rain_fall_level = 5;
inline void Vehicle::clear_rain_fall_level() {
  rain_fall_level_ = 0;
}
inline ::autodrive::workflow::proto::RainFallLevel Vehicle::rain_fall_level() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.rain_fall_level)
  return static_cast< ::autodrive::workflow::proto::RainFallLevel >(rain_fall_level_);
}
inline void Vehicle::set_rain_fall_level(::autodrive::workflow::proto::RainFallLevel value) {
  
  rain_fall_level_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.rain_fall_level)
}

// .autodrive.workflow.proto.Gear gear = 6;
inline void Vehicle::clear_gear() {
  gear_ = 0;
}
inline ::autodrive::workflow::proto::Gear Vehicle::gear() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.gear)
  return static_cast< ::autodrive::workflow::proto::Gear >(gear_);
}
inline void Vehicle::set_gear(::autodrive::workflow::proto::Gear value) {
  
  gear_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.gear)
}

// repeated uint32 whl_pulse = 7;
inline int Vehicle::whl_pulse_size() const {
  return whl_pulse_.size();
}
inline void Vehicle::clear_whl_pulse() {
  whl_pulse_.Clear();
}
inline ::google::protobuf::uint32 Vehicle::whl_pulse(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.whl_pulse)
  return whl_pulse_.Get(index);
}
inline void Vehicle::set_whl_pulse(int index, ::google::protobuf::uint32 value) {
  whl_pulse_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.whl_pulse)
}
inline void Vehicle::add_whl_pulse(::google::protobuf::uint32 value) {
  whl_pulse_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.Vehicle.whl_pulse)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Vehicle::whl_pulse() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.Vehicle.whl_pulse)
  return whl_pulse_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Vehicle::mutable_whl_pulse() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.Vehicle.whl_pulse)
  return &whl_pulse_;
}

// repeated uint32 whl_pulse_valid = 8;
inline int Vehicle::whl_pulse_valid_size() const {
  return whl_pulse_valid_.size();
}
inline void Vehicle::clear_whl_pulse_valid() {
  whl_pulse_valid_.Clear();
}
inline ::google::protobuf::uint32 Vehicle::whl_pulse_valid(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.whl_pulse_valid)
  return whl_pulse_valid_.Get(index);
}
inline void Vehicle::set_whl_pulse_valid(int index, ::google::protobuf::uint32 value) {
  whl_pulse_valid_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.whl_pulse_valid)
}
inline void Vehicle::add_whl_pulse_valid(::google::protobuf::uint32 value) {
  whl_pulse_valid_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.Vehicle.whl_pulse_valid)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Vehicle::whl_pulse_valid() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.Vehicle.whl_pulse_valid)
  return whl_pulse_valid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Vehicle::mutable_whl_pulse_valid() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.Vehicle.whl_pulse_valid)
  return &whl_pulse_valid_;
}

// repeated float whl_speed = 9;
inline int Vehicle::whl_speed_size() const {
  return whl_speed_.size();
}
inline void Vehicle::clear_whl_speed() {
  whl_speed_.Clear();
}
inline float Vehicle::whl_speed(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.whl_speed)
  return whl_speed_.Get(index);
}
inline void Vehicle::set_whl_speed(int index, float value) {
  whl_speed_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.whl_speed)
}
inline void Vehicle::add_whl_speed(float value) {
  whl_speed_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.Vehicle.whl_speed)
}
inline const ::google::protobuf::RepeatedField< float >&
Vehicle::whl_speed() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.Vehicle.whl_speed)
  return whl_speed_;
}
inline ::google::protobuf::RepeatedField< float >*
Vehicle::mutable_whl_speed() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.Vehicle.whl_speed)
  return &whl_speed_;
}

// uint32 yaw_rate_valid = 10;
inline void Vehicle::clear_yaw_rate_valid() {
  yaw_rate_valid_ = 0u;
}
inline ::google::protobuf::uint32 Vehicle::yaw_rate_valid() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.yaw_rate_valid)
  return yaw_rate_valid_;
}
inline void Vehicle::set_yaw_rate_valid(::google::protobuf::uint32 value) {
  
  yaw_rate_valid_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.yaw_rate_valid)
}

// uint32 speed_valid = 11;
inline void Vehicle::clear_speed_valid() {
  speed_valid_ = 0u;
}
inline ::google::protobuf::uint32 Vehicle::speed_valid() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.speed_valid)
  return speed_valid_;
}
inline void Vehicle::set_speed_valid(::google::protobuf::uint32 value) {
  
  speed_valid_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.speed_valid)
}

// uint32 gear_valid = 12;
inline void Vehicle::clear_gear_valid() {
  gear_valid_ = 0u;
}
inline ::google::protobuf::uint32 Vehicle::gear_valid() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.gear_valid)
  return gear_valid_;
}
inline void Vehicle::set_gear_valid(::google::protobuf::uint32 value) {
  
  gear_valid_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.gear_valid)
}

// repeated uint32 wl_pluse_direction = 13;
inline int Vehicle::wl_pluse_direction_size() const {
  return wl_pluse_direction_.size();
}
inline void Vehicle::clear_wl_pluse_direction() {
  wl_pluse_direction_.Clear();
}
inline ::google::protobuf::uint32 Vehicle::wl_pluse_direction(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.wl_pluse_direction)
  return wl_pluse_direction_.Get(index);
}
inline void Vehicle::set_wl_pluse_direction(int index, ::google::protobuf::uint32 value) {
  wl_pluse_direction_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.wl_pluse_direction)
}
inline void Vehicle::add_wl_pluse_direction(::google::protobuf::uint32 value) {
  wl_pluse_direction_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.Vehicle.wl_pluse_direction)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Vehicle::wl_pluse_direction() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.Vehicle.wl_pluse_direction)
  return wl_pluse_direction_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Vehicle::mutable_wl_pluse_direction() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.Vehicle.wl_pluse_direction)
  return &wl_pluse_direction_;
}

// repeated uint32 tire_pressure_valid = 14;
inline int Vehicle::tire_pressure_valid_size() const {
  return tire_pressure_valid_.size();
}
inline void Vehicle::clear_tire_pressure_valid() {
  tire_pressure_valid_.Clear();
}
inline ::google::protobuf::uint32 Vehicle::tire_pressure_valid(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.tire_pressure_valid)
  return tire_pressure_valid_.Get(index);
}
inline void Vehicle::set_tire_pressure_valid(int index, ::google::protobuf::uint32 value) {
  tire_pressure_valid_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.tire_pressure_valid)
}
inline void Vehicle::add_tire_pressure_valid(::google::protobuf::uint32 value) {
  tire_pressure_valid_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.Vehicle.tire_pressure_valid)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Vehicle::tire_pressure_valid() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.Vehicle.tire_pressure_valid)
  return tire_pressure_valid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Vehicle::mutable_tire_pressure_valid() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.Vehicle.tire_pressure_valid)
  return &tire_pressure_valid_;
}

// repeated float tire_pressure = 15;
inline int Vehicle::tire_pressure_size() const {
  return tire_pressure_.size();
}
inline void Vehicle::clear_tire_pressure() {
  tire_pressure_.Clear();
}
inline float Vehicle::tire_pressure(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.tire_pressure)
  return tire_pressure_.Get(index);
}
inline void Vehicle::set_tire_pressure(int index, float value) {
  tire_pressure_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.tire_pressure)
}
inline void Vehicle::add_tire_pressure(float value) {
  tire_pressure_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.Vehicle.tire_pressure)
}
inline const ::google::protobuf::RepeatedField< float >&
Vehicle::tire_pressure() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.Vehicle.tire_pressure)
  return tire_pressure_;
}
inline ::google::protobuf::RepeatedField< float >*
Vehicle::mutable_tire_pressure() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.Vehicle.tire_pressure)
  return &tire_pressure_;
}

// uint32 wheel_size = 16;
inline void Vehicle::clear_wheel_size() {
  wheel_size_ = 0u;
}
inline ::google::protobuf::uint32 Vehicle::wheel_size() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Vehicle.wheel_size)
  return wheel_size_;
}
inline void Vehicle::set_wheel_size(::google::protobuf::uint32 value) {
  
  wheel_size_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Vehicle.wheel_size)
}

// -------------------------------------------------------------------

// OdometryMsg

// .autodrive.workflow.proto.MsgHeader header = 1;
inline bool OdometryMsg::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::MsgHeader& OdometryMsg::header() const {
  const ::autodrive::workflow::proto::MsgHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::MsgHeader*>(
      &::autodrive::workflow::proto::_MsgHeader_default_instance_);
}
inline ::autodrive::workflow::proto::MsgHeader* OdometryMsg::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.OdometryMsg.header)
  
  ::autodrive::workflow::proto::MsgHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::MsgHeader* OdometryMsg::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::MsgHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.OdometryMsg.header)
  return header_;
}
inline void OdometryMsg::set_allocated_header(::autodrive::workflow::proto::MsgHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.OdometryMsg.header)
}

// .autodrive.workflow.proto.Error error = 2;
inline bool OdometryMsg::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::autodrive::workflow::proto::Error& OdometryMsg::error() const {
  const ::autodrive::workflow::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.error)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Error*>(
      &::autodrive::workflow::proto::_Error_default_instance_);
}
inline ::autodrive::workflow::proto::Error* OdometryMsg::release_error() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.OdometryMsg.error)
  
  ::autodrive::workflow::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Error* OdometryMsg::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::autodrive::workflow::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.OdometryMsg.error)
  return error_;
}
inline void OdometryMsg::set_allocated_error(::autodrive::workflow::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.OdometryMsg.error)
}

// .autodrive.workflow.proto.Vector3f position = 3;
inline bool OdometryMsg::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& OdometryMsg::position() const {
  const ::autodrive::workflow::proto::Vector3f* p = position_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.position)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* OdometryMsg::release_position() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.OdometryMsg.position)
  
  ::autodrive::workflow::proto::Vector3f* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* OdometryMsg::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.OdometryMsg.position)
  return position_;
}
inline void OdometryMsg::set_allocated_position(::autodrive::workflow::proto::Vector3f* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.OdometryMsg.position)
}

// .autodrive.workflow.proto.Vector3f orientation = 4;
inline bool OdometryMsg::has_orientation() const {
  return this != internal_default_instance() && orientation_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& OdometryMsg::orientation() const {
  const ::autodrive::workflow::proto::Vector3f* p = orientation_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* OdometryMsg::release_orientation() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.OdometryMsg.orientation)
  
  ::autodrive::workflow::proto::Vector3f* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* OdometryMsg::mutable_orientation() {
  
  if (orientation_ == NULL) {
    orientation_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.OdometryMsg.orientation)
  return orientation_;
}
inline void OdometryMsg::set_allocated_orientation(::autodrive::workflow::proto::Vector3f* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(orientation_);
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.OdometryMsg.orientation)
}

// float speed = 5;
inline void OdometryMsg::clear_speed() {
  speed_ = 0;
}
inline float OdometryMsg::speed() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.speed)
  return speed_;
}
inline void OdometryMsg::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.speed)
}

// float speed_scale = 6;
inline void OdometryMsg::clear_speed_scale() {
  speed_scale_ = 0;
}
inline float OdometryMsg::speed_scale() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.speed_scale)
  return speed_scale_;
}
inline void OdometryMsg::set_speed_scale(float value) {
  
  speed_scale_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.speed_scale)
}

// .autodrive.workflow.proto.Vector2f acceleration = 7;
inline bool OdometryMsg::has_acceleration() const {
  return this != internal_default_instance() && acceleration_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector2f& OdometryMsg::acceleration() const {
  const ::autodrive::workflow::proto::Vector2f* p = acceleration_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector2f*>(
      &::autodrive::workflow::proto::_Vector2f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector2f* OdometryMsg::release_acceleration() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.OdometryMsg.acceleration)
  
  ::autodrive::workflow::proto::Vector2f* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector2f* OdometryMsg::mutable_acceleration() {
  
  if (acceleration_ == NULL) {
    acceleration_ = new ::autodrive::workflow::proto::Vector2f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.OdometryMsg.acceleration)
  return acceleration_;
}
inline void OdometryMsg::set_allocated_acceleration(::autodrive::workflow::proto::Vector2f* acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(acceleration_);
  }
  if (acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.OdometryMsg.acceleration)
}

// float yaw_rate = 8;
inline void OdometryMsg::clear_yaw_rate() {
  yaw_rate_ = 0;
}
inline float OdometryMsg::yaw_rate() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.yaw_rate)
  return yaw_rate_;
}
inline void OdometryMsg::set_yaw_rate(float value) {
  
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.yaw_rate)
}

// float yaw_rate_bias = 9;
inline void OdometryMsg::clear_yaw_rate_bias() {
  yaw_rate_bias_ = 0;
}
inline float OdometryMsg::yaw_rate_bias() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.yaw_rate_bias)
  return yaw_rate_bias_;
}
inline void OdometryMsg::set_yaw_rate_bias(float value) {
  
  yaw_rate_bias_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.yaw_rate_bias)
}

// float wheel_angle = 10;
inline void OdometryMsg::clear_wheel_angle() {
  wheel_angle_ = 0;
}
inline float OdometryMsg::wheel_angle() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.wheel_angle)
  return wheel_angle_;
}
inline void OdometryMsg::set_wheel_angle(float value) {
  
  wheel_angle_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.wheel_angle)
}

// float slope = 11;
inline void OdometryMsg::clear_slope() {
  slope_ = 0;
}
inline float OdometryMsg::slope() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.slope)
  return slope_;
}
inline void OdometryMsg::set_slope(float value) {
  
  slope_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.slope)
}

// .autodrive.workflow.proto.StableDataPitch stable_pitch = 12;
inline bool OdometryMsg::has_stable_pitch() const {
  return this != internal_default_instance() && stable_pitch_ != NULL;
}
inline void OdometryMsg::clear_stable_pitch() {
  if (GetArenaNoVirtual() == NULL && stable_pitch_ != NULL) {
    delete stable_pitch_;
  }
  stable_pitch_ = NULL;
}
inline const ::autodrive::workflow::proto::StableDataPitch& OdometryMsg::stable_pitch() const {
  const ::autodrive::workflow::proto::StableDataPitch* p = stable_pitch_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.stable_pitch)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::StableDataPitch*>(
      &::autodrive::workflow::proto::_StableDataPitch_default_instance_);
}
inline ::autodrive::workflow::proto::StableDataPitch* OdometryMsg::release_stable_pitch() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.OdometryMsg.stable_pitch)
  
  ::autodrive::workflow::proto::StableDataPitch* temp = stable_pitch_;
  stable_pitch_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::StableDataPitch* OdometryMsg::mutable_stable_pitch() {
  
  if (stable_pitch_ == NULL) {
    stable_pitch_ = new ::autodrive::workflow::proto::StableDataPitch;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.OdometryMsg.stable_pitch)
  return stable_pitch_;
}
inline void OdometryMsg::set_allocated_stable_pitch(::autodrive::workflow::proto::StableDataPitch* stable_pitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stable_pitch_;
  }
  if (stable_pitch) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stable_pitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stable_pitch, submessage_arena);
    }
    
  } else {
    
  }
  stable_pitch_ = stable_pitch;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.OdometryMsg.stable_pitch)
}

// float slope_confidence = 13;
inline void OdometryMsg::clear_slope_confidence() {
  slope_confidence_ = 0;
}
inline float OdometryMsg::slope_confidence() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.slope_confidence)
  return slope_confidence_;
}
inline void OdometryMsg::set_slope_confidence(float value) {
  
  slope_confidence_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.slope_confidence)
}

// uint32 diagnostic_code = 14;
inline void OdometryMsg::clear_diagnostic_code() {
  diagnostic_code_ = 0u;
}
inline ::google::protobuf::uint32 OdometryMsg::diagnostic_code() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.diagnostic_code)
  return diagnostic_code_;
}
inline void OdometryMsg::set_diagnostic_code(::google::protobuf::uint32 value) {
  
  diagnostic_code_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.diagnostic_code)
}

// .autodrive.workflow.proto.Vector3d cov_translation = 15;
inline bool OdometryMsg::has_cov_translation() const {
  return this != internal_default_instance() && cov_translation_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& OdometryMsg::cov_translation() const {
  const ::autodrive::workflow::proto::Vector3d* p = cov_translation_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.cov_translation)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* OdometryMsg::release_cov_translation() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.OdometryMsg.cov_translation)
  
  ::autodrive::workflow::proto::Vector3d* temp = cov_translation_;
  cov_translation_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* OdometryMsg::mutable_cov_translation() {
  
  if (cov_translation_ == NULL) {
    cov_translation_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.OdometryMsg.cov_translation)
  return cov_translation_;
}
inline void OdometryMsg::set_allocated_cov_translation(::autodrive::workflow::proto::Vector3d* cov_translation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cov_translation_);
  }
  if (cov_translation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cov_translation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cov_translation, submessage_arena);
    }
    
  } else {
    
  }
  cov_translation_ = cov_translation;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.OdometryMsg.cov_translation)
}

// .autodrive.workflow.proto.Vector3d cov_eular_angle = 16;
inline bool OdometryMsg::has_cov_eular_angle() const {
  return this != internal_default_instance() && cov_eular_angle_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& OdometryMsg::cov_eular_angle() const {
  const ::autodrive::workflow::proto::Vector3d* p = cov_eular_angle_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.cov_eular_angle)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* OdometryMsg::release_cov_eular_angle() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.OdometryMsg.cov_eular_angle)
  
  ::autodrive::workflow::proto::Vector3d* temp = cov_eular_angle_;
  cov_eular_angle_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* OdometryMsg::mutable_cov_eular_angle() {
  
  if (cov_eular_angle_ == NULL) {
    cov_eular_angle_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.OdometryMsg.cov_eular_angle)
  return cov_eular_angle_;
}
inline void OdometryMsg::set_allocated_cov_eular_angle(::autodrive::workflow::proto::Vector3d* cov_eular_angle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cov_eular_angle_);
  }
  if (cov_eular_angle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cov_eular_angle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cov_eular_angle, submessage_arena);
    }
    
  } else {
    
  }
  cov_eular_angle_ = cov_eular_angle;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.OdometryMsg.cov_eular_angle)
}

// .autodrive.workflow.proto.Vector3d position_hr = 17;
inline bool OdometryMsg::has_position_hr() const {
  return this != internal_default_instance() && position_hr_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& OdometryMsg::position_hr() const {
  const ::autodrive::workflow::proto::Vector3d* p = position_hr_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.position_hr)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* OdometryMsg::release_position_hr() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.OdometryMsg.position_hr)
  
  ::autodrive::workflow::proto::Vector3d* temp = position_hr_;
  position_hr_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* OdometryMsg::mutable_position_hr() {
  
  if (position_hr_ == NULL) {
    position_hr_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.OdometryMsg.position_hr)
  return position_hr_;
}
inline void OdometryMsg::set_allocated_position_hr(::autodrive::workflow::proto::Vector3d* position_hr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_hr_);
  }
  if (position_hr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position_hr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_hr, submessage_arena);
    }
    
  } else {
    
  }
  position_hr_ = position_hr;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.OdometryMsg.position_hr)
}

// uint32 source = 18;
inline void OdometryMsg::clear_source() {
  source_ = 0u;
}
inline ::google::protobuf::uint32 OdometryMsg::source() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.source)
  return source_;
}
inline void OdometryMsg::set_source(::google::protobuf::uint32 value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.source)
}

// bool is_slope_available = 19;
inline void OdometryMsg::clear_is_slope_available() {
  is_slope_available_ = false;
}
inline bool OdometryMsg::is_slope_available() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.is_slope_available)
  return is_slope_available_;
}
inline void OdometryMsg::set_is_slope_available(bool value) {
  
  is_slope_available_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.is_slope_available)
}

// .autodrive.workflow.proto.OdometryDataType type = 20;
inline void OdometryMsg::clear_type() {
  type_ = 0;
}
inline ::autodrive::workflow::proto::OdometryDataType OdometryMsg::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.type)
  return static_cast< ::autodrive::workflow::proto::OdometryDataType >(type_);
}
inline void OdometryMsg::set_type(::autodrive::workflow::proto::OdometryDataType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.type)
}

// .autodrive.workflow.proto.OdometryDataState state = 21;
inline void OdometryMsg::clear_state() {
  state_ = 0;
}
inline ::autodrive::workflow::proto::OdometryDataState OdometryMsg::state() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.state)
  return static_cast< ::autodrive::workflow::proto::OdometryDataState >(state_);
}
inline void OdometryMsg::set_state(::autodrive::workflow::proto::OdometryDataState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.state)
}

// .autodrive.workflow.proto.OdometryDataErrorCode error_code = 22;
inline void OdometryMsg::clear_error_code() {
  error_code_ = 0;
}
inline ::autodrive::workflow::proto::OdometryDataErrorCode OdometryMsg::error_code() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.error_code)
  return static_cast< ::autodrive::workflow::proto::OdometryDataErrorCode >(error_code_);
}
inline void OdometryMsg::set_error_code(::autodrive::workflow::proto::OdometryDataErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.error_code)
}

// .autodrive.workflow.proto.OdometryDataYawRateBiasEstimateState yaw_rate_bias_estimate_state = 23;
inline void OdometryMsg::clear_yaw_rate_bias_estimate_state() {
  yaw_rate_bias_estimate_state_ = 0;
}
inline ::autodrive::workflow::proto::OdometryDataYawRateBiasEstimateState OdometryMsg::yaw_rate_bias_estimate_state() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.yaw_rate_bias_estimate_state)
  return static_cast< ::autodrive::workflow::proto::OdometryDataYawRateBiasEstimateState >(yaw_rate_bias_estimate_state_);
}
inline void OdometryMsg::set_yaw_rate_bias_estimate_state(::autodrive::workflow::proto::OdometryDataYawRateBiasEstimateState value) {
  
  yaw_rate_bias_estimate_state_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.OdometryMsg.yaw_rate_bias_estimate_state)
}

// .autodrive.workflow.proto.Vehicle vehicle_info = 24;
inline bool OdometryMsg::has_vehicle_info() const {
  return this != internal_default_instance() && vehicle_info_ != NULL;
}
inline void OdometryMsg::clear_vehicle_info() {
  if (GetArenaNoVirtual() == NULL && vehicle_info_ != NULL) {
    delete vehicle_info_;
  }
  vehicle_info_ = NULL;
}
inline const ::autodrive::workflow::proto::Vehicle& OdometryMsg::vehicle_info() const {
  const ::autodrive::workflow::proto::Vehicle* p = vehicle_info_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.OdometryMsg.vehicle_info)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vehicle*>(
      &::autodrive::workflow::proto::_Vehicle_default_instance_);
}
inline ::autodrive::workflow::proto::Vehicle* OdometryMsg::release_vehicle_info() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.OdometryMsg.vehicle_info)
  
  ::autodrive::workflow::proto::Vehicle* temp = vehicle_info_;
  vehicle_info_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vehicle* OdometryMsg::mutable_vehicle_info() {
  
  if (vehicle_info_ == NULL) {
    vehicle_info_ = new ::autodrive::workflow::proto::Vehicle;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.OdometryMsg.vehicle_info)
  return vehicle_info_;
}
inline void OdometryMsg::set_allocated_vehicle_info(::autodrive::workflow::proto::Vehicle* vehicle_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vehicle_info_;
  }
  if (vehicle_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicle_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicle_info, submessage_arena);
    }
    
  } else {
    
  }
  vehicle_info_ = vehicle_info;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.OdometryMsg.vehicle_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::OdometryDataSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::OdometryDataSource>() {
  return ::autodrive::workflow::proto::OdometryDataSource_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::OdometryDataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::OdometryDataType>() {
  return ::autodrive::workflow::proto::OdometryDataType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::OdometryDataState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::OdometryDataState>() {
  return ::autodrive::workflow::proto::OdometryDataState_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::OdometryDataErrorCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::OdometryDataErrorCode>() {
  return ::autodrive::workflow::proto::OdometryDataErrorCode_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::OdometryDataYawRateBiasEstimateState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::OdometryDataYawRateBiasEstimateState>() {
  return ::autodrive::workflow::proto::OdometryDataYawRateBiasEstimateState_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::Gear> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::Gear>() {
  return ::autodrive::workflow::proto::Gear_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::LightIntensityValidity> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::LightIntensityValidity>() {
  return ::autodrive::workflow::proto::LightIntensityValidity_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::TurningLightStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::TurningLightStatus>() {
  return ::autodrive::workflow::proto::TurningLightStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::RainFallLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::RainFallLevel>() {
  return ::autodrive::workflow::proto::RainFallLevel_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_odometry_5fdata_2eproto__INCLUDED
