// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: road_info.proto

#include "road_info.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace autodrive {
namespace workflow {
namespace proto {
class RoadInfoCurveLineDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RoadInfoCurveLine>
      _instance;
} _RoadInfoCurveLine_default_instance_;
class BorderDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Border>
      _instance;
} _Border_default_instance_;
class RoadBordersDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RoadBorders>
      _instance;
} _RoadBorders_default_instance_;
class TransitionPointsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TransitionPoints>
      _instance;
} _TransitionPoints_default_instance_;
class RoadInfoLineDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RoadInfoLine>
      _instance;
} _RoadInfoLine_default_instance_;
class HighWayJunctionInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<HighWayJunctionInfo>
      _instance;
} _HighWayJunctionInfo_default_instance_;
class NumberOfLanesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NumberOfLanes>
      _instance;
} _NumberOfLanes_default_instance_;
class RoadInfoLinesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RoadInfoLines>
      _instance;
} _RoadInfoLines_default_instance_;
class StopLinesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<StopLines>
      _instance;
} _StopLines_default_instance_;
class CrossingsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Crossings>
      _instance;
} _Crossings_default_instance_;
class RoadInfoMsgDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RoadInfoMsg>
      _instance;
} _RoadInfoMsg_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace protobuf_road_5finfo_2eproto {
void InitDefaultsRoadInfoCurveLineImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector3d();
  {
    void* ptr = &::autodrive::workflow::proto::_RoadInfoCurveLine_default_instance_;
    new (ptr) ::autodrive::workflow::proto::RoadInfoCurveLine();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::RoadInfoCurveLine::InitAsDefaultInstance();
}

void InitDefaultsRoadInfoCurveLine() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsRoadInfoCurveLineImpl);
}

void InitDefaultsBorderImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoCurveLine();
  {
    void* ptr = &::autodrive::workflow::proto::_Border_default_instance_;
    new (ptr) ::autodrive::workflow::proto::Border();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::Border::InitAsDefaultInstance();
}

void InitDefaultsBorder() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsBorderImpl);
}

void InitDefaultsRoadBordersImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_road_5finfo_2eproto::InitDefaultsBorder();
  {
    void* ptr = &::autodrive::workflow::proto::_RoadBorders_default_instance_;
    new (ptr) ::autodrive::workflow::proto::RoadBorders();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::RoadBorders::InitAsDefaultInstance();
}

void InitDefaultsRoadBorders() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsRoadBordersImpl);
}

void InitDefaultsTransitionPointsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::autodrive::workflow::proto::_TransitionPoints_default_instance_;
    new (ptr) ::autodrive::workflow::proto::TransitionPoints();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::TransitionPoints::InitAsDefaultInstance();
}

void InitDefaultsTransitionPoints() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsTransitionPointsImpl);
}

void InitDefaultsRoadInfoLineImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoCurveLine();
  {
    void* ptr = &::autodrive::workflow::proto::_RoadInfoLine_default_instance_;
    new (ptr) ::autodrive::workflow::proto::RoadInfoLine();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::RoadInfoLine::InitAsDefaultInstance();
}

void InitDefaultsRoadInfoLine() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsRoadInfoLineImpl);
}

void InitDefaultsHighWayJunctionInfoImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::autodrive::workflow::proto::_HighWayJunctionInfo_default_instance_;
    new (ptr) ::autodrive::workflow::proto::HighWayJunctionInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::HighWayJunctionInfo::InitAsDefaultInstance();
}

void InitDefaultsHighWayJunctionInfo() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsHighWayJunctionInfoImpl);
}

void InitDefaultsNumberOfLanesImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::autodrive::workflow::proto::_NumberOfLanes_default_instance_;
    new (ptr) ::autodrive::workflow::proto::NumberOfLanes();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::NumberOfLanes::InitAsDefaultInstance();
}

void InitDefaultsNumberOfLanes() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsNumberOfLanesImpl);
}

void InitDefaultsRoadInfoLinesImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_perception_5fbase_2eproto::InitDefaultsCameraMatrix();
  protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoLine();
  protobuf_road_5finfo_2eproto::InitDefaultsTransitionPoints();
  protobuf_road_5finfo_2eproto::InitDefaultsHighWayJunctionInfo();
  protobuf_road_5finfo_2eproto::InitDefaultsNumberOfLanes();
  {
    void* ptr = &::autodrive::workflow::proto::_RoadInfoLines_default_instance_;
    new (ptr) ::autodrive::workflow::proto::RoadInfoLines();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::RoadInfoLines::InitAsDefaultInstance();
}

void InitDefaultsRoadInfoLines() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsRoadInfoLinesImpl);
}

void InitDefaultsStopLinesImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::autodrive::workflow::proto::_StopLines_default_instance_;
    new (ptr) ::autodrive::workflow::proto::StopLines();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::StopLines::InitAsDefaultInstance();
}

void InitDefaultsStopLines() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsStopLinesImpl);
}

void InitDefaultsCrossingsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::autodrive::workflow::proto::_Crossings_default_instance_;
    new (ptr) ::autodrive::workflow::proto::Crossings();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::Crossings::InitAsDefaultInstance();
}

void InitDefaultsCrossings() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsCrossingsImpl);
}

void InitDefaultsRoadInfoMsgImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_common_2eproto::InitDefaultsMsgHeader();
  protobuf_common_2eproto::InitDefaultsError();
  protobuf_road_5finfo_2eproto::InitDefaultsRoadBorders();
  protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoLines();
  protobuf_road_5finfo_2eproto::InitDefaultsStopLines();
  protobuf_road_5finfo_2eproto::InitDefaultsCrossings();
  {
    void* ptr = &::autodrive::workflow::proto::_RoadInfoMsg_default_instance_;
    new (ptr) ::autodrive::workflow::proto::RoadInfoMsg();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::RoadInfoMsg::InitAsDefaultInstance();
}

void InitDefaultsRoadInfoMsg() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsRoadInfoMsgImpl);
}

::google::protobuf::Metadata file_level_metadata[11];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[18];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, start_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, end_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, rmse_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, points_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, t_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, t_max_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, start_pt_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, x_coeff_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, y_coeff_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoCurveLine, length_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Border, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Border, border_side_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Border, border_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Border, conf_level_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Border, curve_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Border, conf_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Border, border_height_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadBorders, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadBorders, borders_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::TransitionPoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::TransitionPoints, long_position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::TransitionPoints, lat_position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::TransitionPoints, prob_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::TransitionPoints, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::TransitionPoints, relate_line_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, str_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, curve_segs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, life_time_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, start_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, end_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, conf_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, width_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, conf_level_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, line_color_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, dlm_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, decel_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, road_prediction_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, length_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLine, triggered_model_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::HighWayJunctionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::HighWayJunctionInfo, highway_exit_left_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::HighWayJunctionInfo, highway_exit_right_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::HighWayJunctionInfo, highway_entry_left_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::HighWayJunctionInfo, highway_entry_right_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::NumberOfLanes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::NumberOfLanes, range_0m_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::NumberOfLanes, range_35m_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, camera_matrix_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, lines_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, src_time_stamp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, asyn_time_stamp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, ambiguous_line_pattern_left_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, ambiguous_line_pattern_right_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, construction_area_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, lane_change_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, driving_side_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, transition_points_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, highway_junction_info_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, number_of_lanes_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoLines, host_width_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::StopLines, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::StopLines, lateral_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::StopLines, longitudinal_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::StopLines, angle_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::StopLines, confidence_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::StopLines, id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::StopLines, stop_line_status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::StopLines, stop_line_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::StopLines, stop_line_color_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::StopLines, is_relevant_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Crossings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Crossings, lateral_position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Crossings, longitudinal_position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Crossings, confidence_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Crossings, id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::Crossings, crossings_type_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoMsg, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoMsg, error_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoMsg, road_borders_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoMsg, lane_lines_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoMsg, stop_lines_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoMsg, crossings_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::RoadInfoMsg, camera_id_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::autodrive::workflow::proto::RoadInfoCurveLine)},
  { 16, -1, sizeof(::autodrive::workflow::proto::Border)},
  { 27, -1, sizeof(::autodrive::workflow::proto::RoadBorders)},
  { 33, -1, sizeof(::autodrive::workflow::proto::TransitionPoints)},
  { 43, -1, sizeof(::autodrive::workflow::proto::RoadInfoLine)},
  { 65, -1, sizeof(::autodrive::workflow::proto::HighWayJunctionInfo)},
  { 74, -1, sizeof(::autodrive::workflow::proto::NumberOfLanes)},
  { 81, -1, sizeof(::autodrive::workflow::proto::RoadInfoLines)},
  { 99, -1, sizeof(::autodrive::workflow::proto::StopLines)},
  { 113, -1, sizeof(::autodrive::workflow::proto::Crossings)},
  { 123, -1, sizeof(::autodrive::workflow::proto::RoadInfoMsg)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_RoadInfoCurveLine_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_Border_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_RoadBorders_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_TransitionPoints_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_RoadInfoLine_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_HighWayJunctionInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_NumberOfLanes_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_RoadInfoLines_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_StopLines_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_Crossings_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_RoadInfoMsg_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "road_info.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 11);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\017road_info.proto\022\030autodrive.workflow.pr"
      "oto\032\013basic.proto\032\014common.proto\032\025percepti"
      "on_base.proto\"\256\002\n\021RoadInfoCurveLine\022\r\n\005s"
      "tart\030\001 \001(\002\022\013\n\003end\030\002 \001(\002\022\014\n\004rmse\030\003 \001(\002\0229\n"
      "\004type\030\004 \001(\0162+.autodrive.workflow.proto.R"
      "oadInfoCurveType\0222\n\006points\030\005 \003(\0132\".autod"
      "rive.workflow.proto.Vector3d\022\t\n\001t\030\006 \003(\001\022"
      "\r\n\005t_max\030\007 \001(\001\0224\n\010start_pt\030\010 \001(\0132\".autod"
      "rive.workflow.proto.Vector3d\022\017\n\007x_coeff\030"
      "\t \003(\001\022\017\n\007y_coeff\030\n \003(\001\022\016\n\006length\030\013 \001(\002\"\251"
      "\002\n\006Border\022=\n\013border_side\030\001 \001(\0162(.autodri"
      "ve.workflow.proto.RoadBorderSide\022=\n\013bord"
      "er_type\030\002 \001(\0162(.autodrive.workflow.proto"
      ".RoadBorderType\022@\n\nconf_level\030\003 \001(\0162,.au"
      "todrive.workflow.proto.RoadInfoLineSourc"
      "e\022:\n\005curve\030\004 \001(\0132+.autodrive.workflow.pr"
      "oto.RoadInfoCurveLine\022\014\n\004conf\030\005 \001(\002\022\025\n\rb"
      "order_height\030\006 \001(\002\"@\n\013RoadBorders\0221\n\007bor"
      "ders\030\001 \003(\0132 .autodrive.workflow.proto.Bo"
      "rder\"\276\001\n\020TransitionPoints\022\025\n\rlong_positi"
      "on\030\001 \001(\002\022\024\n\014lat_position\030\002 \001(\002\022\014\n\004prob\030\003"
      " \001(\002\0226\n\004type\030\004 \001(\0162(.autodrive.workflow."
      "proto.TransitionType\0227\n\013relate_line\030\005 \001("
      "\0162\".autodrive.workflow.proto.LineRole\"\216\005"
      "\n\014RoadInfoLine\022\n\n\002id\030\001 \001(\005\022\016\n\006str_id\030\002 \001"
      "(\t\022\?\n\ncurve_segs\030\003 \003(\0132+.autodrive.workf"
      "low.proto.RoadInfoCurveLine\022\021\n\tlife_time"
      "\030\004 \001(\005\022\r\n\005start\030\005 \001(\002\022\013\n\003end\030\006 \001(\002\022\014\n\004co"
      "nf\030\007 \001(\002\022\r\n\005width\030\010 \001(\002\022@\n\010position\030\t \001("
      "\0162..autodrive.workflow.proto.RoadInfoLin"
      "ePosition\022@\n\nconf_level\030\n \001(\0162,.autodriv"
      "e.workflow.proto.RoadInfoLineSource\022\?\n\nl"
      "ine_color\030\013 \001(\0162+.autodrive.workflow.pro"
      "to.RoadInfoLineColor\0228\n\004type\030\014 \001(\0162*.aut"
      "odrive.workflow.proto.RoadInfoLineType\0223"
      "\n\010dlm_type\030\r \001(\0162!.autodrive.workflow.pr"
      "oto.DlmType\0227\n\ndecel_type\030\016 \001(\0162#.autodr"
      "ive.workflow.proto.DecelType\022\027\n\017road_pre"
      "diction\030\017 \001(\r\022\016\n\006length\030\020 \001(\002\022\?\n\017trigger"
      "ed_model\030\021 \001(\0162&.autodrive.workflow.prot"
      "o.TriggerModel\"\205\001\n\023HighWayJunctionInfo\022\031"
      "\n\021highway_exit_left\030\001 \001(\010\022\032\n\022highway_exi"
      "t_right\030\002 \001(\010\022\032\n\022highway_entry_left\030\003 \001("
      "\010\022\033\n\023highway_entry_right\030\004 \001(\010\"4\n\rNumber"
      "OfLanes\022\020\n\010range_0m\030\001 \001(\r\022\021\n\trange_35m\030\002"
      " \001(\r\"\341\005\n\rRoadInfoLines\022M\n\rcamera_matrix\030"
      "\001 \001(\01326.autodrive.workflow.proto.percept"
      "ion_base.CameraMatrix\0225\n\005lines\030\002 \003(\0132&.a"
      "utodrive.workflow.proto.RoadInfoLine\022\026\n\016"
      "src_time_stamp\030\003 \001(\003\022\027\n\017asyn_time_stamp\030"
      "\004 \001(\003\022#\n\033ambiguous_line_pattern_left\030\005 \001"
      "(\r\022$\n\034ambiguous_line_pattern_right\030\006 \001(\r"
      "\022\031\n\021construction_area\030\007 \001(\r\0229\n\013lane_chan"
      "ge\030\010 \001(\0162$.autodrive.workflow.proto.Lane"
      "Change\022I\n\014driving_side\030\t \001(\01623.autodrive"
      ".workflow.proto.RoadInfoLines.DrivingSid"
      "e\022E\n\021transition_points\030\n \003(\0132*.autodrive"
      ".workflow.proto.TransitionPoints\022L\n\025high"
      "way_junction_info\030\013 \001(\0132-.autodrive.work"
      "flow.proto.HighWayJunctionInfo\022@\n\017number"
      "_of_lanes\030\014 \001(\0132\'.autodrive.workflow.pro"
      "to.NumberOfLanes\022\022\n\nhost_width\030\r \001(\002\"B\n\013"
      "DrivingSide\022\030\n\024kDrivingSideLeftSide\020\000\022\031\n"
      "\025kDrivingSideRightSide\020\001\"\322\002\n\tStopLines\022\030"
      "\n\020lateral_distance\030\001 \001(\002\022\035\n\025longitudinal"
      "_distance\030\002 \001(\002\022\r\n\005angle\030\003 \001(\002\022\022\n\nconfid"
      "ence\030\004 \001(\002\022\n\n\002id\030\005 \001(\r\022B\n\020stop_line_stat"
      "us\030\006 \001(\0162(.autodrive.workflow.proto.Stop"
      "LineStatus\022>\n\016stop_line_type\030\007 \001(\0162&.aut"
      "odrive.workflow.proto.StopLineType\022D\n\017st"
      "op_line_color\030\010 \001(\0162+.autodrive.workflow"
      ".proto.StopLineColorType\022\023\n\013is_relevant\030"
      "\t \001(\010\"\245\001\n\tCrossings\022\030\n\020lateral_position\030"
      "\001 \001(\002\022\035\n\025longitudinal_position\030\002 \001(\002\022\022\n\n"
      "confidence\030\003 \001(\002\022\n\n\002id\030\004 \001(\r\022\?\n\016crossing"
      "s_type\030\005 \001(\0162\'.autodrive.workflow.proto."
      "CrossingsType\"\360\002\n\013RoadInfoMsg\0223\n\006header\030"
      "\001 \001(\0132#.autodrive.workflow.proto.MsgHead"
      "er\022.\n\005error\030\002 \001(\0132\037.autodrive.workflow.p"
      "roto.Error\022;\n\014road_borders\030\003 \001(\0132%.autod"
      "rive.workflow.proto.RoadBorders\022;\n\nlane_"
      "lines\030\004 \001(\0132\'.autodrive.workflow.proto.R"
      "oadInfoLines\0227\n\nstop_lines\030\005 \001(\0132#.autod"
      "rive.workflow.proto.StopLines\0226\n\tcrossin"
      "gs\030\006 \001(\0132#.autodrive.workflow.proto.Cros"
      "sings\022\021\n\tcamera_id\030\007 \001(\005*K\n\016RoadBorderSi"
      "de\022\033\n\027kRoadBorderSideLeftEdge\020\000\022\034\n\030kRoad"
      "BorderSideRightEdge\020\001*\353\001\n\016RoadBorderType"
      "\022\027\n\023kRoadBorderTypeCurb\020\000\022\033\n\027kRoadBorder"
      "TypeRoadEdge\020\001\022\032\n\026kRoadBorderTypeBarrier"
      "\020\002\022\027\n\023kRoadBorderTypeCone\020\003\022\035\n\031kRoadBord"
      "erTypeParkedCars\020\004\022\027\n\023kRoadBorderTypeWal"
      "l\020\005\022\034\n\030kRoadBorderTypeGuardRail\020\006\022\030\n\024kRo"
      "adBorderTypeOther\020\007*^\n\022RoadInfoLineSourc"
      "e\022\031\n\025kRoadConfNotAvailable\020\000\022\026\n\022kRoadCon"
      "fPredicted\020\001\022\025\n\021kRoadConfDetected\020\002*i\n\021R"
      "oadInfoCurveType\022\025\n\021kCurveTypeUnknown\020\000\022"
      "\022\n\016kCurveTypeAdas\020\002\022\023\n\017kCurveTypeCubic\020\004"
      "\022\024\n\020kCurveTypeBezier\020\010*\271\001\n\020RoadInfoLineT"
      "ype\022\026\n\022kLineTypeUndecided\020\000\022\026\n\022kLineType"
      "SolidLine\020\001\022\027\n\023kLineTypeDashedLine\020\002\022\027\n\023"
      "kLineTypeDoubleLine\020\003\022\035\n\031kLineTypeDecele"
      "rationLine\020\004\022\022\n\016kLineTypeBotts\020\005\022\020\n\014kLin"
      "eTypeHOV\020\006*\200\001\n\007DlmType\022\016\n\nkDlmNotDlm\020\000\022\023"
      "\n\017kDlmSolidDashed\020\001\022\023\n\017kDlmDashedSolid\020\002"
      "\022\022\n\016kDlmSolidSolid\020\003\022\024\n\020kDlmDashedDashed"
      "\020\004\022\021\n\rkDlmUndecided\020\005*j\n\tDecelType\022\022\n\016kD"
      "ecelNotDecel\020\000\022\017\n\013kDecelSolid\020\001\022\020\n\014kDece"
      "lDashed\020\002\022\023\n\017kDecelUndecided\020\003\022\021\n\rkDecel"
      "Invalid\020\004*~\n\021RoadInfoLineColor\022\025\n\021kLineC"
      "olorUnknown\020\000\022\023\n\017kLineColorWhite\020\001\022\024\n\020kL"
      "ineColorYellow\020\002\022\022\n\016kLineColorBlue\020\003\022\023\n\017"
      "kLineColorGreen\020\004*\315\002\n\024RoadInfoLinePositi"
      "on\022\030\n\024kLinePositionUnknown\020\000\022\025\n\021kLinePos"
      "itionLeft\020\001\022\026\n\022kLinePositionRight\020\002\022\031\n\025k"
      "LinePositionLeftLeft\020\003\022\033\n\027kLinePositionR"
      "ightRight\020\004\022\034\n\030kLinePositionLeftOutside\020"
      "\005\022\035\n\031kLinePositionRightOutside\020\006\022\032\n\026kLin"
      "ePositionLeftRight\020\007\022\032\n\026kLinePositionRig"
      "htLeft\020\010\022\035\n\031kLinePositionLeftLeftLeft\020\t\022"
      " \n\034kLinePositionRightRightRight\020\n*]\n\016Tra"
      "nsitionType\022\030\n\024kTransitionTypeSplit\020\000\022\030\n"
      "\024kTransitionTypeMerge\020\001\022\027\n\023kTransitionTy"
      "peExit\020\002*f\n\016StopLineStatus\022\032\n\026kStopLineS"
      "tatusUnknown\020\000\022\032\n\026kStopLineStatusInImage"
      "\020\001\022\034\n\030kStopLineStatusPredicted\020\002*\203\002\n\014Sto"
      "pLineType\022\031\n\025kStopLineTypeStopLine\020\000\022\037\n\033"
      "kStopLineTypeDashedStopLine\020\001\022\037\n\033kStopLi"
      "neTypeDoubleStopLine\020\002\022$\n kStopLineTypeD"
      "ashedSolidStopLine\020\003\022$\n kStopLineTypeSol"
      "idDashedStopLine\020\004\022%\n!kStopLineTypeDoubl"
      "eDashedStopLine\020\005\022#\n\037kStopLineTypeTriang"
      "ularStopLine\020\006*x\n\021StopLineColorType\022\037\n\033k"
      "StopLineColorTypeGreenBlue\020\000\022\033\n\027kStopLin"
      "eColorTypeWhite\020\001\022%\n!kStopLineColorTypeY"
      "ellowOrangeRed\020\002*X\n\rCrossingsType\022\026\n\022kRo"
      "adSolidCrossing\020\000\022\026\n\022kRoadZebraCrossing\020"
      "\001\022\027\n\023kRoadDashedCrossing\020\002*n\n\nLaneChange"
      "\022\027\n\023kLaneChangeNoChange\020\000\022\025\n\021kLaneChange"
      "ToLeft\020\001\022\026\n\022kLaneChangeToRight\020\002\022\030\n\024kLan"
      "eChangeToUnknown\020\003*\246\001\n\010LineRole\022\024\n\020kLine"
      "RoleUnknown\020\000\022\021\n\rkLineRoleLeft\020\001\022\022\n\016kLin"
      "eRoleRight\020\002\022\025\n\021kLineRoleLeftLeft\020\003\022\027\n\023k"
      "LineRoleRightRight\020\004\022\025\n\021kLineRoleLeftEdg"
      "e\020\005\022\026\n\022kLineRoleRightEdge\020\006*h\n\014TriggerMo"
      "del\022\035\n\031kTriggerModelNotAvailable\020\000\022\032\n\026kT"
      "riggerModelTriggered\020\001\022\035\n\031kTriggerModelN"
      "otTriggered\020\002b\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 5901);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "road_info.proto", &protobuf_RegisterTypes);
  ::protobuf_basic_2eproto::AddDescriptors();
  ::protobuf_common_2eproto::AddDescriptors();
  ::protobuf_perception_5fbase_2eproto::AddDescriptors();
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_road_5finfo_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
const ::google::protobuf::EnumDescriptor* RoadInfoLines_DrivingSide_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[0];
}
bool RoadInfoLines_DrivingSide_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RoadInfoLines_DrivingSide RoadInfoLines::kDrivingSideLeftSide;
const RoadInfoLines_DrivingSide RoadInfoLines::kDrivingSideRightSide;
const RoadInfoLines_DrivingSide RoadInfoLines::DrivingSide_MIN;
const RoadInfoLines_DrivingSide RoadInfoLines::DrivingSide_MAX;
const int RoadInfoLines::DrivingSide_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* RoadBorderSide_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[1];
}
bool RoadBorderSide_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoadBorderType_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[2];
}
bool RoadBorderType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoadInfoLineSource_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[3];
}
bool RoadInfoLineSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoadInfoCurveType_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[4];
}
bool RoadInfoCurveType_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 4:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoadInfoLineType_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[5];
}
bool RoadInfoLineType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* DlmType_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[6];
}
bool DlmType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* DecelType_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[7];
}
bool DecelType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoadInfoLineColor_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[8];
}
bool RoadInfoLineColor_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoadInfoLinePosition_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[9];
}
bool RoadInfoLinePosition_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TransitionType_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[10];
}
bool TransitionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StopLineStatus_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[11];
}
bool StopLineStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StopLineType_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[12];
}
bool StopLineType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StopLineColorType_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[13];
}
bool StopLineColorType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CrossingsType_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[14];
}
bool CrossingsType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LaneChange_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[15];
}
bool LaneChange_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LineRole_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[16];
}
bool LineRole_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TriggerModel_descriptor() {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_road_5finfo_2eproto::file_level_enum_descriptors[17];
}
bool TriggerModel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void RoadInfoCurveLine::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_RoadInfoCurveLine_default_instance_._instance.get_mutable()->start_pt_ = const_cast< ::autodrive::workflow::proto::Vector3d*>(
      ::autodrive::workflow::proto::Vector3d::internal_default_instance());
}
void RoadInfoCurveLine::clear_points() {
  points_.Clear();
}
void RoadInfoCurveLine::clear_start_pt() {
  if (GetArenaNoVirtual() == NULL && start_pt_ != NULL) {
    delete start_pt_;
  }
  start_pt_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RoadInfoCurveLine::kStartFieldNumber;
const int RoadInfoCurveLine::kEndFieldNumber;
const int RoadInfoCurveLine::kRmseFieldNumber;
const int RoadInfoCurveLine::kTypeFieldNumber;
const int RoadInfoCurveLine::kPointsFieldNumber;
const int RoadInfoCurveLine::kTFieldNumber;
const int RoadInfoCurveLine::kTMaxFieldNumber;
const int RoadInfoCurveLine::kStartPtFieldNumber;
const int RoadInfoCurveLine::kXCoeffFieldNumber;
const int RoadInfoCurveLine::kYCoeffFieldNumber;
const int RoadInfoCurveLine::kLengthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RoadInfoCurveLine::RoadInfoCurveLine()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoCurveLine();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.RoadInfoCurveLine)
}
RoadInfoCurveLine::RoadInfoCurveLine(const RoadInfoCurveLine& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      points_(from.points_),
      t_(from.t_),
      x_coeff_(from.x_coeff_),
      y_coeff_(from.y_coeff_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_start_pt()) {
    start_pt_ = new ::autodrive::workflow::proto::Vector3d(*from.start_pt_);
  } else {
    start_pt_ = NULL;
  }
  ::memcpy(&start_, &from.start_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&start_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.RoadInfoCurveLine)
}

void RoadInfoCurveLine::SharedCtor() {
  ::memset(&start_pt_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&length_) -
      reinterpret_cast<char*>(&start_pt_)) + sizeof(length_));
  _cached_size_ = 0;
}

RoadInfoCurveLine::~RoadInfoCurveLine() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.RoadInfoCurveLine)
  SharedDtor();
}

void RoadInfoCurveLine::SharedDtor() {
  if (this != internal_default_instance()) delete start_pt_;
}

void RoadInfoCurveLine::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoadInfoCurveLine::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RoadInfoCurveLine& RoadInfoCurveLine::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoCurveLine();
  return *internal_default_instance();
}

RoadInfoCurveLine* RoadInfoCurveLine::New(::google::protobuf::Arena* arena) const {
  RoadInfoCurveLine* n = new RoadInfoCurveLine;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RoadInfoCurveLine::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.RoadInfoCurveLine)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points_.Clear();
  t_.Clear();
  x_coeff_.Clear();
  y_coeff_.Clear();
  if (GetArenaNoVirtual() == NULL && start_pt_ != NULL) {
    delete start_pt_;
  }
  start_pt_ = NULL;
  ::memset(&start_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&length_) -
      reinterpret_cast<char*>(&start_)) + sizeof(length_));
  _internal_metadata_.Clear();
}

bool RoadInfoCurveLine::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.RoadInfoCurveLine)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float start = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u /* 13 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float end = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u /* 21 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &end_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float rmse = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u /* 29 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rmse_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadInfoCurveType type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::autodrive::workflow::proto::RoadInfoCurveType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.Vector3d points = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_points()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double t = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_t())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(49u /* 49 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 50u, input, this->mutable_t())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double t_max = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(57u /* 57 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &t_max_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Vector3d start_pt = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_start_pt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double x_coeff = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_x_coeff())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(73u /* 73 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 74u, input, this->mutable_x_coeff())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated double y_coeff = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u /* 82 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_y_coeff())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(81u /* 81 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 82u, input, this->mutable_y_coeff())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float length = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(93u /* 93 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.RoadInfoCurveLine)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.RoadInfoCurveLine)
  return false;
#undef DO_
}

void RoadInfoCurveLine::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.RoadInfoCurveLine)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float start = 1;
  if (this->start() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->start(), output);
  }

  // float end = 2;
  if (this->end() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->end(), output);
  }

  // float rmse = 3;
  if (this->rmse() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->rmse(), output);
  }

  // .autodrive.workflow.proto.RoadInfoCurveType type = 4;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // repeated .autodrive.workflow.proto.Vector3d points = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->points(static_cast<int>(i)), output);
  }

  // repeated double t = 6;
  if (this->t_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(6, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(static_cast< ::google::protobuf::uint32>(
        _t_cached_byte_size_));
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->t().data(), this->t_size(), output);
  }

  // double t_max = 7;
  if (this->t_max() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->t_max(), output);
  }

  // .autodrive.workflow.proto.Vector3d start_pt = 8;
  if (this->has_start_pt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->start_pt_, output);
  }

  // repeated double x_coeff = 9;
  if (this->x_coeff_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(9, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(static_cast< ::google::protobuf::uint32>(
        _x_coeff_cached_byte_size_));
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->x_coeff().data(), this->x_coeff_size(), output);
  }

  // repeated double y_coeff = 10;
  if (this->y_coeff_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(10, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(static_cast< ::google::protobuf::uint32>(
        _y_coeff_cached_byte_size_));
    ::google::protobuf::internal::WireFormatLite::WriteDoubleArray(
      this->y_coeff().data(), this->y_coeff_size(), output);
  }

  // float length = 11;
  if (this->length() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->length(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.RoadInfoCurveLine)
}

::google::protobuf::uint8* RoadInfoCurveLine::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.RoadInfoCurveLine)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float start = 1;
  if (this->start() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->start(), target);
  }

  // float end = 2;
  if (this->end() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->end(), target);
  }

  // float rmse = 3;
  if (this->rmse() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->rmse(), target);
  }

  // .autodrive.workflow.proto.RoadInfoCurveType type = 4;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->type(), target);
  }

  // repeated .autodrive.workflow.proto.Vector3d points = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->points(static_cast<int>(i)), deterministic, target);
  }

  // repeated double t = 6;
  if (this->t_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      6,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
        static_cast< ::google::protobuf::int32>(
            _t_cached_byte_size_), target);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleNoTagToArray(this->t_, target);
  }

  // double t_max = 7;
  if (this->t_max() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->t_max(), target);
  }

  // .autodrive.workflow.proto.Vector3d start_pt = 8;
  if (this->has_start_pt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, *this->start_pt_, deterministic, target);
  }

  // repeated double x_coeff = 9;
  if (this->x_coeff_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      9,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
        static_cast< ::google::protobuf::int32>(
            _x_coeff_cached_byte_size_), target);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleNoTagToArray(this->x_coeff_, target);
  }

  // repeated double y_coeff = 10;
  if (this->y_coeff_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      10,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
        static_cast< ::google::protobuf::int32>(
            _y_coeff_cached_byte_size_), target);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleNoTagToArray(this->y_coeff_, target);
  }

  // float length = 11;
  if (this->length() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->length(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.RoadInfoCurveLine)
  return target;
}

size_t RoadInfoCurveLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.RoadInfoCurveLine)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.Vector3d points = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->points_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->points(static_cast<int>(i)));
    }
  }

  // repeated double t = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->t_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast< ::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _t_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated double x_coeff = 9;
  {
    unsigned int count = static_cast<unsigned int>(this->x_coeff_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast< ::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _x_coeff_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated double y_coeff = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->y_coeff_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast< ::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _y_coeff_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // .autodrive.workflow.proto.Vector3d start_pt = 8;
  if (this->has_start_pt()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->start_pt_);
  }

  // float start = 1;
  if (this->start() != 0) {
    total_size += 1 + 4;
  }

  // float end = 2;
  if (this->end() != 0) {
    total_size += 1 + 4;
  }

  // float rmse = 3;
  if (this->rmse() != 0) {
    total_size += 1 + 4;
  }

  // .autodrive.workflow.proto.RoadInfoCurveType type = 4;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // double t_max = 7;
  if (this->t_max() != 0) {
    total_size += 1 + 8;
  }

  // float length = 11;
  if (this->length() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadInfoCurveLine::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.RoadInfoCurveLine)
  GOOGLE_DCHECK_NE(&from, this);
  const RoadInfoCurveLine* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RoadInfoCurveLine>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.RoadInfoCurveLine)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.RoadInfoCurveLine)
    MergeFrom(*source);
  }
}

void RoadInfoCurveLine::MergeFrom(const RoadInfoCurveLine& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.RoadInfoCurveLine)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  points_.MergeFrom(from.points_);
  t_.MergeFrom(from.t_);
  x_coeff_.MergeFrom(from.x_coeff_);
  y_coeff_.MergeFrom(from.y_coeff_);
  if (from.has_start_pt()) {
    mutable_start_pt()->::autodrive::workflow::proto::Vector3d::MergeFrom(from.start_pt());
  }
  if (from.start() != 0) {
    set_start(from.start());
  }
  if (from.end() != 0) {
    set_end(from.end());
  }
  if (from.rmse() != 0) {
    set_rmse(from.rmse());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.t_max() != 0) {
    set_t_max(from.t_max());
  }
  if (from.length() != 0) {
    set_length(from.length());
  }
}

void RoadInfoCurveLine::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.RoadInfoCurveLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoadInfoCurveLine::CopyFrom(const RoadInfoCurveLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.RoadInfoCurveLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadInfoCurveLine::IsInitialized() const {
  return true;
}

void RoadInfoCurveLine::Swap(RoadInfoCurveLine* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RoadInfoCurveLine::InternalSwap(RoadInfoCurveLine* other) {
  using std::swap;
  points_.InternalSwap(&other->points_);
  t_.InternalSwap(&other->t_);
  x_coeff_.InternalSwap(&other->x_coeff_);
  y_coeff_.InternalSwap(&other->y_coeff_);
  swap(start_pt_, other->start_pt_);
  swap(start_, other->start_);
  swap(end_, other->end_);
  swap(rmse_, other->rmse_);
  swap(type_, other->type_);
  swap(t_max_, other->t_max_);
  swap(length_, other->length_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RoadInfoCurveLine::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Border::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_Border_default_instance_._instance.get_mutable()->curve_ = const_cast< ::autodrive::workflow::proto::RoadInfoCurveLine*>(
      ::autodrive::workflow::proto::RoadInfoCurveLine::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Border::kBorderSideFieldNumber;
const int Border::kBorderTypeFieldNumber;
const int Border::kConfLevelFieldNumber;
const int Border::kCurveFieldNumber;
const int Border::kConfFieldNumber;
const int Border::kBorderHeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Border::Border()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsBorder();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.Border)
}
Border::Border(const Border& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_curve()) {
    curve_ = new ::autodrive::workflow::proto::RoadInfoCurveLine(*from.curve_);
  } else {
    curve_ = NULL;
  }
  ::memcpy(&border_side_, &from.border_side_,
    static_cast<size_t>(reinterpret_cast<char*>(&border_height_) -
    reinterpret_cast<char*>(&border_side_)) + sizeof(border_height_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.Border)
}

void Border::SharedCtor() {
  ::memset(&curve_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&border_height_) -
      reinterpret_cast<char*>(&curve_)) + sizeof(border_height_));
  _cached_size_ = 0;
}

Border::~Border() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.Border)
  SharedDtor();
}

void Border::SharedDtor() {
  if (this != internal_default_instance()) delete curve_;
}

void Border::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Border::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Border& Border::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsBorder();
  return *internal_default_instance();
}

Border* Border::New(::google::protobuf::Arena* arena) const {
  Border* n = new Border;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Border::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.Border)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && curve_ != NULL) {
    delete curve_;
  }
  curve_ = NULL;
  ::memset(&border_side_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&border_height_) -
      reinterpret_cast<char*>(&border_side_)) + sizeof(border_height_));
  _internal_metadata_.Clear();
}

bool Border::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.Border)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.RoadBorderSide border_side = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_border_side(static_cast< ::autodrive::workflow::proto::RoadBorderSide >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadBorderType border_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_border_type(static_cast< ::autodrive::workflow::proto::RoadBorderType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadInfoLineSource conf_level = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_conf_level(static_cast< ::autodrive::workflow::proto::RoadInfoLineSource >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadInfoCurveLine curve = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_curve()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float conf = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(45u /* 45 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &conf_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float border_height = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(53u /* 53 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &border_height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.Border)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.Border)
  return false;
#undef DO_
}

void Border::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.Border)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.RoadBorderSide border_side = 1;
  if (this->border_side() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->border_side(), output);
  }

  // .autodrive.workflow.proto.RoadBorderType border_type = 2;
  if (this->border_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->border_type(), output);
  }

  // .autodrive.workflow.proto.RoadInfoLineSource conf_level = 3;
  if (this->conf_level() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->conf_level(), output);
  }

  // .autodrive.workflow.proto.RoadInfoCurveLine curve = 4;
  if (this->has_curve()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->curve_, output);
  }

  // float conf = 5;
  if (this->conf() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->conf(), output);
  }

  // float border_height = 6;
  if (this->border_height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->border_height(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.Border)
}

::google::protobuf::uint8* Border::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.Border)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.RoadBorderSide border_side = 1;
  if (this->border_side() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->border_side(), target);
  }

  // .autodrive.workflow.proto.RoadBorderType border_type = 2;
  if (this->border_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->border_type(), target);
  }

  // .autodrive.workflow.proto.RoadInfoLineSource conf_level = 3;
  if (this->conf_level() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->conf_level(), target);
  }

  // .autodrive.workflow.proto.RoadInfoCurveLine curve = 4;
  if (this->has_curve()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, *this->curve_, deterministic, target);
  }

  // float conf = 5;
  if (this->conf() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->conf(), target);
  }

  // float border_height = 6;
  if (this->border_height() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->border_height(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.Border)
  return target;
}

size_t Border::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.Border)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .autodrive.workflow.proto.RoadInfoCurveLine curve = 4;
  if (this->has_curve()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->curve_);
  }

  // .autodrive.workflow.proto.RoadBorderSide border_side = 1;
  if (this->border_side() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->border_side());
  }

  // .autodrive.workflow.proto.RoadBorderType border_type = 2;
  if (this->border_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->border_type());
  }

  // .autodrive.workflow.proto.RoadInfoLineSource conf_level = 3;
  if (this->conf_level() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->conf_level());
  }

  // float conf = 5;
  if (this->conf() != 0) {
    total_size += 1 + 4;
  }

  // float border_height = 6;
  if (this->border_height() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Border::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.Border)
  GOOGLE_DCHECK_NE(&from, this);
  const Border* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Border>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.Border)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.Border)
    MergeFrom(*source);
  }
}

void Border::MergeFrom(const Border& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.Border)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_curve()) {
    mutable_curve()->::autodrive::workflow::proto::RoadInfoCurveLine::MergeFrom(from.curve());
  }
  if (from.border_side() != 0) {
    set_border_side(from.border_side());
  }
  if (from.border_type() != 0) {
    set_border_type(from.border_type());
  }
  if (from.conf_level() != 0) {
    set_conf_level(from.conf_level());
  }
  if (from.conf() != 0) {
    set_conf(from.conf());
  }
  if (from.border_height() != 0) {
    set_border_height(from.border_height());
  }
}

void Border::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.Border)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Border::CopyFrom(const Border& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.Border)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Border::IsInitialized() const {
  return true;
}

void Border::Swap(Border* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Border::InternalSwap(Border* other) {
  using std::swap;
  swap(curve_, other->curve_);
  swap(border_side_, other->border_side_);
  swap(border_type_, other->border_type_);
  swap(conf_level_, other->conf_level_);
  swap(conf_, other->conf_);
  swap(border_height_, other->border_height_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Border::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void RoadBorders::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RoadBorders::kBordersFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RoadBorders::RoadBorders()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsRoadBorders();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.RoadBorders)
}
RoadBorders::RoadBorders(const RoadBorders& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      borders_(from.borders_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.RoadBorders)
}

void RoadBorders::SharedCtor() {
  _cached_size_ = 0;
}

RoadBorders::~RoadBorders() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.RoadBorders)
  SharedDtor();
}

void RoadBorders::SharedDtor() {
}

void RoadBorders::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoadBorders::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RoadBorders& RoadBorders::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsRoadBorders();
  return *internal_default_instance();
}

RoadBorders* RoadBorders::New(::google::protobuf::Arena* arena) const {
  RoadBorders* n = new RoadBorders;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RoadBorders::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.RoadBorders)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  borders_.Clear();
  _internal_metadata_.Clear();
}

bool RoadBorders::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.RoadBorders)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .autodrive.workflow.proto.Border borders = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_borders()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.RoadBorders)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.RoadBorders)
  return false;
#undef DO_
}

void RoadBorders::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.RoadBorders)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.Border borders = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->borders_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->borders(static_cast<int>(i)), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.RoadBorders)
}

::google::protobuf::uint8* RoadBorders::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.RoadBorders)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.Border borders = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->borders_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->borders(static_cast<int>(i)), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.RoadBorders)
  return target;
}

size_t RoadBorders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.RoadBorders)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.Border borders = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->borders_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->borders(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadBorders::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.RoadBorders)
  GOOGLE_DCHECK_NE(&from, this);
  const RoadBorders* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RoadBorders>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.RoadBorders)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.RoadBorders)
    MergeFrom(*source);
  }
}

void RoadBorders::MergeFrom(const RoadBorders& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.RoadBorders)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  borders_.MergeFrom(from.borders_);
}

void RoadBorders::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.RoadBorders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoadBorders::CopyFrom(const RoadBorders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.RoadBorders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadBorders::IsInitialized() const {
  return true;
}

void RoadBorders::Swap(RoadBorders* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RoadBorders::InternalSwap(RoadBorders* other) {
  using std::swap;
  borders_.InternalSwap(&other->borders_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RoadBorders::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TransitionPoints::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TransitionPoints::kLongPositionFieldNumber;
const int TransitionPoints::kLatPositionFieldNumber;
const int TransitionPoints::kProbFieldNumber;
const int TransitionPoints::kTypeFieldNumber;
const int TransitionPoints::kRelateLineFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TransitionPoints::TransitionPoints()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsTransitionPoints();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.TransitionPoints)
}
TransitionPoints::TransitionPoints(const TransitionPoints& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&long_position_, &from.long_position_,
    static_cast<size_t>(reinterpret_cast<char*>(&relate_line_) -
    reinterpret_cast<char*>(&long_position_)) + sizeof(relate_line_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.TransitionPoints)
}

void TransitionPoints::SharedCtor() {
  ::memset(&long_position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&relate_line_) -
      reinterpret_cast<char*>(&long_position_)) + sizeof(relate_line_));
  _cached_size_ = 0;
}

TransitionPoints::~TransitionPoints() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.TransitionPoints)
  SharedDtor();
}

void TransitionPoints::SharedDtor() {
}

void TransitionPoints::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransitionPoints::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TransitionPoints& TransitionPoints::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsTransitionPoints();
  return *internal_default_instance();
}

TransitionPoints* TransitionPoints::New(::google::protobuf::Arena* arena) const {
  TransitionPoints* n = new TransitionPoints;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransitionPoints::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.TransitionPoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&long_position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&relate_line_) -
      reinterpret_cast<char*>(&long_position_)) + sizeof(relate_line_));
  _internal_metadata_.Clear();
}

bool TransitionPoints::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.TransitionPoints)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float long_position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u /* 13 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &long_position_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float lat_position = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u /* 21 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lat_position_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float prob = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u /* 29 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &prob_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.TransitionType type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::autodrive::workflow::proto::TransitionType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.LineRole relate_line = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_relate_line(static_cast< ::autodrive::workflow::proto::LineRole >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.TransitionPoints)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.TransitionPoints)
  return false;
#undef DO_
}

void TransitionPoints::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.TransitionPoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float long_position = 1;
  if (this->long_position() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->long_position(), output);
  }

  // float lat_position = 2;
  if (this->lat_position() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->lat_position(), output);
  }

  // float prob = 3;
  if (this->prob() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->prob(), output);
  }

  // .autodrive.workflow.proto.TransitionType type = 4;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // .autodrive.workflow.proto.LineRole relate_line = 5;
  if (this->relate_line() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->relate_line(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.TransitionPoints)
}

::google::protobuf::uint8* TransitionPoints::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.TransitionPoints)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float long_position = 1;
  if (this->long_position() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->long_position(), target);
  }

  // float lat_position = 2;
  if (this->lat_position() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->lat_position(), target);
  }

  // float prob = 3;
  if (this->prob() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->prob(), target);
  }

  // .autodrive.workflow.proto.TransitionType type = 4;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->type(), target);
  }

  // .autodrive.workflow.proto.LineRole relate_line = 5;
  if (this->relate_line() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->relate_line(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.TransitionPoints)
  return target;
}

size_t TransitionPoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.TransitionPoints)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // float long_position = 1;
  if (this->long_position() != 0) {
    total_size += 1 + 4;
  }

  // float lat_position = 2;
  if (this->lat_position() != 0) {
    total_size += 1 + 4;
  }

  // float prob = 3;
  if (this->prob() != 0) {
    total_size += 1 + 4;
  }

  // .autodrive.workflow.proto.TransitionType type = 4;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // .autodrive.workflow.proto.LineRole relate_line = 5;
  if (this->relate_line() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->relate_line());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransitionPoints::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.TransitionPoints)
  GOOGLE_DCHECK_NE(&from, this);
  const TransitionPoints* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TransitionPoints>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.TransitionPoints)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.TransitionPoints)
    MergeFrom(*source);
  }
}

void TransitionPoints::MergeFrom(const TransitionPoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.TransitionPoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.long_position() != 0) {
    set_long_position(from.long_position());
  }
  if (from.lat_position() != 0) {
    set_lat_position(from.lat_position());
  }
  if (from.prob() != 0) {
    set_prob(from.prob());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.relate_line() != 0) {
    set_relate_line(from.relate_line());
  }
}

void TransitionPoints::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.TransitionPoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransitionPoints::CopyFrom(const TransitionPoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.TransitionPoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransitionPoints::IsInitialized() const {
  return true;
}

void TransitionPoints::Swap(TransitionPoints* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransitionPoints::InternalSwap(TransitionPoints* other) {
  using std::swap;
  swap(long_position_, other->long_position_);
  swap(lat_position_, other->lat_position_);
  swap(prob_, other->prob_);
  swap(type_, other->type_);
  swap(relate_line_, other->relate_line_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TransitionPoints::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void RoadInfoLine::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RoadInfoLine::kIdFieldNumber;
const int RoadInfoLine::kStrIdFieldNumber;
const int RoadInfoLine::kCurveSegsFieldNumber;
const int RoadInfoLine::kLifeTimeFieldNumber;
const int RoadInfoLine::kStartFieldNumber;
const int RoadInfoLine::kEndFieldNumber;
const int RoadInfoLine::kConfFieldNumber;
const int RoadInfoLine::kWidthFieldNumber;
const int RoadInfoLine::kPositionFieldNumber;
const int RoadInfoLine::kConfLevelFieldNumber;
const int RoadInfoLine::kLineColorFieldNumber;
const int RoadInfoLine::kTypeFieldNumber;
const int RoadInfoLine::kDlmTypeFieldNumber;
const int RoadInfoLine::kDecelTypeFieldNumber;
const int RoadInfoLine::kRoadPredictionFieldNumber;
const int RoadInfoLine::kLengthFieldNumber;
const int RoadInfoLine::kTriggeredModelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RoadInfoLine::RoadInfoLine()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoLine();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.RoadInfoLine)
}
RoadInfoLine::RoadInfoLine(const RoadInfoLine& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      curve_segs_(from.curve_segs_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  str_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.str_id().size() > 0) {
    str_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.str_id_);
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&triggered_model_) -
    reinterpret_cast<char*>(&id_)) + sizeof(triggered_model_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.RoadInfoLine)
}

void RoadInfoLine::SharedCtor() {
  str_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&triggered_model_) -
      reinterpret_cast<char*>(&id_)) + sizeof(triggered_model_));
  _cached_size_ = 0;
}

RoadInfoLine::~RoadInfoLine() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.RoadInfoLine)
  SharedDtor();
}

void RoadInfoLine::SharedDtor() {
  str_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void RoadInfoLine::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoadInfoLine::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RoadInfoLine& RoadInfoLine::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoLine();
  return *internal_default_instance();
}

RoadInfoLine* RoadInfoLine::New(::google::protobuf::Arena* arena) const {
  RoadInfoLine* n = new RoadInfoLine;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RoadInfoLine::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.RoadInfoLine)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  curve_segs_.Clear();
  str_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&triggered_model_) -
      reinterpret_cast<char*>(&id_)) + sizeof(triggered_model_));
  _internal_metadata_.Clear();
}

bool RoadInfoLine::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.RoadInfoLine)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string str_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_str_id()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->str_id().data(), static_cast<int>(this->str_id().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "autodrive.workflow.proto.RoadInfoLine.str_id"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.RoadInfoCurveLine curve_segs = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_curve_segs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 life_time = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &life_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float start = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(45u /* 45 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &start_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float end = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(53u /* 53 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &end_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float conf = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(61u /* 61 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &conf_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float width = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(69u /* 69 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadInfoLinePosition position = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_position(static_cast< ::autodrive::workflow::proto::RoadInfoLinePosition >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadInfoLineSource conf_level = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_conf_level(static_cast< ::autodrive::workflow::proto::RoadInfoLineSource >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadInfoLineColor line_color = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_line_color(static_cast< ::autodrive::workflow::proto::RoadInfoLineColor >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadInfoLineType type = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u /* 96 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::autodrive::workflow::proto::RoadInfoLineType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.DlmType dlm_type = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u /* 104 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_dlm_type(static_cast< ::autodrive::workflow::proto::DlmType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.DecelType decel_type = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(112u /* 112 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_decel_type(static_cast< ::autodrive::workflow::proto::DecelType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 road_prediction = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(120u /* 120 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &road_prediction_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float length = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(133u /* 133 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.TriggerModel triggered_model = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(136u /* 136 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_triggered_model(static_cast< ::autodrive::workflow::proto::TriggerModel >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.RoadInfoLine)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.RoadInfoLine)
  return false;
#undef DO_
}

void RoadInfoLine::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.RoadInfoLine)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // string str_id = 2;
  if (this->str_id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->str_id().data(), static_cast<int>(this->str_id().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "autodrive.workflow.proto.RoadInfoLine.str_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->str_id(), output);
  }

  // repeated .autodrive.workflow.proto.RoadInfoCurveLine curve_segs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->curve_segs_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->curve_segs(static_cast<int>(i)), output);
  }

  // int32 life_time = 4;
  if (this->life_time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->life_time(), output);
  }

  // float start = 5;
  if (this->start() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->start(), output);
  }

  // float end = 6;
  if (this->end() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->end(), output);
  }

  // float conf = 7;
  if (this->conf() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->conf(), output);
  }

  // float width = 8;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->width(), output);
  }

  // .autodrive.workflow.proto.RoadInfoLinePosition position = 9;
  if (this->position() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->position(), output);
  }

  // .autodrive.workflow.proto.RoadInfoLineSource conf_level = 10;
  if (this->conf_level() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->conf_level(), output);
  }

  // .autodrive.workflow.proto.RoadInfoLineColor line_color = 11;
  if (this->line_color() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->line_color(), output);
  }

  // .autodrive.workflow.proto.RoadInfoLineType type = 12;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      12, this->type(), output);
  }

  // .autodrive.workflow.proto.DlmType dlm_type = 13;
  if (this->dlm_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      13, this->dlm_type(), output);
  }

  // .autodrive.workflow.proto.DecelType decel_type = 14;
  if (this->decel_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      14, this->decel_type(), output);
  }

  // uint32 road_prediction = 15;
  if (this->road_prediction() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->road_prediction(), output);
  }

  // float length = 16;
  if (this->length() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(16, this->length(), output);
  }

  // .autodrive.workflow.proto.TriggerModel triggered_model = 17;
  if (this->triggered_model() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      17, this->triggered_model(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.RoadInfoLine)
}

::google::protobuf::uint8* RoadInfoLine::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.RoadInfoLine)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // string str_id = 2;
  if (this->str_id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->str_id().data(), static_cast<int>(this->str_id().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "autodrive.workflow.proto.RoadInfoLine.str_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->str_id(), target);
  }

  // repeated .autodrive.workflow.proto.RoadInfoCurveLine curve_segs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->curve_segs_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->curve_segs(static_cast<int>(i)), deterministic, target);
  }

  // int32 life_time = 4;
  if (this->life_time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->life_time(), target);
  }

  // float start = 5;
  if (this->start() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->start(), target);
  }

  // float end = 6;
  if (this->end() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->end(), target);
  }

  // float conf = 7;
  if (this->conf() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->conf(), target);
  }

  // float width = 8;
  if (this->width() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->width(), target);
  }

  // .autodrive.workflow.proto.RoadInfoLinePosition position = 9;
  if (this->position() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->position(), target);
  }

  // .autodrive.workflow.proto.RoadInfoLineSource conf_level = 10;
  if (this->conf_level() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->conf_level(), target);
  }

  // .autodrive.workflow.proto.RoadInfoLineColor line_color = 11;
  if (this->line_color() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      11, this->line_color(), target);
  }

  // .autodrive.workflow.proto.RoadInfoLineType type = 12;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      12, this->type(), target);
  }

  // .autodrive.workflow.proto.DlmType dlm_type = 13;
  if (this->dlm_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      13, this->dlm_type(), target);
  }

  // .autodrive.workflow.proto.DecelType decel_type = 14;
  if (this->decel_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      14, this->decel_type(), target);
  }

  // uint32 road_prediction = 15;
  if (this->road_prediction() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->road_prediction(), target);
  }

  // float length = 16;
  if (this->length() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(16, this->length(), target);
  }

  // .autodrive.workflow.proto.TriggerModel triggered_model = 17;
  if (this->triggered_model() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      17, this->triggered_model(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.RoadInfoLine)
  return target;
}

size_t RoadInfoLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.RoadInfoLine)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.RoadInfoCurveLine curve_segs = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->curve_segs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->curve_segs(static_cast<int>(i)));
    }
  }

  // string str_id = 2;
  if (this->str_id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->str_id());
  }

  // int32 id = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  // int32 life_time = 4;
  if (this->life_time() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->life_time());
  }

  // float start = 5;
  if (this->start() != 0) {
    total_size += 1 + 4;
  }

  // float end = 6;
  if (this->end() != 0) {
    total_size += 1 + 4;
  }

  // float conf = 7;
  if (this->conf() != 0) {
    total_size += 1 + 4;
  }

  // float width = 8;
  if (this->width() != 0) {
    total_size += 1 + 4;
  }

  // .autodrive.workflow.proto.RoadInfoLinePosition position = 9;
  if (this->position() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->position());
  }

  // .autodrive.workflow.proto.RoadInfoLineSource conf_level = 10;
  if (this->conf_level() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->conf_level());
  }

  // .autodrive.workflow.proto.RoadInfoLineColor line_color = 11;
  if (this->line_color() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->line_color());
  }

  // .autodrive.workflow.proto.RoadInfoLineType type = 12;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // .autodrive.workflow.proto.DlmType dlm_type = 13;
  if (this->dlm_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->dlm_type());
  }

  // .autodrive.workflow.proto.DecelType decel_type = 14;
  if (this->decel_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->decel_type());
  }

  // uint32 road_prediction = 15;
  if (this->road_prediction() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->road_prediction());
  }

  // float length = 16;
  if (this->length() != 0) {
    total_size += 2 + 4;
  }

  // .autodrive.workflow.proto.TriggerModel triggered_model = 17;
  if (this->triggered_model() != 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->triggered_model());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadInfoLine::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.RoadInfoLine)
  GOOGLE_DCHECK_NE(&from, this);
  const RoadInfoLine* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RoadInfoLine>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.RoadInfoLine)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.RoadInfoLine)
    MergeFrom(*source);
  }
}

void RoadInfoLine::MergeFrom(const RoadInfoLine& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.RoadInfoLine)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  curve_segs_.MergeFrom(from.curve_segs_);
  if (from.str_id().size() > 0) {

    str_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.str_id_);
  }
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.life_time() != 0) {
    set_life_time(from.life_time());
  }
  if (from.start() != 0) {
    set_start(from.start());
  }
  if (from.end() != 0) {
    set_end(from.end());
  }
  if (from.conf() != 0) {
    set_conf(from.conf());
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.position() != 0) {
    set_position(from.position());
  }
  if (from.conf_level() != 0) {
    set_conf_level(from.conf_level());
  }
  if (from.line_color() != 0) {
    set_line_color(from.line_color());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.dlm_type() != 0) {
    set_dlm_type(from.dlm_type());
  }
  if (from.decel_type() != 0) {
    set_decel_type(from.decel_type());
  }
  if (from.road_prediction() != 0) {
    set_road_prediction(from.road_prediction());
  }
  if (from.length() != 0) {
    set_length(from.length());
  }
  if (from.triggered_model() != 0) {
    set_triggered_model(from.triggered_model());
  }
}

void RoadInfoLine::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.RoadInfoLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoadInfoLine::CopyFrom(const RoadInfoLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.RoadInfoLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadInfoLine::IsInitialized() const {
  return true;
}

void RoadInfoLine::Swap(RoadInfoLine* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RoadInfoLine::InternalSwap(RoadInfoLine* other) {
  using std::swap;
  curve_segs_.InternalSwap(&other->curve_segs_);
  str_id_.Swap(&other->str_id_);
  swap(id_, other->id_);
  swap(life_time_, other->life_time_);
  swap(start_, other->start_);
  swap(end_, other->end_);
  swap(conf_, other->conf_);
  swap(width_, other->width_);
  swap(position_, other->position_);
  swap(conf_level_, other->conf_level_);
  swap(line_color_, other->line_color_);
  swap(type_, other->type_);
  swap(dlm_type_, other->dlm_type_);
  swap(decel_type_, other->decel_type_);
  swap(road_prediction_, other->road_prediction_);
  swap(length_, other->length_);
  swap(triggered_model_, other->triggered_model_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RoadInfoLine::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void HighWayJunctionInfo::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HighWayJunctionInfo::kHighwayExitLeftFieldNumber;
const int HighWayJunctionInfo::kHighwayExitRightFieldNumber;
const int HighWayJunctionInfo::kHighwayEntryLeftFieldNumber;
const int HighWayJunctionInfo::kHighwayEntryRightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HighWayJunctionInfo::HighWayJunctionInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsHighWayJunctionInfo();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.HighWayJunctionInfo)
}
HighWayJunctionInfo::HighWayJunctionInfo(const HighWayJunctionInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&highway_exit_left_, &from.highway_exit_left_,
    static_cast<size_t>(reinterpret_cast<char*>(&highway_entry_right_) -
    reinterpret_cast<char*>(&highway_exit_left_)) + sizeof(highway_entry_right_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.HighWayJunctionInfo)
}

void HighWayJunctionInfo::SharedCtor() {
  ::memset(&highway_exit_left_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&highway_entry_right_) -
      reinterpret_cast<char*>(&highway_exit_left_)) + sizeof(highway_entry_right_));
  _cached_size_ = 0;
}

HighWayJunctionInfo::~HighWayJunctionInfo() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.HighWayJunctionInfo)
  SharedDtor();
}

void HighWayJunctionInfo::SharedDtor() {
}

void HighWayJunctionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HighWayJunctionInfo::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const HighWayJunctionInfo& HighWayJunctionInfo::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsHighWayJunctionInfo();
  return *internal_default_instance();
}

HighWayJunctionInfo* HighWayJunctionInfo::New(::google::protobuf::Arena* arena) const {
  HighWayJunctionInfo* n = new HighWayJunctionInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HighWayJunctionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.HighWayJunctionInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&highway_exit_left_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&highway_entry_right_) -
      reinterpret_cast<char*>(&highway_exit_left_)) + sizeof(highway_entry_right_));
  _internal_metadata_.Clear();
}

bool HighWayJunctionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.HighWayJunctionInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // bool highway_exit_left = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &highway_exit_left_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool highway_exit_right = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &highway_exit_right_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool highway_entry_left = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &highway_entry_left_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool highway_entry_right = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &highway_entry_right_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.HighWayJunctionInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.HighWayJunctionInfo)
  return false;
#undef DO_
}

void HighWayJunctionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.HighWayJunctionInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool highway_exit_left = 1;
  if (this->highway_exit_left() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->highway_exit_left(), output);
  }

  // bool highway_exit_right = 2;
  if (this->highway_exit_right() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->highway_exit_right(), output);
  }

  // bool highway_entry_left = 3;
  if (this->highway_entry_left() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->highway_entry_left(), output);
  }

  // bool highway_entry_right = 4;
  if (this->highway_entry_right() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->highway_entry_right(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.HighWayJunctionInfo)
}

::google::protobuf::uint8* HighWayJunctionInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.HighWayJunctionInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool highway_exit_left = 1;
  if (this->highway_exit_left() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->highway_exit_left(), target);
  }

  // bool highway_exit_right = 2;
  if (this->highway_exit_right() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->highway_exit_right(), target);
  }

  // bool highway_entry_left = 3;
  if (this->highway_entry_left() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->highway_entry_left(), target);
  }

  // bool highway_entry_right = 4;
  if (this->highway_entry_right() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->highway_entry_right(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.HighWayJunctionInfo)
  return target;
}

size_t HighWayJunctionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.HighWayJunctionInfo)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // bool highway_exit_left = 1;
  if (this->highway_exit_left() != 0) {
    total_size += 1 + 1;
  }

  // bool highway_exit_right = 2;
  if (this->highway_exit_right() != 0) {
    total_size += 1 + 1;
  }

  // bool highway_entry_left = 3;
  if (this->highway_entry_left() != 0) {
    total_size += 1 + 1;
  }

  // bool highway_entry_right = 4;
  if (this->highway_entry_right() != 0) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HighWayJunctionInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.HighWayJunctionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const HighWayJunctionInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const HighWayJunctionInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.HighWayJunctionInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.HighWayJunctionInfo)
    MergeFrom(*source);
  }
}

void HighWayJunctionInfo::MergeFrom(const HighWayJunctionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.HighWayJunctionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.highway_exit_left() != 0) {
    set_highway_exit_left(from.highway_exit_left());
  }
  if (from.highway_exit_right() != 0) {
    set_highway_exit_right(from.highway_exit_right());
  }
  if (from.highway_entry_left() != 0) {
    set_highway_entry_left(from.highway_entry_left());
  }
  if (from.highway_entry_right() != 0) {
    set_highway_entry_right(from.highway_entry_right());
  }
}

void HighWayJunctionInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.HighWayJunctionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HighWayJunctionInfo::CopyFrom(const HighWayJunctionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.HighWayJunctionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HighWayJunctionInfo::IsInitialized() const {
  return true;
}

void HighWayJunctionInfo::Swap(HighWayJunctionInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HighWayJunctionInfo::InternalSwap(HighWayJunctionInfo* other) {
  using std::swap;
  swap(highway_exit_left_, other->highway_exit_left_);
  swap(highway_exit_right_, other->highway_exit_right_);
  swap(highway_entry_left_, other->highway_entry_left_);
  swap(highway_entry_right_, other->highway_entry_right_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HighWayJunctionInfo::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void NumberOfLanes::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NumberOfLanes::kRange0MFieldNumber;
const int NumberOfLanes::kRange35MFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NumberOfLanes::NumberOfLanes()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsNumberOfLanes();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.NumberOfLanes)
}
NumberOfLanes::NumberOfLanes(const NumberOfLanes& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&range_0m_, &from.range_0m_,
    static_cast<size_t>(reinterpret_cast<char*>(&range_35m_) -
    reinterpret_cast<char*>(&range_0m_)) + sizeof(range_35m_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.NumberOfLanes)
}

void NumberOfLanes::SharedCtor() {
  ::memset(&range_0m_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&range_35m_) -
      reinterpret_cast<char*>(&range_0m_)) + sizeof(range_35m_));
  _cached_size_ = 0;
}

NumberOfLanes::~NumberOfLanes() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.NumberOfLanes)
  SharedDtor();
}

void NumberOfLanes::SharedDtor() {
}

void NumberOfLanes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NumberOfLanes::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const NumberOfLanes& NumberOfLanes::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsNumberOfLanes();
  return *internal_default_instance();
}

NumberOfLanes* NumberOfLanes::New(::google::protobuf::Arena* arena) const {
  NumberOfLanes* n = new NumberOfLanes;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NumberOfLanes::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.NumberOfLanes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&range_0m_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&range_35m_) -
      reinterpret_cast<char*>(&range_0m_)) + sizeof(range_35m_));
  _internal_metadata_.Clear();
}

bool NumberOfLanes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.NumberOfLanes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 range_0m = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &range_0m_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 range_35m = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &range_35m_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.NumberOfLanes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.NumberOfLanes)
  return false;
#undef DO_
}

void NumberOfLanes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.NumberOfLanes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 range_0m = 1;
  if (this->range_0m() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->range_0m(), output);
  }

  // uint32 range_35m = 2;
  if (this->range_35m() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->range_35m(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.NumberOfLanes)
}

::google::protobuf::uint8* NumberOfLanes::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.NumberOfLanes)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 range_0m = 1;
  if (this->range_0m() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->range_0m(), target);
  }

  // uint32 range_35m = 2;
  if (this->range_35m() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->range_35m(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.NumberOfLanes)
  return target;
}

size_t NumberOfLanes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.NumberOfLanes)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // uint32 range_0m = 1;
  if (this->range_0m() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->range_0m());
  }

  // uint32 range_35m = 2;
  if (this->range_35m() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->range_35m());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NumberOfLanes::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.NumberOfLanes)
  GOOGLE_DCHECK_NE(&from, this);
  const NumberOfLanes* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const NumberOfLanes>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.NumberOfLanes)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.NumberOfLanes)
    MergeFrom(*source);
  }
}

void NumberOfLanes::MergeFrom(const NumberOfLanes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.NumberOfLanes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.range_0m() != 0) {
    set_range_0m(from.range_0m());
  }
  if (from.range_35m() != 0) {
    set_range_35m(from.range_35m());
  }
}

void NumberOfLanes::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.NumberOfLanes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NumberOfLanes::CopyFrom(const NumberOfLanes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.NumberOfLanes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NumberOfLanes::IsInitialized() const {
  return true;
}

void NumberOfLanes::Swap(NumberOfLanes* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NumberOfLanes::InternalSwap(NumberOfLanes* other) {
  using std::swap;
  swap(range_0m_, other->range_0m_);
  swap(range_35m_, other->range_35m_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NumberOfLanes::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void RoadInfoLines::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_RoadInfoLines_default_instance_._instance.get_mutable()->camera_matrix_ = const_cast< ::autodrive::workflow::proto::perception_base::CameraMatrix*>(
      ::autodrive::workflow::proto::perception_base::CameraMatrix::internal_default_instance());
  ::autodrive::workflow::proto::_RoadInfoLines_default_instance_._instance.get_mutable()->highway_junction_info_ = const_cast< ::autodrive::workflow::proto::HighWayJunctionInfo*>(
      ::autodrive::workflow::proto::HighWayJunctionInfo::internal_default_instance());
  ::autodrive::workflow::proto::_RoadInfoLines_default_instance_._instance.get_mutable()->number_of_lanes_ = const_cast< ::autodrive::workflow::proto::NumberOfLanes*>(
      ::autodrive::workflow::proto::NumberOfLanes::internal_default_instance());
}
void RoadInfoLines::clear_camera_matrix() {
  if (GetArenaNoVirtual() == NULL && camera_matrix_ != NULL) {
    delete camera_matrix_;
  }
  camera_matrix_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RoadInfoLines::kCameraMatrixFieldNumber;
const int RoadInfoLines::kLinesFieldNumber;
const int RoadInfoLines::kSrcTimeStampFieldNumber;
const int RoadInfoLines::kAsynTimeStampFieldNumber;
const int RoadInfoLines::kAmbiguousLinePatternLeftFieldNumber;
const int RoadInfoLines::kAmbiguousLinePatternRightFieldNumber;
const int RoadInfoLines::kConstructionAreaFieldNumber;
const int RoadInfoLines::kLaneChangeFieldNumber;
const int RoadInfoLines::kDrivingSideFieldNumber;
const int RoadInfoLines::kTransitionPointsFieldNumber;
const int RoadInfoLines::kHighwayJunctionInfoFieldNumber;
const int RoadInfoLines::kNumberOfLanesFieldNumber;
const int RoadInfoLines::kHostWidthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RoadInfoLines::RoadInfoLines()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoLines();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.RoadInfoLines)
}
RoadInfoLines::RoadInfoLines(const RoadInfoLines& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      lines_(from.lines_),
      transition_points_(from.transition_points_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_camera_matrix()) {
    camera_matrix_ = new ::autodrive::workflow::proto::perception_base::CameraMatrix(*from.camera_matrix_);
  } else {
    camera_matrix_ = NULL;
  }
  if (from.has_highway_junction_info()) {
    highway_junction_info_ = new ::autodrive::workflow::proto::HighWayJunctionInfo(*from.highway_junction_info_);
  } else {
    highway_junction_info_ = NULL;
  }
  if (from.has_number_of_lanes()) {
    number_of_lanes_ = new ::autodrive::workflow::proto::NumberOfLanes(*from.number_of_lanes_);
  } else {
    number_of_lanes_ = NULL;
  }
  ::memcpy(&src_time_stamp_, &from.src_time_stamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&host_width_) -
    reinterpret_cast<char*>(&src_time_stamp_)) + sizeof(host_width_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.RoadInfoLines)
}

void RoadInfoLines::SharedCtor() {
  ::memset(&camera_matrix_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&host_width_) -
      reinterpret_cast<char*>(&camera_matrix_)) + sizeof(host_width_));
  _cached_size_ = 0;
}

RoadInfoLines::~RoadInfoLines() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.RoadInfoLines)
  SharedDtor();
}

void RoadInfoLines::SharedDtor() {
  if (this != internal_default_instance()) delete camera_matrix_;
  if (this != internal_default_instance()) delete highway_junction_info_;
  if (this != internal_default_instance()) delete number_of_lanes_;
}

void RoadInfoLines::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoadInfoLines::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RoadInfoLines& RoadInfoLines::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoLines();
  return *internal_default_instance();
}

RoadInfoLines* RoadInfoLines::New(::google::protobuf::Arena* arena) const {
  RoadInfoLines* n = new RoadInfoLines;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RoadInfoLines::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.RoadInfoLines)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  lines_.Clear();
  transition_points_.Clear();
  if (GetArenaNoVirtual() == NULL && camera_matrix_ != NULL) {
    delete camera_matrix_;
  }
  camera_matrix_ = NULL;
  if (GetArenaNoVirtual() == NULL && highway_junction_info_ != NULL) {
    delete highway_junction_info_;
  }
  highway_junction_info_ = NULL;
  if (GetArenaNoVirtual() == NULL && number_of_lanes_ != NULL) {
    delete number_of_lanes_;
  }
  number_of_lanes_ = NULL;
  ::memset(&src_time_stamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&host_width_) -
      reinterpret_cast<char*>(&src_time_stamp_)) + sizeof(host_width_));
  _internal_metadata_.Clear();
}

bool RoadInfoLines::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.RoadInfoLines)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.perception_base.CameraMatrix camera_matrix = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_camera_matrix()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.RoadInfoLine lines = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_lines()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 src_time_stamp = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &src_time_stamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 asyn_time_stamp = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &asyn_time_stamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 ambiguous_line_pattern_left = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ambiguous_line_pattern_left_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 ambiguous_line_pattern_right = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ambiguous_line_pattern_right_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 construction_area = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &construction_area_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.LaneChange lane_change = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_lane_change(static_cast< ::autodrive::workflow::proto::LaneChange >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadInfoLines.DrivingSide driving_side = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_driving_side(static_cast< ::autodrive::workflow::proto::RoadInfoLines_DrivingSide >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.TransitionPoints transition_points = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u /* 82 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_transition_points()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.HighWayJunctionInfo highway_junction_info = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u /* 90 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_highway_junction_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.NumberOfLanes number_of_lanes = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u /* 98 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_number_of_lanes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float host_width = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(109u /* 109 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &host_width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.RoadInfoLines)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.RoadInfoLines)
  return false;
#undef DO_
}

void RoadInfoLines::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.RoadInfoLines)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.perception_base.CameraMatrix camera_matrix = 1;
  if (this->has_camera_matrix()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->camera_matrix_, output);
  }

  // repeated .autodrive.workflow.proto.RoadInfoLine lines = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->lines_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->lines(static_cast<int>(i)), output);
  }

  // int64 src_time_stamp = 3;
  if (this->src_time_stamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->src_time_stamp(), output);
  }

  // int64 asyn_time_stamp = 4;
  if (this->asyn_time_stamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->asyn_time_stamp(), output);
  }

  // uint32 ambiguous_line_pattern_left = 5;
  if (this->ambiguous_line_pattern_left() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->ambiguous_line_pattern_left(), output);
  }

  // uint32 ambiguous_line_pattern_right = 6;
  if (this->ambiguous_line_pattern_right() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->ambiguous_line_pattern_right(), output);
  }

  // uint32 construction_area = 7;
  if (this->construction_area() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->construction_area(), output);
  }

  // .autodrive.workflow.proto.LaneChange lane_change = 8;
  if (this->lane_change() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->lane_change(), output);
  }

  // .autodrive.workflow.proto.RoadInfoLines.DrivingSide driving_side = 9;
  if (this->driving_side() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->driving_side(), output);
  }

  // repeated .autodrive.workflow.proto.TransitionPoints transition_points = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->transition_points_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->transition_points(static_cast<int>(i)), output);
  }

  // .autodrive.workflow.proto.HighWayJunctionInfo highway_junction_info = 11;
  if (this->has_highway_junction_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->highway_junction_info_, output);
  }

  // .autodrive.workflow.proto.NumberOfLanes number_of_lanes = 12;
  if (this->has_number_of_lanes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->number_of_lanes_, output);
  }

  // float host_width = 13;
  if (this->host_width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->host_width(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.RoadInfoLines)
}

::google::protobuf::uint8* RoadInfoLines::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.RoadInfoLines)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.perception_base.CameraMatrix camera_matrix = 1;
  if (this->has_camera_matrix()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->camera_matrix_, deterministic, target);
  }

  // repeated .autodrive.workflow.proto.RoadInfoLine lines = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->lines_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->lines(static_cast<int>(i)), deterministic, target);
  }

  // int64 src_time_stamp = 3;
  if (this->src_time_stamp() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->src_time_stamp(), target);
  }

  // int64 asyn_time_stamp = 4;
  if (this->asyn_time_stamp() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->asyn_time_stamp(), target);
  }

  // uint32 ambiguous_line_pattern_left = 5;
  if (this->ambiguous_line_pattern_left() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->ambiguous_line_pattern_left(), target);
  }

  // uint32 ambiguous_line_pattern_right = 6;
  if (this->ambiguous_line_pattern_right() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->ambiguous_line_pattern_right(), target);
  }

  // uint32 construction_area = 7;
  if (this->construction_area() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->construction_area(), target);
  }

  // .autodrive.workflow.proto.LaneChange lane_change = 8;
  if (this->lane_change() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->lane_change(), target);
  }

  // .autodrive.workflow.proto.RoadInfoLines.DrivingSide driving_side = 9;
  if (this->driving_side() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->driving_side(), target);
  }

  // repeated .autodrive.workflow.proto.TransitionPoints transition_points = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->transition_points_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, this->transition_points(static_cast<int>(i)), deterministic, target);
  }

  // .autodrive.workflow.proto.HighWayJunctionInfo highway_junction_info = 11;
  if (this->has_highway_junction_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, *this->highway_junction_info_, deterministic, target);
  }

  // .autodrive.workflow.proto.NumberOfLanes number_of_lanes = 12;
  if (this->has_number_of_lanes()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        12, *this->number_of_lanes_, deterministic, target);
  }

  // float host_width = 13;
  if (this->host_width() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->host_width(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.RoadInfoLines)
  return target;
}

size_t RoadInfoLines::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.RoadInfoLines)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.RoadInfoLine lines = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->lines_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->lines(static_cast<int>(i)));
    }
  }

  // repeated .autodrive.workflow.proto.TransitionPoints transition_points = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->transition_points_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->transition_points(static_cast<int>(i)));
    }
  }

  // .autodrive.workflow.proto.perception_base.CameraMatrix camera_matrix = 1;
  if (this->has_camera_matrix()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->camera_matrix_);
  }

  // .autodrive.workflow.proto.HighWayJunctionInfo highway_junction_info = 11;
  if (this->has_highway_junction_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->highway_junction_info_);
  }

  // .autodrive.workflow.proto.NumberOfLanes number_of_lanes = 12;
  if (this->has_number_of_lanes()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->number_of_lanes_);
  }

  // int64 src_time_stamp = 3;
  if (this->src_time_stamp() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->src_time_stamp());
  }

  // int64 asyn_time_stamp = 4;
  if (this->asyn_time_stamp() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->asyn_time_stamp());
  }

  // uint32 ambiguous_line_pattern_left = 5;
  if (this->ambiguous_line_pattern_left() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ambiguous_line_pattern_left());
  }

  // uint32 ambiguous_line_pattern_right = 6;
  if (this->ambiguous_line_pattern_right() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ambiguous_line_pattern_right());
  }

  // uint32 construction_area = 7;
  if (this->construction_area() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->construction_area());
  }

  // .autodrive.workflow.proto.LaneChange lane_change = 8;
  if (this->lane_change() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->lane_change());
  }

  // .autodrive.workflow.proto.RoadInfoLines.DrivingSide driving_side = 9;
  if (this->driving_side() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->driving_side());
  }

  // float host_width = 13;
  if (this->host_width() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadInfoLines::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.RoadInfoLines)
  GOOGLE_DCHECK_NE(&from, this);
  const RoadInfoLines* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RoadInfoLines>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.RoadInfoLines)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.RoadInfoLines)
    MergeFrom(*source);
  }
}

void RoadInfoLines::MergeFrom(const RoadInfoLines& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.RoadInfoLines)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  lines_.MergeFrom(from.lines_);
  transition_points_.MergeFrom(from.transition_points_);
  if (from.has_camera_matrix()) {
    mutable_camera_matrix()->::autodrive::workflow::proto::perception_base::CameraMatrix::MergeFrom(from.camera_matrix());
  }
  if (from.has_highway_junction_info()) {
    mutable_highway_junction_info()->::autodrive::workflow::proto::HighWayJunctionInfo::MergeFrom(from.highway_junction_info());
  }
  if (from.has_number_of_lanes()) {
    mutable_number_of_lanes()->::autodrive::workflow::proto::NumberOfLanes::MergeFrom(from.number_of_lanes());
  }
  if (from.src_time_stamp() != 0) {
    set_src_time_stamp(from.src_time_stamp());
  }
  if (from.asyn_time_stamp() != 0) {
    set_asyn_time_stamp(from.asyn_time_stamp());
  }
  if (from.ambiguous_line_pattern_left() != 0) {
    set_ambiguous_line_pattern_left(from.ambiguous_line_pattern_left());
  }
  if (from.ambiguous_line_pattern_right() != 0) {
    set_ambiguous_line_pattern_right(from.ambiguous_line_pattern_right());
  }
  if (from.construction_area() != 0) {
    set_construction_area(from.construction_area());
  }
  if (from.lane_change() != 0) {
    set_lane_change(from.lane_change());
  }
  if (from.driving_side() != 0) {
    set_driving_side(from.driving_side());
  }
  if (from.host_width() != 0) {
    set_host_width(from.host_width());
  }
}

void RoadInfoLines::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.RoadInfoLines)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoadInfoLines::CopyFrom(const RoadInfoLines& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.RoadInfoLines)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadInfoLines::IsInitialized() const {
  return true;
}

void RoadInfoLines::Swap(RoadInfoLines* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RoadInfoLines::InternalSwap(RoadInfoLines* other) {
  using std::swap;
  lines_.InternalSwap(&other->lines_);
  transition_points_.InternalSwap(&other->transition_points_);
  swap(camera_matrix_, other->camera_matrix_);
  swap(highway_junction_info_, other->highway_junction_info_);
  swap(number_of_lanes_, other->number_of_lanes_);
  swap(src_time_stamp_, other->src_time_stamp_);
  swap(asyn_time_stamp_, other->asyn_time_stamp_);
  swap(ambiguous_line_pattern_left_, other->ambiguous_line_pattern_left_);
  swap(ambiguous_line_pattern_right_, other->ambiguous_line_pattern_right_);
  swap(construction_area_, other->construction_area_);
  swap(lane_change_, other->lane_change_);
  swap(driving_side_, other->driving_side_);
  swap(host_width_, other->host_width_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RoadInfoLines::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void StopLines::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StopLines::kLateralDistanceFieldNumber;
const int StopLines::kLongitudinalDistanceFieldNumber;
const int StopLines::kAngleFieldNumber;
const int StopLines::kConfidenceFieldNumber;
const int StopLines::kIdFieldNumber;
const int StopLines::kStopLineStatusFieldNumber;
const int StopLines::kStopLineTypeFieldNumber;
const int StopLines::kStopLineColorFieldNumber;
const int StopLines::kIsRelevantFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StopLines::StopLines()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsStopLines();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.StopLines)
}
StopLines::StopLines(const StopLines& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&lateral_distance_, &from.lateral_distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_relevant_) -
    reinterpret_cast<char*>(&lateral_distance_)) + sizeof(is_relevant_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.StopLines)
}

void StopLines::SharedCtor() {
  ::memset(&lateral_distance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_relevant_) -
      reinterpret_cast<char*>(&lateral_distance_)) + sizeof(is_relevant_));
  _cached_size_ = 0;
}

StopLines::~StopLines() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.StopLines)
  SharedDtor();
}

void StopLines::SharedDtor() {
}

void StopLines::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StopLines::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const StopLines& StopLines::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsStopLines();
  return *internal_default_instance();
}

StopLines* StopLines::New(::google::protobuf::Arena* arena) const {
  StopLines* n = new StopLines;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StopLines::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.StopLines)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&lateral_distance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_relevant_) -
      reinterpret_cast<char*>(&lateral_distance_)) + sizeof(is_relevant_));
  _internal_metadata_.Clear();
}

bool StopLines::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.StopLines)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float lateral_distance = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u /* 13 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lateral_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float longitudinal_distance = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u /* 21 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &longitudinal_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float angle = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u /* 29 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float confidence = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u /* 37 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &confidence_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 id = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.StopLineStatus stop_line_status = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_stop_line_status(static_cast< ::autodrive::workflow::proto::StopLineStatus >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.StopLineType stop_line_type = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_stop_line_type(static_cast< ::autodrive::workflow::proto::StopLineType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.StopLineColorType stop_line_color = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_stop_line_color(static_cast< ::autodrive::workflow::proto::StopLineColorType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool is_relevant = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_relevant_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.StopLines)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.StopLines)
  return false;
#undef DO_
}

void StopLines::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.StopLines)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float lateral_distance = 1;
  if (this->lateral_distance() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->lateral_distance(), output);
  }

  // float longitudinal_distance = 2;
  if (this->longitudinal_distance() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->longitudinal_distance(), output);
  }

  // float angle = 3;
  if (this->angle() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->angle(), output);
  }

  // float confidence = 4;
  if (this->confidence() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->confidence(), output);
  }

  // uint32 id = 5;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->id(), output);
  }

  // .autodrive.workflow.proto.StopLineStatus stop_line_status = 6;
  if (this->stop_line_status() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->stop_line_status(), output);
  }

  // .autodrive.workflow.proto.StopLineType stop_line_type = 7;
  if (this->stop_line_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->stop_line_type(), output);
  }

  // .autodrive.workflow.proto.StopLineColorType stop_line_color = 8;
  if (this->stop_line_color() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->stop_line_color(), output);
  }

  // bool is_relevant = 9;
  if (this->is_relevant() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->is_relevant(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.StopLines)
}

::google::protobuf::uint8* StopLines::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.StopLines)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float lateral_distance = 1;
  if (this->lateral_distance() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->lateral_distance(), target);
  }

  // float longitudinal_distance = 2;
  if (this->longitudinal_distance() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->longitudinal_distance(), target);
  }

  // float angle = 3;
  if (this->angle() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->angle(), target);
  }

  // float confidence = 4;
  if (this->confidence() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->confidence(), target);
  }

  // uint32 id = 5;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->id(), target);
  }

  // .autodrive.workflow.proto.StopLineStatus stop_line_status = 6;
  if (this->stop_line_status() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->stop_line_status(), target);
  }

  // .autodrive.workflow.proto.StopLineType stop_line_type = 7;
  if (this->stop_line_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->stop_line_type(), target);
  }

  // .autodrive.workflow.proto.StopLineColorType stop_line_color = 8;
  if (this->stop_line_color() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->stop_line_color(), target);
  }

  // bool is_relevant = 9;
  if (this->is_relevant() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->is_relevant(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.StopLines)
  return target;
}

size_t StopLines::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.StopLines)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // float lateral_distance = 1;
  if (this->lateral_distance() != 0) {
    total_size += 1 + 4;
  }

  // float longitudinal_distance = 2;
  if (this->longitudinal_distance() != 0) {
    total_size += 1 + 4;
  }

  // float angle = 3;
  if (this->angle() != 0) {
    total_size += 1 + 4;
  }

  // float confidence = 4;
  if (this->confidence() != 0) {
    total_size += 1 + 4;
  }

  // uint32 id = 5;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }

  // .autodrive.workflow.proto.StopLineStatus stop_line_status = 6;
  if (this->stop_line_status() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->stop_line_status());
  }

  // .autodrive.workflow.proto.StopLineType stop_line_type = 7;
  if (this->stop_line_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->stop_line_type());
  }

  // .autodrive.workflow.proto.StopLineColorType stop_line_color = 8;
  if (this->stop_line_color() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->stop_line_color());
  }

  // bool is_relevant = 9;
  if (this->is_relevant() != 0) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StopLines::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.StopLines)
  GOOGLE_DCHECK_NE(&from, this);
  const StopLines* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const StopLines>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.StopLines)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.StopLines)
    MergeFrom(*source);
  }
}

void StopLines::MergeFrom(const StopLines& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.StopLines)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.lateral_distance() != 0) {
    set_lateral_distance(from.lateral_distance());
  }
  if (from.longitudinal_distance() != 0) {
    set_longitudinal_distance(from.longitudinal_distance());
  }
  if (from.angle() != 0) {
    set_angle(from.angle());
  }
  if (from.confidence() != 0) {
    set_confidence(from.confidence());
  }
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.stop_line_status() != 0) {
    set_stop_line_status(from.stop_line_status());
  }
  if (from.stop_line_type() != 0) {
    set_stop_line_type(from.stop_line_type());
  }
  if (from.stop_line_color() != 0) {
    set_stop_line_color(from.stop_line_color());
  }
  if (from.is_relevant() != 0) {
    set_is_relevant(from.is_relevant());
  }
}

void StopLines::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.StopLines)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StopLines::CopyFrom(const StopLines& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.StopLines)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopLines::IsInitialized() const {
  return true;
}

void StopLines::Swap(StopLines* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StopLines::InternalSwap(StopLines* other) {
  using std::swap;
  swap(lateral_distance_, other->lateral_distance_);
  swap(longitudinal_distance_, other->longitudinal_distance_);
  swap(angle_, other->angle_);
  swap(confidence_, other->confidence_);
  swap(id_, other->id_);
  swap(stop_line_status_, other->stop_line_status_);
  swap(stop_line_type_, other->stop_line_type_);
  swap(stop_line_color_, other->stop_line_color_);
  swap(is_relevant_, other->is_relevant_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StopLines::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Crossings::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Crossings::kLateralPositionFieldNumber;
const int Crossings::kLongitudinalPositionFieldNumber;
const int Crossings::kConfidenceFieldNumber;
const int Crossings::kIdFieldNumber;
const int Crossings::kCrossingsTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Crossings::Crossings()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsCrossings();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.Crossings)
}
Crossings::Crossings(const Crossings& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&lateral_position_, &from.lateral_position_,
    static_cast<size_t>(reinterpret_cast<char*>(&crossings_type_) -
    reinterpret_cast<char*>(&lateral_position_)) + sizeof(crossings_type_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.Crossings)
}

void Crossings::SharedCtor() {
  ::memset(&lateral_position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&crossings_type_) -
      reinterpret_cast<char*>(&lateral_position_)) + sizeof(crossings_type_));
  _cached_size_ = 0;
}

Crossings::~Crossings() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.Crossings)
  SharedDtor();
}

void Crossings::SharedDtor() {
}

void Crossings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Crossings::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Crossings& Crossings::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsCrossings();
  return *internal_default_instance();
}

Crossings* Crossings::New(::google::protobuf::Arena* arena) const {
  Crossings* n = new Crossings;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Crossings::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.Crossings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&lateral_position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&crossings_type_) -
      reinterpret_cast<char*>(&lateral_position_)) + sizeof(crossings_type_));
  _internal_metadata_.Clear();
}

bool Crossings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.Crossings)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float lateral_position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u /* 13 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &lateral_position_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float longitudinal_position = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u /* 21 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &longitudinal_position_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float confidence = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u /* 29 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &confidence_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 id = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.CrossingsType crossings_type = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_crossings_type(static_cast< ::autodrive::workflow::proto::CrossingsType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.Crossings)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.Crossings)
  return false;
#undef DO_
}

void Crossings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.Crossings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float lateral_position = 1;
  if (this->lateral_position() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->lateral_position(), output);
  }

  // float longitudinal_position = 2;
  if (this->longitudinal_position() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->longitudinal_position(), output);
  }

  // float confidence = 3;
  if (this->confidence() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->confidence(), output);
  }

  // uint32 id = 4;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->id(), output);
  }

  // .autodrive.workflow.proto.CrossingsType crossings_type = 5;
  if (this->crossings_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->crossings_type(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.Crossings)
}

::google::protobuf::uint8* Crossings::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.Crossings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float lateral_position = 1;
  if (this->lateral_position() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->lateral_position(), target);
  }

  // float longitudinal_position = 2;
  if (this->longitudinal_position() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->longitudinal_position(), target);
  }

  // float confidence = 3;
  if (this->confidence() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->confidence(), target);
  }

  // uint32 id = 4;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->id(), target);
  }

  // .autodrive.workflow.proto.CrossingsType crossings_type = 5;
  if (this->crossings_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->crossings_type(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.Crossings)
  return target;
}

size_t Crossings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.Crossings)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // float lateral_position = 1;
  if (this->lateral_position() != 0) {
    total_size += 1 + 4;
  }

  // float longitudinal_position = 2;
  if (this->longitudinal_position() != 0) {
    total_size += 1 + 4;
  }

  // float confidence = 3;
  if (this->confidence() != 0) {
    total_size += 1 + 4;
  }

  // uint32 id = 4;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->id());
  }

  // .autodrive.workflow.proto.CrossingsType crossings_type = 5;
  if (this->crossings_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->crossings_type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Crossings::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.Crossings)
  GOOGLE_DCHECK_NE(&from, this);
  const Crossings* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Crossings>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.Crossings)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.Crossings)
    MergeFrom(*source);
  }
}

void Crossings::MergeFrom(const Crossings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.Crossings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.lateral_position() != 0) {
    set_lateral_position(from.lateral_position());
  }
  if (from.longitudinal_position() != 0) {
    set_longitudinal_position(from.longitudinal_position());
  }
  if (from.confidence() != 0) {
    set_confidence(from.confidence());
  }
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.crossings_type() != 0) {
    set_crossings_type(from.crossings_type());
  }
}

void Crossings::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.Crossings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Crossings::CopyFrom(const Crossings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.Crossings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Crossings::IsInitialized() const {
  return true;
}

void Crossings::Swap(Crossings* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Crossings::InternalSwap(Crossings* other) {
  using std::swap;
  swap(lateral_position_, other->lateral_position_);
  swap(longitudinal_position_, other->longitudinal_position_);
  swap(confidence_, other->confidence_);
  swap(id_, other->id_);
  swap(crossings_type_, other->crossings_type_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Crossings::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void RoadInfoMsg::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_RoadInfoMsg_default_instance_._instance.get_mutable()->header_ = const_cast< ::autodrive::workflow::proto::MsgHeader*>(
      ::autodrive::workflow::proto::MsgHeader::internal_default_instance());
  ::autodrive::workflow::proto::_RoadInfoMsg_default_instance_._instance.get_mutable()->error_ = const_cast< ::autodrive::workflow::proto::Error*>(
      ::autodrive::workflow::proto::Error::internal_default_instance());
  ::autodrive::workflow::proto::_RoadInfoMsg_default_instance_._instance.get_mutable()->road_borders_ = const_cast< ::autodrive::workflow::proto::RoadBorders*>(
      ::autodrive::workflow::proto::RoadBorders::internal_default_instance());
  ::autodrive::workflow::proto::_RoadInfoMsg_default_instance_._instance.get_mutable()->lane_lines_ = const_cast< ::autodrive::workflow::proto::RoadInfoLines*>(
      ::autodrive::workflow::proto::RoadInfoLines::internal_default_instance());
  ::autodrive::workflow::proto::_RoadInfoMsg_default_instance_._instance.get_mutable()->stop_lines_ = const_cast< ::autodrive::workflow::proto::StopLines*>(
      ::autodrive::workflow::proto::StopLines::internal_default_instance());
  ::autodrive::workflow::proto::_RoadInfoMsg_default_instance_._instance.get_mutable()->crossings_ = const_cast< ::autodrive::workflow::proto::Crossings*>(
      ::autodrive::workflow::proto::Crossings::internal_default_instance());
}
void RoadInfoMsg::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
void RoadInfoMsg::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RoadInfoMsg::kHeaderFieldNumber;
const int RoadInfoMsg::kErrorFieldNumber;
const int RoadInfoMsg::kRoadBordersFieldNumber;
const int RoadInfoMsg::kLaneLinesFieldNumber;
const int RoadInfoMsg::kStopLinesFieldNumber;
const int RoadInfoMsg::kCrossingsFieldNumber;
const int RoadInfoMsg::kCameraIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RoadInfoMsg::RoadInfoMsg()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoMsg();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.RoadInfoMsg)
}
RoadInfoMsg::RoadInfoMsg(const RoadInfoMsg& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::autodrive::workflow::proto::MsgHeader(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_error()) {
    error_ = new ::autodrive::workflow::proto::Error(*from.error_);
  } else {
    error_ = NULL;
  }
  if (from.has_road_borders()) {
    road_borders_ = new ::autodrive::workflow::proto::RoadBorders(*from.road_borders_);
  } else {
    road_borders_ = NULL;
  }
  if (from.has_lane_lines()) {
    lane_lines_ = new ::autodrive::workflow::proto::RoadInfoLines(*from.lane_lines_);
  } else {
    lane_lines_ = NULL;
  }
  if (from.has_stop_lines()) {
    stop_lines_ = new ::autodrive::workflow::proto::StopLines(*from.stop_lines_);
  } else {
    stop_lines_ = NULL;
  }
  if (from.has_crossings()) {
    crossings_ = new ::autodrive::workflow::proto::Crossings(*from.crossings_);
  } else {
    crossings_ = NULL;
  }
  camera_id_ = from.camera_id_;
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.RoadInfoMsg)
}

void RoadInfoMsg::SharedCtor() {
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&camera_id_) -
      reinterpret_cast<char*>(&header_)) + sizeof(camera_id_));
  _cached_size_ = 0;
}

RoadInfoMsg::~RoadInfoMsg() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.RoadInfoMsg)
  SharedDtor();
}

void RoadInfoMsg::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete error_;
  if (this != internal_default_instance()) delete road_borders_;
  if (this != internal_default_instance()) delete lane_lines_;
  if (this != internal_default_instance()) delete stop_lines_;
  if (this != internal_default_instance()) delete crossings_;
}

void RoadInfoMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoadInfoMsg::descriptor() {
  ::protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RoadInfoMsg& RoadInfoMsg::default_instance() {
  ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoMsg();
  return *internal_default_instance();
}

RoadInfoMsg* RoadInfoMsg::New(::google::protobuf::Arena* arena) const {
  RoadInfoMsg* n = new RoadInfoMsg;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RoadInfoMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.RoadInfoMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
  if (GetArenaNoVirtual() == NULL && road_borders_ != NULL) {
    delete road_borders_;
  }
  road_borders_ = NULL;
  if (GetArenaNoVirtual() == NULL && lane_lines_ != NULL) {
    delete lane_lines_;
  }
  lane_lines_ = NULL;
  if (GetArenaNoVirtual() == NULL && stop_lines_ != NULL) {
    delete stop_lines_;
  }
  stop_lines_ = NULL;
  if (GetArenaNoVirtual() == NULL && crossings_ != NULL) {
    delete crossings_;
  }
  crossings_ = NULL;
  camera_id_ = 0;
  _internal_metadata_.Clear();
}

bool RoadInfoMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.RoadInfoMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.MsgHeader header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Error error = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_error()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadBorders road_borders = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_road_borders()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadInfoLines lane_lines = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lane_lines()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.StopLines stop_lines = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_stop_lines()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Crossings crossings = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_crossings()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 camera_id = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &camera_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.RoadInfoMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.RoadInfoMsg)
  return false;
#undef DO_
}

void RoadInfoMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.RoadInfoMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.MsgHeader header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .autodrive.workflow.proto.Error error = 2;
  if (this->has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->error_, output);
  }

  // .autodrive.workflow.proto.RoadBorders road_borders = 3;
  if (this->has_road_borders()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->road_borders_, output);
  }

  // .autodrive.workflow.proto.RoadInfoLines lane_lines = 4;
  if (this->has_lane_lines()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->lane_lines_, output);
  }

  // .autodrive.workflow.proto.StopLines stop_lines = 5;
  if (this->has_stop_lines()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->stop_lines_, output);
  }

  // .autodrive.workflow.proto.Crossings crossings = 6;
  if (this->has_crossings()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->crossings_, output);
  }

  // int32 camera_id = 7;
  if (this->camera_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->camera_id(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.RoadInfoMsg)
}

::google::protobuf::uint8* RoadInfoMsg::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.RoadInfoMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.MsgHeader header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->header_, deterministic, target);
  }

  // .autodrive.workflow.proto.Error error = 2;
  if (this->has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->error_, deterministic, target);
  }

  // .autodrive.workflow.proto.RoadBorders road_borders = 3;
  if (this->has_road_borders()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->road_borders_, deterministic, target);
  }

  // .autodrive.workflow.proto.RoadInfoLines lane_lines = 4;
  if (this->has_lane_lines()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, *this->lane_lines_, deterministic, target);
  }

  // .autodrive.workflow.proto.StopLines stop_lines = 5;
  if (this->has_stop_lines()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, *this->stop_lines_, deterministic, target);
  }

  // .autodrive.workflow.proto.Crossings crossings = 6;
  if (this->has_crossings()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, *this->crossings_, deterministic, target);
  }

  // int32 camera_id = 7;
  if (this->camera_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->camera_id(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.RoadInfoMsg)
  return target;
}

size_t RoadInfoMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.RoadInfoMsg)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .autodrive.workflow.proto.MsgHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->header_);
  }

  // .autodrive.workflow.proto.Error error = 2;
  if (this->has_error()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->error_);
  }

  // .autodrive.workflow.proto.RoadBorders road_borders = 3;
  if (this->has_road_borders()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->road_borders_);
  }

  // .autodrive.workflow.proto.RoadInfoLines lane_lines = 4;
  if (this->has_lane_lines()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->lane_lines_);
  }

  // .autodrive.workflow.proto.StopLines stop_lines = 5;
  if (this->has_stop_lines()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->stop_lines_);
  }

  // .autodrive.workflow.proto.Crossings crossings = 6;
  if (this->has_crossings()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->crossings_);
  }

  // int32 camera_id = 7;
  if (this->camera_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->camera_id());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoadInfoMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.RoadInfoMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const RoadInfoMsg* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RoadInfoMsg>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.RoadInfoMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.RoadInfoMsg)
    MergeFrom(*source);
  }
}

void RoadInfoMsg::MergeFrom(const RoadInfoMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.RoadInfoMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    mutable_header()->::autodrive::workflow::proto::MsgHeader::MergeFrom(from.header());
  }
  if (from.has_error()) {
    mutable_error()->::autodrive::workflow::proto::Error::MergeFrom(from.error());
  }
  if (from.has_road_borders()) {
    mutable_road_borders()->::autodrive::workflow::proto::RoadBorders::MergeFrom(from.road_borders());
  }
  if (from.has_lane_lines()) {
    mutable_lane_lines()->::autodrive::workflow::proto::RoadInfoLines::MergeFrom(from.lane_lines());
  }
  if (from.has_stop_lines()) {
    mutable_stop_lines()->::autodrive::workflow::proto::StopLines::MergeFrom(from.stop_lines());
  }
  if (from.has_crossings()) {
    mutable_crossings()->::autodrive::workflow::proto::Crossings::MergeFrom(from.crossings());
  }
  if (from.camera_id() != 0) {
    set_camera_id(from.camera_id());
  }
}

void RoadInfoMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.RoadInfoMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoadInfoMsg::CopyFrom(const RoadInfoMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.RoadInfoMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadInfoMsg::IsInitialized() const {
  return true;
}

void RoadInfoMsg::Swap(RoadInfoMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RoadInfoMsg::InternalSwap(RoadInfoMsg* other) {
  using std::swap;
  swap(header_, other->header_);
  swap(error_, other->error_);
  swap(road_borders_, other->road_borders_);
  swap(lane_lines_, other->lane_lines_);
  swap(stop_lines_, other->stop_lines_);
  swap(crossings_, other->crossings_);
  swap(camera_id_, other->camera_id_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RoadInfoMsg::GetMetadata() const {
  protobuf_road_5finfo_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_road_5finfo_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

// @@protoc_insertion_point(global_scope)
