// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map_display.proto

#include "map_display.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace autodrive {
namespace workflow {
namespace proto {
class SingleTrajPointDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SingleTrajPoint>
      _instance;
} _SingleTrajPoint_default_instance_;
class GlbTrajectoryDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GlbTrajectory>
      _instance;
} _GlbTrajectory_default_instance_;
class GlbPrkgSlotDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GlbPrkgSlot>
      _instance;
} _GlbPrkgSlot_default_instance_;
class GlbPrcpPrkgSlotsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GlbPrcpPrkgSlots>
      _instance;
} _GlbPrcpPrkgSlots_default_instance_;
class GlbRoadMarkDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GlbRoadMark>
      _instance;
} _GlbRoadMark_default_instance_;
class GlbRoadMakMapDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GlbRoadMakMap>
      _instance;
} _GlbRoadMakMap_default_instance_;
class GlbObstacleDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GlbObstacle>
      _instance;
} _GlbObstacle_default_instance_;
class GlbPrcpObstacleDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GlbPrcpObstacle>
      _instance;
} _GlbPrcpObstacle_default_instance_;
class MapCommonHeaderDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MapCommonHeader>
      _instance;
} _MapCommonHeader_default_instance_;
class MapInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MapInfo>
      _instance;
} _MapInfo_default_instance_;
class MapDisplayMsgDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<MapDisplayMsg>
      _instance;
} _MapDisplayMsg_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace protobuf_map_5fdisplay_2eproto {
void InitDefaultsSingleTrajPointImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector3f();
  {
    void* ptr = &::autodrive::workflow::proto::_SingleTrajPoint_default_instance_;
    new (ptr) ::autodrive::workflow::proto::SingleTrajPoint();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::SingleTrajPoint::InitAsDefaultInstance();
}

void InitDefaultsSingleTrajPoint() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsSingleTrajPointImpl);
}

void InitDefaultsGlbTrajectoryImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_map_5fdisplay_2eproto::InitDefaultsSingleTrajPoint();
  protobuf_basic_2eproto::InitDefaultsVector3f();
  {
    void* ptr = &::autodrive::workflow::proto::_GlbTrajectory_default_instance_;
    new (ptr) ::autodrive::workflow::proto::GlbTrajectory();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::GlbTrajectory::InitAsDefaultInstance();
}

void InitDefaultsGlbTrajectory() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsGlbTrajectoryImpl);
}

void InitDefaultsGlbPrkgSlotImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector3f();
  {
    void* ptr = &::autodrive::workflow::proto::_GlbPrkgSlot_default_instance_;
    new (ptr) ::autodrive::workflow::proto::GlbPrkgSlot();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::GlbPrkgSlot::InitAsDefaultInstance();
}

void InitDefaultsGlbPrkgSlot() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsGlbPrkgSlotImpl);
}

void InitDefaultsGlbPrcpPrkgSlotsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_map_5fdisplay_2eproto::InitDefaultsGlbPrkgSlot();
  {
    void* ptr = &::autodrive::workflow::proto::_GlbPrcpPrkgSlots_default_instance_;
    new (ptr) ::autodrive::workflow::proto::GlbPrcpPrkgSlots();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::GlbPrcpPrkgSlots::InitAsDefaultInstance();
}

void InitDefaultsGlbPrcpPrkgSlots() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsGlbPrcpPrkgSlotsImpl);
}

void InitDefaultsGlbRoadMarkImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector3f();
  protobuf_basic_2eproto::InitDefaultsVector2f();
  {
    void* ptr = &::autodrive::workflow::proto::_GlbRoadMark_default_instance_;
    new (ptr) ::autodrive::workflow::proto::GlbRoadMark();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::GlbRoadMark::InitAsDefaultInstance();
}

void InitDefaultsGlbRoadMark() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsGlbRoadMarkImpl);
}

void InitDefaultsGlbRoadMakMapImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_map_5fdisplay_2eproto::InitDefaultsGlbRoadMark();
  {
    void* ptr = &::autodrive::workflow::proto::_GlbRoadMakMap_default_instance_;
    new (ptr) ::autodrive::workflow::proto::GlbRoadMakMap();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::GlbRoadMakMap::InitAsDefaultInstance();
}

void InitDefaultsGlbRoadMakMap() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsGlbRoadMakMapImpl);
}

void InitDefaultsGlbObstacleImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector3f();
  protobuf_basic_2eproto::InitDefaultsVector2f();
  {
    void* ptr = &::autodrive::workflow::proto::_GlbObstacle_default_instance_;
    new (ptr) ::autodrive::workflow::proto::GlbObstacle();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::GlbObstacle::InitAsDefaultInstance();
}

void InitDefaultsGlbObstacle() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsGlbObstacleImpl);
}

void InitDefaultsGlbPrcpObstacleImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_map_5fdisplay_2eproto::InitDefaultsGlbObstacle();
  {
    void* ptr = &::autodrive::workflow::proto::_GlbPrcpObstacle_default_instance_;
    new (ptr) ::autodrive::workflow::proto::GlbPrcpObstacle();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::GlbPrcpObstacle::InitAsDefaultInstance();
}

void InitDefaultsGlbPrcpObstacle() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsGlbPrcpObstacleImpl);
}

void InitDefaultsMapCommonHeaderImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector2f();
  {
    void* ptr = &::autodrive::workflow::proto::_MapCommonHeader_default_instance_;
    new (ptr) ::autodrive::workflow::proto::MapCommonHeader();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::MapCommonHeader::InitAsDefaultInstance();
}

void InitDefaultsMapCommonHeader() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsMapCommonHeaderImpl);
}

void InitDefaultsMapInfoImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_map_5fdisplay_2eproto::InitDefaultsMapCommonHeader();
  protobuf_map_5fdisplay_2eproto::InitDefaultsGlbTrajectory();
  protobuf_map_5fdisplay_2eproto::InitDefaultsGlbPrcpPrkgSlots();
  protobuf_map_5fdisplay_2eproto::InitDefaultsGlbRoadMakMap();
  protobuf_map_5fdisplay_2eproto::InitDefaultsGlbPrcpObstacle();
  {
    void* ptr = &::autodrive::workflow::proto::_MapInfo_default_instance_;
    new (ptr) ::autodrive::workflow::proto::MapInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::MapInfo::InitAsDefaultInstance();
}

void InitDefaultsMapInfo() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsMapInfoImpl);
}

void InitDefaultsMapDisplayMsgImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_common_2eproto::InitDefaultsMsgHeader();
  protobuf_common_2eproto::InitDefaultsError();
  protobuf_map_5fdisplay_2eproto::InitDefaultsMapInfo();
  protobuf_map_5fdisplay_2eproto::InitDefaultsMapCommonHeader();
  {
    void* ptr = &::autodrive::workflow::proto::_MapDisplayMsg_default_instance_;
    new (ptr) ::autodrive::workflow::proto::MapDisplayMsg();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::MapDisplayMsg::InitAsDefaultInstance();
}

void InitDefaultsMapDisplayMsg() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsMapDisplayMsgImpl);
}

::google::protobuf::Metadata file_level_metadata[11];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[7];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::SingleTrajPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::SingleTrajPoint, point_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::SingleTrajPoint, floor_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbTrajectory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbTrajectory, glb_trajectory_point_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbTrajectory, start_point_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbTrajectory, end_point_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrkgSlot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrkgSlot, slot_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrkgSlot, slot_status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrkgSlot, slot_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrkgSlot, slot_points_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrkgSlot, is_target_slot_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrkgSlot, has_lever_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrkgSlot, lever_start_point_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrkgSlot, lever_end_point_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrkgSlot, floor_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrcpPrkgSlots, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrcpPrkgSlots, glb_prkg_slots_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbRoadMark, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbRoadMark, position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbRoadMark, odom_heading_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbRoadMark, roadmark_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbRoadMark, roadmark_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbRoadMark, border_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbRoadMark, floor_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbRoadMakMap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbRoadMakMap, glb_road_mak_map_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbObstacle, center_position_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbObstacle, odom_heading_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbObstacle, obstacle_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbObstacle, danger_level_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbObstacle, target_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbObstacle, border_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbObstacle, obj_status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbObstacle, floor_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrcpObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::GlbPrcpObstacle, glb_prcp_obstacle_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapCommonHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapCommonHeader, map_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapCommonHeader, map_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapCommonHeader, utc_time_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapCommonHeader, latitude_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapCommonHeader, longitude_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapCommonHeader, glb_trajectory_point_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapCommonHeader, map_total_height_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapCommonHeader, map_total_floor_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapCommonHeader, slot_parking_times_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapInfo, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapInfo, global_trajectory_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapInfo, global_percep_parking_slots_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapInfo, global_road_mark_map_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapInfo, global_perception_obstacle_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapInfo, map_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapInfo, rest_map_distance_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapInfo, num_speed_bumps_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapDisplayMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapDisplayMsg, header_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapDisplayMsg, error_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapDisplayMsg, map_info_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapDisplayMsg, update_map_info_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::MapDisplayMsg, all_map_headers_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::autodrive::workflow::proto::SingleTrajPoint)},
  { 7, -1, sizeof(::autodrive::workflow::proto::GlbTrajectory)},
  { 15, -1, sizeof(::autodrive::workflow::proto::GlbPrkgSlot)},
  { 29, -1, sizeof(::autodrive::workflow::proto::GlbPrcpPrkgSlots)},
  { 35, -1, sizeof(::autodrive::workflow::proto::GlbRoadMark)},
  { 46, -1, sizeof(::autodrive::workflow::proto::GlbRoadMakMap)},
  { 52, -1, sizeof(::autodrive::workflow::proto::GlbObstacle)},
  { 65, -1, sizeof(::autodrive::workflow::proto::GlbPrcpObstacle)},
  { 71, -1, sizeof(::autodrive::workflow::proto::MapCommonHeader)},
  { 85, -1, sizeof(::autodrive::workflow::proto::MapInfo)},
  { 98, -1, sizeof(::autodrive::workflow::proto::MapDisplayMsg)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_SingleTrajPoint_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_GlbTrajectory_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_GlbPrkgSlot_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_GlbPrcpPrkgSlots_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_GlbRoadMark_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_GlbRoadMakMap_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_GlbObstacle_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_GlbPrcpObstacle_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_MapCommonHeader_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_MapInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::_MapDisplayMsg_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "map_display.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 11);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\021map_display.proto\022\030autodrive.workflow."
      "proto\032\014common.proto\032\013basic.proto\"S\n\017Sing"
      "leTrajPoint\0221\n\005point\030\001 \001(\0132\".autodrive.w"
      "orkflow.proto.Vector3f\022\r\n\005floor\030\002 \001(\002\"\310\001"
      "\n\rGlbTrajectory\022G\n\024glb_trajectory_point\030"
      "\001 \003(\0132).autodrive.workflow.proto.SingleT"
      "rajPoint\0227\n\013start_point\030\002 \001(\0132\".autodriv"
      "e.workflow.proto.Vector3f\0225\n\tend_point\030\003"
      " \001(\0132\".autodrive.workflow.proto.Vector3f"
      "\"\377\002\n\013GlbPrkgSlot\022\017\n\007slot_id\030\001 \001(\r\0229\n\013slo"
      "t_status\030\002 \001(\0162$.autodrive.workflow.prot"
      "o.SlotStatus\0225\n\tslot_type\030\003 \001(\0162\".autodr"
      "ive.workflow.proto.SlotType\0227\n\013slot_poin"
      "ts\030\004 \003(\0132\".autodrive.workflow.proto.Vect"
      "or3f\022\026\n\016is_target_slot\030\005 \001(\010\022\021\n\thas_leve"
      "r\030\006 \001(\010\022=\n\021lever_start_point\030\007 \001(\0132\".aut"
      "odrive.workflow.proto.Vector3f\022;\n\017lever_"
      "end_point\030\010 \001(\0132\".autodrive.workflow.pro"
      "to.Vector3f\022\r\n\005floor\030\t \001(\002\"Q\n\020GlbPrcpPrk"
      "gSlots\022=\n\016glb_prkg_slots\030\001 \003(\0132%.autodri"
      "ve.workflow.proto.GlbPrkgSlot\"\360\001\n\013GlbRoa"
      "dMark\0224\n\010position\030\001 \001(\0132\".autodrive.work"
      "flow.proto.Vector3f\022\024\n\014odom_heading\030\002 \001("
      "\002\022\023\n\013roadmark_id\030\003 \001(\r\022=\n\rroadmark_type\030"
      "\004 \001(\0162&.autodrive.workflow.proto.RoadMar"
      "kType\0222\n\006border\030\005 \003(\0132\".autodrive.workfl"
      "ow.proto.Vector2f\022\r\n\005floor\030\006 \001(\002\"P\n\rGlbR"
      "oadMakMap\022\?\n\020glb_road_mak_map\030\001 \003(\0132%.au"
      "todrive.workflow.proto.GlbRoadMark\"\362\002\n\013G"
      "lbObstacle\022;\n\017center_position\030\001 \001(\0132\".au"
      "todrive.workflow.proto.Vector3f\022\024\n\014odom_"
      "heading\030\002 \001(\002\022D\n\robstacle_type\030\003 \001(\0162-.a"
      "utodrive.workflow.proto.Map2HmiObstacleT"
      "ype\022;\n\014danger_level\030\004 \001(\0162%.autodrive.wo"
      "rkflow.proto.DangerLevel\022\021\n\ttarget_id\030\005 "
      "\001(\r\0222\n\006border\030\006 \003(\0132\".autodrive.workflow"
      ".proto.Vector2f\0227\n\nobj_status\030\007 \001(\0162#.au"
      "todrive.workflow.proto.ObjStatus\022\r\n\005floo"
      "r\030\010 \001(\002\"S\n\017GlbPrcpObstacle\022@\n\021glb_prcp_o"
      "bstacle\030\001 \003(\0132%.autodrive.workflow.proto"
      ".GlbObstacle\"\242\002\n\017MapCommonHeader\022\016\n\006map_"
      "id\030\001 \001(\005\0227\n\010map_type\030\002 \001(\0162%.autodrive.w"
      "orkflow.proto.MapDataType\022\020\n\010utc_time\030\003 "
      "\001(\004\022\020\n\010latitude\030\004 \001(\005\022\021\n\tlongitude\030\005 \001(\005"
      "\022@\n\024glb_trajectory_point\030\006 \003(\0132\".autodri"
      "ve.workflow.proto.Vector2f\022\030\n\020map_total_"
      "height\030\007 \001(\002\022\027\n\017map_total_floor\030\010 \001(\002\022\032\n"
      "\022slot_parking_times\030\t \001(\005\"\271\003\n\007MapInfo\0229\n"
      "\006header\030\001 \001(\0132).autodrive.workflow.proto"
      ".MapCommonHeader\022B\n\021global_trajectory\030\002 "
      "\001(\0132\'.autodrive.workflow.proto.GlbTrajec"
      "tory\022O\n\033global_percep_parking_slots\030\003 \001("
      "\0132*.autodrive.workflow.proto.GlbPrcpPrkg"
      "Slots\022E\n\024global_road_mark_map\030\004 \001(\0132\'.au"
      "todrive.workflow.proto.GlbRoadMakMap\022M\n\032"
      "global_perception_obstacle\030\005 \001(\0132).autod"
      "rive.workflow.proto.GlbPrcpObstacle\022\024\n\014m"
      "ap_distance\030\006 \001(\002\022\031\n\021rest_map_distance\030\007"
      " \001(\002\022\027\n\017num_speed_bumps\030\010 \001(\r\"\206\002\n\rMapDis"
      "playMsg\0223\n\006header\030\001 \001(\0132#.autodrive.work"
      "flow.proto.MsgHeader\022.\n\005error\030\002 \001(\0132\037.au"
      "todrive.workflow.proto.Error\0223\n\010map_info"
      "\030\003 \001(\0132!.autodrive.workflow.proto.MapInf"
      "o\022\027\n\017update_map_info\030\004 \001(\010\022B\n\017all_map_he"
      "aders\030\005 \003(\0132).autodrive.workflow.proto.M"
      "apCommonHeader*F\n\010SlotType\022\014\n\010kReserve\020\000"
      "\022\r\n\tkVertical\020\001\022\017\n\013kHorizontal\020\002\022\014\n\010kObl"
      "ique\020\003*\377\001\n\nSlotStatus\022\023\n\017kSlotStatusEmpy"
      "\020\000\022\026\n\022kSlotStatusUnknown\020\001\022\036\n\032kSlotStatu"
      "sPedestrianOcupy\020\002\022!\n\035kSlotStatusTwowhee"
      "lscartOcupy\020\003\022\036\n\032kSlotStatusConebarrelOc"
      "upy\020\004\022\035\n\031kSlotStatusFloorlockOcupy\020\005\022\036\n\032"
      "kSlotStatusNoparksignOcupy\020\006\022\"\n\036kSlotSta"
      "tusOtherObstaclesOcupy\020\007*\243\004\n\014RoadMarkTyp"
      "e\022\031\n\025kRoadMarkTypeReserved\020\000\022\r\n\tkStraigh"
      "t\020\002\022\017\n\013kStrOrTurnL\020\003\022\017\n\013kStrOrTurnR\020\004\022\017\n"
      "\013kStrOrTurnA\020\005\022\016\n\nkTurinLeft\020\006\022\021\n\rkTurnL"
      "OrTurnA\020\007\022\021\n\rkTurnLOrLConf\020\010\022\n\n\006kTurnR\020\t"
      "\022\021\n\rkTurnROrRConf\020\n\022\013\n\007kTurnLR\020\013\022\n\n\006kTur"
      "nA\020\014\022\016\n\nkTurnLForb\020\r\022\016\n\nkTurnRForb\020\016\022\016\n\n"
      "kTurnAForb\020\017\022\026\n\022kStrOrTurnLOrTrunR\020\020\022\026\n\022"
      "kStrOrTurnLOrTrunA\020\021\022\021\n\rkTurnROrTurnA\020\022\022"
      "\021\n\rkDistConfLine\020\026\022\022\n\016kStopyieldLine\020\027\022\023"
      "\n\017kDecelyieldLine\020\030\022\r\n\tkStopline\020\031\022\017\n\013kN"
      "oParkArea\020\032\022\016\n\nkCrossWalk\020\033\022\022\n\016kSolidLan"
      "eLine\020\034\022\023\n\017kDashedLaneLine\020\035\022\022\n\016kZebraCr"
      "ossing\020\036\022\r\n\tkGridLine\020\037\022\020\n\014kLeadingLine\020"
      " \022\013\n\007kOthers\020c*C\n\013DangerLevel\022\r\n\tkNoDang"
      "er\020\000\022\013\n\007kLevel1\020\001\022\013\n\007kLevel2\020\002\022\013\n\007kLevel"
      "3\020\003*\315\003\n\023Map2HmiObstacleType\022 \n\034kMap2HmiO"
      "bstacleTypeReserved\020\000\022$\n kMap2HmiObstacl"
      "eTypeWheelStopper\020\001\022#\n\037kMap2HmiObstacleT"
      "ypeParkingLock\020\002\022\037\n\033kMap2HmiObstacleType"
      "Pillars\020\003\022!\n\035kMap2HmiObstacleTypeSpeedBu"
      "mp\020\004\022\037\n\033kMap2HmiObstacleTypeFireBox\020\005\022)\n"
      "%kMap2HmiObstacleTypeAnticollisionBall\020\006"
      "\022!\n\035kMap2HmiObstacleTypeReflector\020\007\022!\n\035k"
      "Map2HmiObstacleTypeCurbStone\020\010\022#\n\037kMap2H"
      "miObstacleTypeTrafficCone\020\t\022)\n%kMap2HmiO"
      "bstacleTypeParkingAFrameSign\020\n\022#\n\037kMap2H"
      "miObstacleTypeParkingGate\020\013*8\n\tObjStatus"
      "\022\014\n\010kUnknown\020\000\022\r\n\tkGateOpen\020\001\022\016\n\nkGateCl"
      "ose\020\002*/\n\013MapDataType\022\020\n\014kRealTimeMap\020\000\022\016"
      "\n\nkStoredMap\020\001b\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 4142);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "map_display.proto", &protobuf_RegisterTypes);
  ::protobuf_common_2eproto::AddDescriptors();
  ::protobuf_basic_2eproto::AddDescriptors();
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_map_5fdisplay_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
const ::google::protobuf::EnumDescriptor* SlotType_descriptor() {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_map_5fdisplay_2eproto::file_level_enum_descriptors[0];
}
bool SlotType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SlotStatus_descriptor() {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_map_5fdisplay_2eproto::file_level_enum_descriptors[1];
}
bool SlotStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RoadMarkType_descriptor() {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_map_5fdisplay_2eproto::file_level_enum_descriptors[2];
}
bool RoadMarkType_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 99:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* DangerLevel_descriptor() {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_map_5fdisplay_2eproto::file_level_enum_descriptors[3];
}
bool DangerLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Map2HmiObstacleType_descriptor() {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_map_5fdisplay_2eproto::file_level_enum_descriptors[4];
}
bool Map2HmiObstacleType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ObjStatus_descriptor() {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_map_5fdisplay_2eproto::file_level_enum_descriptors[5];
}
bool ObjStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* MapDataType_descriptor() {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_map_5fdisplay_2eproto::file_level_enum_descriptors[6];
}
bool MapDataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void SingleTrajPoint::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_SingleTrajPoint_default_instance_._instance.get_mutable()->point_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
}
void SingleTrajPoint::clear_point() {
  if (GetArenaNoVirtual() == NULL && point_ != NULL) {
    delete point_;
  }
  point_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SingleTrajPoint::kPointFieldNumber;
const int SingleTrajPoint::kFloorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SingleTrajPoint::SingleTrajPoint()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsSingleTrajPoint();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.SingleTrajPoint)
}
SingleTrajPoint::SingleTrajPoint(const SingleTrajPoint& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_point()) {
    point_ = new ::autodrive::workflow::proto::Vector3f(*from.point_);
  } else {
    point_ = NULL;
  }
  floor_ = from.floor_;
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.SingleTrajPoint)
}

void SingleTrajPoint::SharedCtor() {
  ::memset(&point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&floor_) -
      reinterpret_cast<char*>(&point_)) + sizeof(floor_));
  _cached_size_ = 0;
}

SingleTrajPoint::~SingleTrajPoint() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.SingleTrajPoint)
  SharedDtor();
}

void SingleTrajPoint::SharedDtor() {
  if (this != internal_default_instance()) delete point_;
}

void SingleTrajPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SingleTrajPoint::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const SingleTrajPoint& SingleTrajPoint::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsSingleTrajPoint();
  return *internal_default_instance();
}

SingleTrajPoint* SingleTrajPoint::New(::google::protobuf::Arena* arena) const {
  SingleTrajPoint* n = new SingleTrajPoint;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SingleTrajPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.SingleTrajPoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && point_ != NULL) {
    delete point_;
  }
  point_ = NULL;
  floor_ = 0;
  _internal_metadata_.Clear();
}

bool SingleTrajPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.SingleTrajPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.Vector3f point = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float floor = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u /* 21 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &floor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.SingleTrajPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.SingleTrajPoint)
  return false;
#undef DO_
}

void SingleTrajPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.SingleTrajPoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f point = 1;
  if (this->has_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->point_, output);
  }

  // float floor = 2;
  if (this->floor() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->floor(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.SingleTrajPoint)
}

::google::protobuf::uint8* SingleTrajPoint::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.SingleTrajPoint)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f point = 1;
  if (this->has_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->point_, deterministic, target);
  }

  // float floor = 2;
  if (this->floor() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->floor(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.SingleTrajPoint)
  return target;
}

size_t SingleTrajPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.SingleTrajPoint)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .autodrive.workflow.proto.Vector3f point = 1;
  if (this->has_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->point_);
  }

  // float floor = 2;
  if (this->floor() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SingleTrajPoint::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.SingleTrajPoint)
  GOOGLE_DCHECK_NE(&from, this);
  const SingleTrajPoint* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SingleTrajPoint>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.SingleTrajPoint)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.SingleTrajPoint)
    MergeFrom(*source);
  }
}

void SingleTrajPoint::MergeFrom(const SingleTrajPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.SingleTrajPoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_point()) {
    mutable_point()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.point());
  }
  if (from.floor() != 0) {
    set_floor(from.floor());
  }
}

void SingleTrajPoint::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.SingleTrajPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SingleTrajPoint::CopyFrom(const SingleTrajPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.SingleTrajPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SingleTrajPoint::IsInitialized() const {
  return true;
}

void SingleTrajPoint::Swap(SingleTrajPoint* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SingleTrajPoint::InternalSwap(SingleTrajPoint* other) {
  using std::swap;
  swap(point_, other->point_);
  swap(floor_, other->floor_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SingleTrajPoint::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void GlbTrajectory::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_GlbTrajectory_default_instance_._instance.get_mutable()->start_point_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
  ::autodrive::workflow::proto::_GlbTrajectory_default_instance_._instance.get_mutable()->end_point_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
}
void GlbTrajectory::clear_start_point() {
  if (GetArenaNoVirtual() == NULL && start_point_ != NULL) {
    delete start_point_;
  }
  start_point_ = NULL;
}
void GlbTrajectory::clear_end_point() {
  if (GetArenaNoVirtual() == NULL && end_point_ != NULL) {
    delete end_point_;
  }
  end_point_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GlbTrajectory::kGlbTrajectoryPointFieldNumber;
const int GlbTrajectory::kStartPointFieldNumber;
const int GlbTrajectory::kEndPointFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GlbTrajectory::GlbTrajectory()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbTrajectory();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.GlbTrajectory)
}
GlbTrajectory::GlbTrajectory(const GlbTrajectory& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      glb_trajectory_point_(from.glb_trajectory_point_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_start_point()) {
    start_point_ = new ::autodrive::workflow::proto::Vector3f(*from.start_point_);
  } else {
    start_point_ = NULL;
  }
  if (from.has_end_point()) {
    end_point_ = new ::autodrive::workflow::proto::Vector3f(*from.end_point_);
  } else {
    end_point_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.GlbTrajectory)
}

void GlbTrajectory::SharedCtor() {
  ::memset(&start_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&end_point_) -
      reinterpret_cast<char*>(&start_point_)) + sizeof(end_point_));
  _cached_size_ = 0;
}

GlbTrajectory::~GlbTrajectory() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.GlbTrajectory)
  SharedDtor();
}

void GlbTrajectory::SharedDtor() {
  if (this != internal_default_instance()) delete start_point_;
  if (this != internal_default_instance()) delete end_point_;
}

void GlbTrajectory::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GlbTrajectory::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GlbTrajectory& GlbTrajectory::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbTrajectory();
  return *internal_default_instance();
}

GlbTrajectory* GlbTrajectory::New(::google::protobuf::Arena* arena) const {
  GlbTrajectory* n = new GlbTrajectory;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GlbTrajectory::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.GlbTrajectory)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  glb_trajectory_point_.Clear();
  if (GetArenaNoVirtual() == NULL && start_point_ != NULL) {
    delete start_point_;
  }
  start_point_ = NULL;
  if (GetArenaNoVirtual() == NULL && end_point_ != NULL) {
    delete end_point_;
  }
  end_point_ = NULL;
  _internal_metadata_.Clear();
}

bool GlbTrajectory::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.GlbTrajectory)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .autodrive.workflow.proto.SingleTrajPoint glb_trajectory_point = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_glb_trajectory_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Vector3f start_point = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_start_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Vector3f end_point = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_end_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.GlbTrajectory)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.GlbTrajectory)
  return false;
#undef DO_
}

void GlbTrajectory::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.GlbTrajectory)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.SingleTrajPoint glb_trajectory_point = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->glb_trajectory_point_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->glb_trajectory_point(static_cast<int>(i)), output);
  }

  // .autodrive.workflow.proto.Vector3f start_point = 2;
  if (this->has_start_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->start_point_, output);
  }

  // .autodrive.workflow.proto.Vector3f end_point = 3;
  if (this->has_end_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->end_point_, output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.GlbTrajectory)
}

::google::protobuf::uint8* GlbTrajectory::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.GlbTrajectory)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.SingleTrajPoint glb_trajectory_point = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->glb_trajectory_point_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->glb_trajectory_point(static_cast<int>(i)), deterministic, target);
  }

  // .autodrive.workflow.proto.Vector3f start_point = 2;
  if (this->has_start_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->start_point_, deterministic, target);
  }

  // .autodrive.workflow.proto.Vector3f end_point = 3;
  if (this->has_end_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->end_point_, deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.GlbTrajectory)
  return target;
}

size_t GlbTrajectory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.GlbTrajectory)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.SingleTrajPoint glb_trajectory_point = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->glb_trajectory_point_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->glb_trajectory_point(static_cast<int>(i)));
    }
  }

  // .autodrive.workflow.proto.Vector3f start_point = 2;
  if (this->has_start_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->start_point_);
  }

  // .autodrive.workflow.proto.Vector3f end_point = 3;
  if (this->has_end_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->end_point_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlbTrajectory::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.GlbTrajectory)
  GOOGLE_DCHECK_NE(&from, this);
  const GlbTrajectory* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GlbTrajectory>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.GlbTrajectory)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.GlbTrajectory)
    MergeFrom(*source);
  }
}

void GlbTrajectory::MergeFrom(const GlbTrajectory& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.GlbTrajectory)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  glb_trajectory_point_.MergeFrom(from.glb_trajectory_point_);
  if (from.has_start_point()) {
    mutable_start_point()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.start_point());
  }
  if (from.has_end_point()) {
    mutable_end_point()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.end_point());
  }
}

void GlbTrajectory::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.GlbTrajectory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GlbTrajectory::CopyFrom(const GlbTrajectory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.GlbTrajectory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlbTrajectory::IsInitialized() const {
  return true;
}

void GlbTrajectory::Swap(GlbTrajectory* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GlbTrajectory::InternalSwap(GlbTrajectory* other) {
  using std::swap;
  glb_trajectory_point_.InternalSwap(&other->glb_trajectory_point_);
  swap(start_point_, other->start_point_);
  swap(end_point_, other->end_point_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GlbTrajectory::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void GlbPrkgSlot::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_GlbPrkgSlot_default_instance_._instance.get_mutable()->lever_start_point_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
  ::autodrive::workflow::proto::_GlbPrkgSlot_default_instance_._instance.get_mutable()->lever_end_point_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
}
void GlbPrkgSlot::clear_slot_points() {
  slot_points_.Clear();
}
void GlbPrkgSlot::clear_lever_start_point() {
  if (GetArenaNoVirtual() == NULL && lever_start_point_ != NULL) {
    delete lever_start_point_;
  }
  lever_start_point_ = NULL;
}
void GlbPrkgSlot::clear_lever_end_point() {
  if (GetArenaNoVirtual() == NULL && lever_end_point_ != NULL) {
    delete lever_end_point_;
  }
  lever_end_point_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GlbPrkgSlot::kSlotIdFieldNumber;
const int GlbPrkgSlot::kSlotStatusFieldNumber;
const int GlbPrkgSlot::kSlotTypeFieldNumber;
const int GlbPrkgSlot::kSlotPointsFieldNumber;
const int GlbPrkgSlot::kIsTargetSlotFieldNumber;
const int GlbPrkgSlot::kHasLeverFieldNumber;
const int GlbPrkgSlot::kLeverStartPointFieldNumber;
const int GlbPrkgSlot::kLeverEndPointFieldNumber;
const int GlbPrkgSlot::kFloorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GlbPrkgSlot::GlbPrkgSlot()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbPrkgSlot();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.GlbPrkgSlot)
}
GlbPrkgSlot::GlbPrkgSlot(const GlbPrkgSlot& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      slot_points_(from.slot_points_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_lever_start_point()) {
    lever_start_point_ = new ::autodrive::workflow::proto::Vector3f(*from.lever_start_point_);
  } else {
    lever_start_point_ = NULL;
  }
  if (from.has_lever_end_point()) {
    lever_end_point_ = new ::autodrive::workflow::proto::Vector3f(*from.lever_end_point_);
  } else {
    lever_end_point_ = NULL;
  }
  ::memcpy(&slot_id_, &from.slot_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&floor_) -
    reinterpret_cast<char*>(&slot_id_)) + sizeof(floor_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.GlbPrkgSlot)
}

void GlbPrkgSlot::SharedCtor() {
  ::memset(&lever_start_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&floor_) -
      reinterpret_cast<char*>(&lever_start_point_)) + sizeof(floor_));
  _cached_size_ = 0;
}

GlbPrkgSlot::~GlbPrkgSlot() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.GlbPrkgSlot)
  SharedDtor();
}

void GlbPrkgSlot::SharedDtor() {
  if (this != internal_default_instance()) delete lever_start_point_;
  if (this != internal_default_instance()) delete lever_end_point_;
}

void GlbPrkgSlot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GlbPrkgSlot::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GlbPrkgSlot& GlbPrkgSlot::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbPrkgSlot();
  return *internal_default_instance();
}

GlbPrkgSlot* GlbPrkgSlot::New(::google::protobuf::Arena* arena) const {
  GlbPrkgSlot* n = new GlbPrkgSlot;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GlbPrkgSlot::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.GlbPrkgSlot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  slot_points_.Clear();
  if (GetArenaNoVirtual() == NULL && lever_start_point_ != NULL) {
    delete lever_start_point_;
  }
  lever_start_point_ = NULL;
  if (GetArenaNoVirtual() == NULL && lever_end_point_ != NULL) {
    delete lever_end_point_;
  }
  lever_end_point_ = NULL;
  ::memset(&slot_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&floor_) -
      reinterpret_cast<char*>(&slot_id_)) + sizeof(floor_));
  _internal_metadata_.Clear();
}

bool GlbPrkgSlot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.GlbPrkgSlot)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 slot_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &slot_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.SlotStatus slot_status = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_slot_status(static_cast< ::autodrive::workflow::proto::SlotStatus >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.SlotType slot_type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_slot_type(static_cast< ::autodrive::workflow::proto::SlotType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.Vector3f slot_points = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_slot_points()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool is_target_slot = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_target_slot_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool has_lever = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_lever_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Vector3f lever_start_point = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lever_start_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Vector3f lever_end_point = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_lever_end_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float floor = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(77u /* 77 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &floor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.GlbPrkgSlot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.GlbPrkgSlot)
  return false;
#undef DO_
}

void GlbPrkgSlot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.GlbPrkgSlot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 slot_id = 1;
  if (this->slot_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->slot_id(), output);
  }

  // .autodrive.workflow.proto.SlotStatus slot_status = 2;
  if (this->slot_status() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->slot_status(), output);
  }

  // .autodrive.workflow.proto.SlotType slot_type = 3;
  if (this->slot_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->slot_type(), output);
  }

  // repeated .autodrive.workflow.proto.Vector3f slot_points = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->slot_points_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->slot_points(static_cast<int>(i)), output);
  }

  // bool is_target_slot = 5;
  if (this->is_target_slot() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->is_target_slot(), output);
  }

  // bool has_lever = 6;
  if (this->has_lever() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->has_lever(), output);
  }

  // .autodrive.workflow.proto.Vector3f lever_start_point = 7;
  if (this->has_lever_start_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->lever_start_point_, output);
  }

  // .autodrive.workflow.proto.Vector3f lever_end_point = 8;
  if (this->has_lever_end_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->lever_end_point_, output);
  }

  // float floor = 9;
  if (this->floor() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->floor(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.GlbPrkgSlot)
}

::google::protobuf::uint8* GlbPrkgSlot::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.GlbPrkgSlot)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 slot_id = 1;
  if (this->slot_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->slot_id(), target);
  }

  // .autodrive.workflow.proto.SlotStatus slot_status = 2;
  if (this->slot_status() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->slot_status(), target);
  }

  // .autodrive.workflow.proto.SlotType slot_type = 3;
  if (this->slot_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->slot_type(), target);
  }

  // repeated .autodrive.workflow.proto.Vector3f slot_points = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->slot_points_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->slot_points(static_cast<int>(i)), deterministic, target);
  }

  // bool is_target_slot = 5;
  if (this->is_target_slot() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->is_target_slot(), target);
  }

  // bool has_lever = 6;
  if (this->has_lever() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->has_lever(), target);
  }

  // .autodrive.workflow.proto.Vector3f lever_start_point = 7;
  if (this->has_lever_start_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, *this->lever_start_point_, deterministic, target);
  }

  // .autodrive.workflow.proto.Vector3f lever_end_point = 8;
  if (this->has_lever_end_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, *this->lever_end_point_, deterministic, target);
  }

  // float floor = 9;
  if (this->floor() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->floor(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.GlbPrkgSlot)
  return target;
}

size_t GlbPrkgSlot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.GlbPrkgSlot)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.Vector3f slot_points = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->slot_points_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->slot_points(static_cast<int>(i)));
    }
  }

  // .autodrive.workflow.proto.Vector3f lever_start_point = 7;
  if (this->has_lever_start_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->lever_start_point_);
  }

  // .autodrive.workflow.proto.Vector3f lever_end_point = 8;
  if (this->has_lever_end_point()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->lever_end_point_);
  }

  // uint32 slot_id = 1;
  if (this->slot_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->slot_id());
  }

  // .autodrive.workflow.proto.SlotStatus slot_status = 2;
  if (this->slot_status() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->slot_status());
  }

  // .autodrive.workflow.proto.SlotType slot_type = 3;
  if (this->slot_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->slot_type());
  }

  // bool is_target_slot = 5;
  if (this->is_target_slot() != 0) {
    total_size += 1 + 1;
  }

  // bool has_lever = 6;
  if (this->has_lever() != 0) {
    total_size += 1 + 1;
  }

  // float floor = 9;
  if (this->floor() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlbPrkgSlot::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.GlbPrkgSlot)
  GOOGLE_DCHECK_NE(&from, this);
  const GlbPrkgSlot* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GlbPrkgSlot>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.GlbPrkgSlot)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.GlbPrkgSlot)
    MergeFrom(*source);
  }
}

void GlbPrkgSlot::MergeFrom(const GlbPrkgSlot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.GlbPrkgSlot)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  slot_points_.MergeFrom(from.slot_points_);
  if (from.has_lever_start_point()) {
    mutable_lever_start_point()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.lever_start_point());
  }
  if (from.has_lever_end_point()) {
    mutable_lever_end_point()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.lever_end_point());
  }
  if (from.slot_id() != 0) {
    set_slot_id(from.slot_id());
  }
  if (from.slot_status() != 0) {
    set_slot_status(from.slot_status());
  }
  if (from.slot_type() != 0) {
    set_slot_type(from.slot_type());
  }
  if (from.is_target_slot() != 0) {
    set_is_target_slot(from.is_target_slot());
  }
  if (from.has_lever() != 0) {
    set_has_lever(from.has_lever());
  }
  if (from.floor() != 0) {
    set_floor(from.floor());
  }
}

void GlbPrkgSlot::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.GlbPrkgSlot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GlbPrkgSlot::CopyFrom(const GlbPrkgSlot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.GlbPrkgSlot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlbPrkgSlot::IsInitialized() const {
  return true;
}

void GlbPrkgSlot::Swap(GlbPrkgSlot* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GlbPrkgSlot::InternalSwap(GlbPrkgSlot* other) {
  using std::swap;
  slot_points_.InternalSwap(&other->slot_points_);
  swap(lever_start_point_, other->lever_start_point_);
  swap(lever_end_point_, other->lever_end_point_);
  swap(slot_id_, other->slot_id_);
  swap(slot_status_, other->slot_status_);
  swap(slot_type_, other->slot_type_);
  swap(is_target_slot_, other->is_target_slot_);
  swap(has_lever_, other->has_lever_);
  swap(floor_, other->floor_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GlbPrkgSlot::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void GlbPrcpPrkgSlots::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GlbPrcpPrkgSlots::kGlbPrkgSlotsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GlbPrcpPrkgSlots::GlbPrcpPrkgSlots()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbPrcpPrkgSlots();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.GlbPrcpPrkgSlots)
}
GlbPrcpPrkgSlots::GlbPrcpPrkgSlots(const GlbPrcpPrkgSlots& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      glb_prkg_slots_(from.glb_prkg_slots_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.GlbPrcpPrkgSlots)
}

void GlbPrcpPrkgSlots::SharedCtor() {
  _cached_size_ = 0;
}

GlbPrcpPrkgSlots::~GlbPrcpPrkgSlots() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  SharedDtor();
}

void GlbPrcpPrkgSlots::SharedDtor() {
}

void GlbPrcpPrkgSlots::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GlbPrcpPrkgSlots::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GlbPrcpPrkgSlots& GlbPrcpPrkgSlots::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbPrcpPrkgSlots();
  return *internal_default_instance();
}

GlbPrcpPrkgSlots* GlbPrcpPrkgSlots::New(::google::protobuf::Arena* arena) const {
  GlbPrcpPrkgSlots* n = new GlbPrcpPrkgSlots;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GlbPrcpPrkgSlots::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  glb_prkg_slots_.Clear();
  _internal_metadata_.Clear();
}

bool GlbPrcpPrkgSlots::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .autodrive.workflow.proto.GlbPrkgSlot glb_prkg_slots = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_glb_prkg_slots()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  return false;
#undef DO_
}

void GlbPrcpPrkgSlots::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.GlbPrkgSlot glb_prkg_slots = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->glb_prkg_slots_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->glb_prkg_slots(static_cast<int>(i)), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.GlbPrcpPrkgSlots)
}

::google::protobuf::uint8* GlbPrcpPrkgSlots::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.GlbPrkgSlot glb_prkg_slots = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->glb_prkg_slots_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->glb_prkg_slots(static_cast<int>(i)), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  return target;
}

size_t GlbPrcpPrkgSlots::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.GlbPrkgSlot glb_prkg_slots = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->glb_prkg_slots_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->glb_prkg_slots(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlbPrcpPrkgSlots::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  GOOGLE_DCHECK_NE(&from, this);
  const GlbPrcpPrkgSlots* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GlbPrcpPrkgSlots>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.GlbPrcpPrkgSlots)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.GlbPrcpPrkgSlots)
    MergeFrom(*source);
  }
}

void GlbPrcpPrkgSlots::MergeFrom(const GlbPrcpPrkgSlots& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  glb_prkg_slots_.MergeFrom(from.glb_prkg_slots_);
}

void GlbPrcpPrkgSlots::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GlbPrcpPrkgSlots::CopyFrom(const GlbPrcpPrkgSlots& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.GlbPrcpPrkgSlots)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlbPrcpPrkgSlots::IsInitialized() const {
  return true;
}

void GlbPrcpPrkgSlots::Swap(GlbPrcpPrkgSlots* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GlbPrcpPrkgSlots::InternalSwap(GlbPrcpPrkgSlots* other) {
  using std::swap;
  glb_prkg_slots_.InternalSwap(&other->glb_prkg_slots_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GlbPrcpPrkgSlots::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void GlbRoadMark::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_GlbRoadMark_default_instance_._instance.get_mutable()->position_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
}
void GlbRoadMark::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
void GlbRoadMark::clear_border() {
  border_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GlbRoadMark::kPositionFieldNumber;
const int GlbRoadMark::kOdomHeadingFieldNumber;
const int GlbRoadMark::kRoadmarkIdFieldNumber;
const int GlbRoadMark::kRoadmarkTypeFieldNumber;
const int GlbRoadMark::kBorderFieldNumber;
const int GlbRoadMark::kFloorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GlbRoadMark::GlbRoadMark()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbRoadMark();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.GlbRoadMark)
}
GlbRoadMark::GlbRoadMark(const GlbRoadMark& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      border_(from.border_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::autodrive::workflow::proto::Vector3f(*from.position_);
  } else {
    position_ = NULL;
  }
  ::memcpy(&odom_heading_, &from.odom_heading_,
    static_cast<size_t>(reinterpret_cast<char*>(&floor_) -
    reinterpret_cast<char*>(&odom_heading_)) + sizeof(floor_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.GlbRoadMark)
}

void GlbRoadMark::SharedCtor() {
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&floor_) -
      reinterpret_cast<char*>(&position_)) + sizeof(floor_));
  _cached_size_ = 0;
}

GlbRoadMark::~GlbRoadMark() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.GlbRoadMark)
  SharedDtor();
}

void GlbRoadMark::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
}

void GlbRoadMark::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GlbRoadMark::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GlbRoadMark& GlbRoadMark::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbRoadMark();
  return *internal_default_instance();
}

GlbRoadMark* GlbRoadMark::New(::google::protobuf::Arena* arena) const {
  GlbRoadMark* n = new GlbRoadMark;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GlbRoadMark::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.GlbRoadMark)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  border_.Clear();
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  ::memset(&odom_heading_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&floor_) -
      reinterpret_cast<char*>(&odom_heading_)) + sizeof(floor_));
  _internal_metadata_.Clear();
}

bool GlbRoadMark::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.GlbRoadMark)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.Vector3f position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float odom_heading = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u /* 21 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &odom_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 roadmark_id = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roadmark_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.RoadMarkType roadmark_type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_roadmark_type(static_cast< ::autodrive::workflow::proto::RoadMarkType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.Vector2f border = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_border()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float floor = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(53u /* 53 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &floor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.GlbRoadMark)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.GlbRoadMark)
  return false;
#undef DO_
}

void GlbRoadMark::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.GlbRoadMark)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f position = 1;
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_, output);
  }

  // float odom_heading = 2;
  if (this->odom_heading() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->odom_heading(), output);
  }

  // uint32 roadmark_id = 3;
  if (this->roadmark_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->roadmark_id(), output);
  }

  // .autodrive.workflow.proto.RoadMarkType roadmark_type = 4;
  if (this->roadmark_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->roadmark_type(), output);
  }

  // repeated .autodrive.workflow.proto.Vector2f border = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->border_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->border(static_cast<int>(i)), output);
  }

  // float floor = 6;
  if (this->floor() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->floor(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.GlbRoadMark)
}

::google::protobuf::uint8* GlbRoadMark::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.GlbRoadMark)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f position = 1;
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->position_, deterministic, target);
  }

  // float odom_heading = 2;
  if (this->odom_heading() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->odom_heading(), target);
  }

  // uint32 roadmark_id = 3;
  if (this->roadmark_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->roadmark_id(), target);
  }

  // .autodrive.workflow.proto.RoadMarkType roadmark_type = 4;
  if (this->roadmark_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->roadmark_type(), target);
  }

  // repeated .autodrive.workflow.proto.Vector2f border = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->border_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->border(static_cast<int>(i)), deterministic, target);
  }

  // float floor = 6;
  if (this->floor() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->floor(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.GlbRoadMark)
  return target;
}

size_t GlbRoadMark::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.GlbRoadMark)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.Vector2f border = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->border_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->border(static_cast<int>(i)));
    }
  }

  // .autodrive.workflow.proto.Vector3f position = 1;
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->position_);
  }

  // float odom_heading = 2;
  if (this->odom_heading() != 0) {
    total_size += 1 + 4;
  }

  // uint32 roadmark_id = 3;
  if (this->roadmark_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->roadmark_id());
  }

  // .autodrive.workflow.proto.RoadMarkType roadmark_type = 4;
  if (this->roadmark_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->roadmark_type());
  }

  // float floor = 6;
  if (this->floor() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlbRoadMark::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.GlbRoadMark)
  GOOGLE_DCHECK_NE(&from, this);
  const GlbRoadMark* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GlbRoadMark>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.GlbRoadMark)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.GlbRoadMark)
    MergeFrom(*source);
  }
}

void GlbRoadMark::MergeFrom(const GlbRoadMark& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.GlbRoadMark)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  border_.MergeFrom(from.border_);
  if (from.has_position()) {
    mutable_position()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.position());
  }
  if (from.odom_heading() != 0) {
    set_odom_heading(from.odom_heading());
  }
  if (from.roadmark_id() != 0) {
    set_roadmark_id(from.roadmark_id());
  }
  if (from.roadmark_type() != 0) {
    set_roadmark_type(from.roadmark_type());
  }
  if (from.floor() != 0) {
    set_floor(from.floor());
  }
}

void GlbRoadMark::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.GlbRoadMark)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GlbRoadMark::CopyFrom(const GlbRoadMark& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.GlbRoadMark)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlbRoadMark::IsInitialized() const {
  return true;
}

void GlbRoadMark::Swap(GlbRoadMark* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GlbRoadMark::InternalSwap(GlbRoadMark* other) {
  using std::swap;
  border_.InternalSwap(&other->border_);
  swap(position_, other->position_);
  swap(odom_heading_, other->odom_heading_);
  swap(roadmark_id_, other->roadmark_id_);
  swap(roadmark_type_, other->roadmark_type_);
  swap(floor_, other->floor_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GlbRoadMark::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void GlbRoadMakMap::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GlbRoadMakMap::kGlbRoadMakMapFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GlbRoadMakMap::GlbRoadMakMap()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbRoadMakMap();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.GlbRoadMakMap)
}
GlbRoadMakMap::GlbRoadMakMap(const GlbRoadMakMap& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      glb_road_mak_map_(from.glb_road_mak_map_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.GlbRoadMakMap)
}

void GlbRoadMakMap::SharedCtor() {
  _cached_size_ = 0;
}

GlbRoadMakMap::~GlbRoadMakMap() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.GlbRoadMakMap)
  SharedDtor();
}

void GlbRoadMakMap::SharedDtor() {
}

void GlbRoadMakMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GlbRoadMakMap::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GlbRoadMakMap& GlbRoadMakMap::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbRoadMakMap();
  return *internal_default_instance();
}

GlbRoadMakMap* GlbRoadMakMap::New(::google::protobuf::Arena* arena) const {
  GlbRoadMakMap* n = new GlbRoadMakMap;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GlbRoadMakMap::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.GlbRoadMakMap)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  glb_road_mak_map_.Clear();
  _internal_metadata_.Clear();
}

bool GlbRoadMakMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.GlbRoadMakMap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .autodrive.workflow.proto.GlbRoadMark glb_road_mak_map = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_glb_road_mak_map()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.GlbRoadMakMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.GlbRoadMakMap)
  return false;
#undef DO_
}

void GlbRoadMakMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.GlbRoadMakMap)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.GlbRoadMark glb_road_mak_map = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->glb_road_mak_map_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->glb_road_mak_map(static_cast<int>(i)), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.GlbRoadMakMap)
}

::google::protobuf::uint8* GlbRoadMakMap::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.GlbRoadMakMap)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.GlbRoadMark glb_road_mak_map = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->glb_road_mak_map_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->glb_road_mak_map(static_cast<int>(i)), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.GlbRoadMakMap)
  return target;
}

size_t GlbRoadMakMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.GlbRoadMakMap)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.GlbRoadMark glb_road_mak_map = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->glb_road_mak_map_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->glb_road_mak_map(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlbRoadMakMap::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.GlbRoadMakMap)
  GOOGLE_DCHECK_NE(&from, this);
  const GlbRoadMakMap* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GlbRoadMakMap>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.GlbRoadMakMap)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.GlbRoadMakMap)
    MergeFrom(*source);
  }
}

void GlbRoadMakMap::MergeFrom(const GlbRoadMakMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.GlbRoadMakMap)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  glb_road_mak_map_.MergeFrom(from.glb_road_mak_map_);
}

void GlbRoadMakMap::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.GlbRoadMakMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GlbRoadMakMap::CopyFrom(const GlbRoadMakMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.GlbRoadMakMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlbRoadMakMap::IsInitialized() const {
  return true;
}

void GlbRoadMakMap::Swap(GlbRoadMakMap* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GlbRoadMakMap::InternalSwap(GlbRoadMakMap* other) {
  using std::swap;
  glb_road_mak_map_.InternalSwap(&other->glb_road_mak_map_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GlbRoadMakMap::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void GlbObstacle::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_GlbObstacle_default_instance_._instance.get_mutable()->center_position_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
}
void GlbObstacle::clear_center_position() {
  if (GetArenaNoVirtual() == NULL && center_position_ != NULL) {
    delete center_position_;
  }
  center_position_ = NULL;
}
void GlbObstacle::clear_border() {
  border_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GlbObstacle::kCenterPositionFieldNumber;
const int GlbObstacle::kOdomHeadingFieldNumber;
const int GlbObstacle::kObstacleTypeFieldNumber;
const int GlbObstacle::kDangerLevelFieldNumber;
const int GlbObstacle::kTargetIdFieldNumber;
const int GlbObstacle::kBorderFieldNumber;
const int GlbObstacle::kObjStatusFieldNumber;
const int GlbObstacle::kFloorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GlbObstacle::GlbObstacle()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbObstacle();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.GlbObstacle)
}
GlbObstacle::GlbObstacle(const GlbObstacle& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      border_(from.border_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_center_position()) {
    center_position_ = new ::autodrive::workflow::proto::Vector3f(*from.center_position_);
  } else {
    center_position_ = NULL;
  }
  ::memcpy(&odom_heading_, &from.odom_heading_,
    static_cast<size_t>(reinterpret_cast<char*>(&floor_) -
    reinterpret_cast<char*>(&odom_heading_)) + sizeof(floor_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.GlbObstacle)
}

void GlbObstacle::SharedCtor() {
  ::memset(&center_position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&floor_) -
      reinterpret_cast<char*>(&center_position_)) + sizeof(floor_));
  _cached_size_ = 0;
}

GlbObstacle::~GlbObstacle() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.GlbObstacle)
  SharedDtor();
}

void GlbObstacle::SharedDtor() {
  if (this != internal_default_instance()) delete center_position_;
}

void GlbObstacle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GlbObstacle::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GlbObstacle& GlbObstacle::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbObstacle();
  return *internal_default_instance();
}

GlbObstacle* GlbObstacle::New(::google::protobuf::Arena* arena) const {
  GlbObstacle* n = new GlbObstacle;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GlbObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.GlbObstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  border_.Clear();
  if (GetArenaNoVirtual() == NULL && center_position_ != NULL) {
    delete center_position_;
  }
  center_position_ = NULL;
  ::memset(&odom_heading_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&floor_) -
      reinterpret_cast<char*>(&odom_heading_)) + sizeof(floor_));
  _internal_metadata_.Clear();
}

bool GlbObstacle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.GlbObstacle)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.Vector3f center_position = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_center_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float odom_heading = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u /* 21 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &odom_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Map2HmiObstacleType obstacle_type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_obstacle_type(static_cast< ::autodrive::workflow::proto::Map2HmiObstacleType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.DangerLevel danger_level = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_danger_level(static_cast< ::autodrive::workflow::proto::DangerLevel >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 target_id = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.Vector2f border = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_border()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.ObjStatus obj_status = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_obj_status(static_cast< ::autodrive::workflow::proto::ObjStatus >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float floor = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(69u /* 69 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &floor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.GlbObstacle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.GlbObstacle)
  return false;
#undef DO_
}

void GlbObstacle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.GlbObstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f center_position = 1;
  if (this->has_center_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->center_position_, output);
  }

  // float odom_heading = 2;
  if (this->odom_heading() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->odom_heading(), output);
  }

  // .autodrive.workflow.proto.Map2HmiObstacleType obstacle_type = 3;
  if (this->obstacle_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->obstacle_type(), output);
  }

  // .autodrive.workflow.proto.DangerLevel danger_level = 4;
  if (this->danger_level() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->danger_level(), output);
  }

  // uint32 target_id = 5;
  if (this->target_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->target_id(), output);
  }

  // repeated .autodrive.workflow.proto.Vector2f border = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->border_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->border(static_cast<int>(i)), output);
  }

  // .autodrive.workflow.proto.ObjStatus obj_status = 7;
  if (this->obj_status() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->obj_status(), output);
  }

  // float floor = 8;
  if (this->floor() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->floor(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.GlbObstacle)
}

::google::protobuf::uint8* GlbObstacle::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.GlbObstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f center_position = 1;
  if (this->has_center_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->center_position_, deterministic, target);
  }

  // float odom_heading = 2;
  if (this->odom_heading() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->odom_heading(), target);
  }

  // .autodrive.workflow.proto.Map2HmiObstacleType obstacle_type = 3;
  if (this->obstacle_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->obstacle_type(), target);
  }

  // .autodrive.workflow.proto.DangerLevel danger_level = 4;
  if (this->danger_level() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->danger_level(), target);
  }

  // uint32 target_id = 5;
  if (this->target_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->target_id(), target);
  }

  // repeated .autodrive.workflow.proto.Vector2f border = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->border_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->border(static_cast<int>(i)), deterministic, target);
  }

  // .autodrive.workflow.proto.ObjStatus obj_status = 7;
  if (this->obj_status() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->obj_status(), target);
  }

  // float floor = 8;
  if (this->floor() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->floor(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.GlbObstacle)
  return target;
}

size_t GlbObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.GlbObstacle)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.Vector2f border = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->border_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->border(static_cast<int>(i)));
    }
  }

  // .autodrive.workflow.proto.Vector3f center_position = 1;
  if (this->has_center_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->center_position_);
  }

  // float odom_heading = 2;
  if (this->odom_heading() != 0) {
    total_size += 1 + 4;
  }

  // .autodrive.workflow.proto.Map2HmiObstacleType obstacle_type = 3;
  if (this->obstacle_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->obstacle_type());
  }

  // .autodrive.workflow.proto.DangerLevel danger_level = 4;
  if (this->danger_level() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->danger_level());
  }

  // uint32 target_id = 5;
  if (this->target_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->target_id());
  }

  // .autodrive.workflow.proto.ObjStatus obj_status = 7;
  if (this->obj_status() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->obj_status());
  }

  // float floor = 8;
  if (this->floor() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlbObstacle::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.GlbObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const GlbObstacle* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GlbObstacle>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.GlbObstacle)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.GlbObstacle)
    MergeFrom(*source);
  }
}

void GlbObstacle::MergeFrom(const GlbObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.GlbObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  border_.MergeFrom(from.border_);
  if (from.has_center_position()) {
    mutable_center_position()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.center_position());
  }
  if (from.odom_heading() != 0) {
    set_odom_heading(from.odom_heading());
  }
  if (from.obstacle_type() != 0) {
    set_obstacle_type(from.obstacle_type());
  }
  if (from.danger_level() != 0) {
    set_danger_level(from.danger_level());
  }
  if (from.target_id() != 0) {
    set_target_id(from.target_id());
  }
  if (from.obj_status() != 0) {
    set_obj_status(from.obj_status());
  }
  if (from.floor() != 0) {
    set_floor(from.floor());
  }
}

void GlbObstacle::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.GlbObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GlbObstacle::CopyFrom(const GlbObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.GlbObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlbObstacle::IsInitialized() const {
  return true;
}

void GlbObstacle::Swap(GlbObstacle* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GlbObstacle::InternalSwap(GlbObstacle* other) {
  using std::swap;
  border_.InternalSwap(&other->border_);
  swap(center_position_, other->center_position_);
  swap(odom_heading_, other->odom_heading_);
  swap(obstacle_type_, other->obstacle_type_);
  swap(danger_level_, other->danger_level_);
  swap(target_id_, other->target_id_);
  swap(obj_status_, other->obj_status_);
  swap(floor_, other->floor_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GlbObstacle::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void GlbPrcpObstacle::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GlbPrcpObstacle::kGlbPrcpObstacleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GlbPrcpObstacle::GlbPrcpObstacle()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbPrcpObstacle();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.GlbPrcpObstacle)
}
GlbPrcpObstacle::GlbPrcpObstacle(const GlbPrcpObstacle& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      glb_prcp_obstacle_(from.glb_prcp_obstacle_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.GlbPrcpObstacle)
}

void GlbPrcpObstacle::SharedCtor() {
  _cached_size_ = 0;
}

GlbPrcpObstacle::~GlbPrcpObstacle() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.GlbPrcpObstacle)
  SharedDtor();
}

void GlbPrcpObstacle::SharedDtor() {
}

void GlbPrcpObstacle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GlbPrcpObstacle::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GlbPrcpObstacle& GlbPrcpObstacle::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsGlbPrcpObstacle();
  return *internal_default_instance();
}

GlbPrcpObstacle* GlbPrcpObstacle::New(::google::protobuf::Arena* arena) const {
  GlbPrcpObstacle* n = new GlbPrcpObstacle;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GlbPrcpObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.GlbPrcpObstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  glb_prcp_obstacle_.Clear();
  _internal_metadata_.Clear();
}

bool GlbPrcpObstacle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.GlbPrcpObstacle)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .autodrive.workflow.proto.GlbObstacle glb_prcp_obstacle = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_glb_prcp_obstacle()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.GlbPrcpObstacle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.GlbPrcpObstacle)
  return false;
#undef DO_
}

void GlbPrcpObstacle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.GlbPrcpObstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.GlbObstacle glb_prcp_obstacle = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->glb_prcp_obstacle_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->glb_prcp_obstacle(static_cast<int>(i)), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.GlbPrcpObstacle)
}

::google::protobuf::uint8* GlbPrcpObstacle::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.GlbPrcpObstacle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.GlbObstacle glb_prcp_obstacle = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->glb_prcp_obstacle_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->glb_prcp_obstacle(static_cast<int>(i)), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.GlbPrcpObstacle)
  return target;
}

size_t GlbPrcpObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.GlbPrcpObstacle)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.GlbObstacle glb_prcp_obstacle = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->glb_prcp_obstacle_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->glb_prcp_obstacle(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlbPrcpObstacle::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.GlbPrcpObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const GlbPrcpObstacle* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GlbPrcpObstacle>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.GlbPrcpObstacle)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.GlbPrcpObstacle)
    MergeFrom(*source);
  }
}

void GlbPrcpObstacle::MergeFrom(const GlbPrcpObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.GlbPrcpObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  glb_prcp_obstacle_.MergeFrom(from.glb_prcp_obstacle_);
}

void GlbPrcpObstacle::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.GlbPrcpObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GlbPrcpObstacle::CopyFrom(const GlbPrcpObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.GlbPrcpObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlbPrcpObstacle::IsInitialized() const {
  return true;
}

void GlbPrcpObstacle::Swap(GlbPrcpObstacle* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GlbPrcpObstacle::InternalSwap(GlbPrcpObstacle* other) {
  using std::swap;
  glb_prcp_obstacle_.InternalSwap(&other->glb_prcp_obstacle_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GlbPrcpObstacle::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void MapCommonHeader::InitAsDefaultInstance() {
}
void MapCommonHeader::clear_glb_trajectory_point() {
  glb_trajectory_point_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MapCommonHeader::kMapIdFieldNumber;
const int MapCommonHeader::kMapTypeFieldNumber;
const int MapCommonHeader::kUtcTimeFieldNumber;
const int MapCommonHeader::kLatitudeFieldNumber;
const int MapCommonHeader::kLongitudeFieldNumber;
const int MapCommonHeader::kGlbTrajectoryPointFieldNumber;
const int MapCommonHeader::kMapTotalHeightFieldNumber;
const int MapCommonHeader::kMapTotalFloorFieldNumber;
const int MapCommonHeader::kSlotParkingTimesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MapCommonHeader::MapCommonHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsMapCommonHeader();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.MapCommonHeader)
}
MapCommonHeader::MapCommonHeader(const MapCommonHeader& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      glb_trajectory_point_(from.glb_trajectory_point_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&map_id_, &from.map_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&slot_parking_times_) -
    reinterpret_cast<char*>(&map_id_)) + sizeof(slot_parking_times_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.MapCommonHeader)
}

void MapCommonHeader::SharedCtor() {
  ::memset(&map_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&slot_parking_times_) -
      reinterpret_cast<char*>(&map_id_)) + sizeof(slot_parking_times_));
  _cached_size_ = 0;
}

MapCommonHeader::~MapCommonHeader() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.MapCommonHeader)
  SharedDtor();
}

void MapCommonHeader::SharedDtor() {
}

void MapCommonHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapCommonHeader::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const MapCommonHeader& MapCommonHeader::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsMapCommonHeader();
  return *internal_default_instance();
}

MapCommonHeader* MapCommonHeader::New(::google::protobuf::Arena* arena) const {
  MapCommonHeader* n = new MapCommonHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MapCommonHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.MapCommonHeader)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  glb_trajectory_point_.Clear();
  ::memset(&map_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&slot_parking_times_) -
      reinterpret_cast<char*>(&map_id_)) + sizeof(slot_parking_times_));
  _internal_metadata_.Clear();
}

bool MapCommonHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.MapCommonHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 map_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.MapDataType map_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_map_type(static_cast< ::autodrive::workflow::proto::MapDataType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 utc_time = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &utc_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 latitude = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &latitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 longitude = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &longitude_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.Vector2f glb_trajectory_point = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_glb_trajectory_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float map_total_height = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(61u /* 61 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &map_total_height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float map_total_floor = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(69u /* 69 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &map_total_floor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 slot_parking_times = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &slot_parking_times_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.MapCommonHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.MapCommonHeader)
  return false;
#undef DO_
}

void MapCommonHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.MapCommonHeader)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 map_id = 1;
  if (this->map_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->map_id(), output);
  }

  // .autodrive.workflow.proto.MapDataType map_type = 2;
  if (this->map_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->map_type(), output);
  }

  // uint64 utc_time = 3;
  if (this->utc_time() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->utc_time(), output);
  }

  // int32 latitude = 4;
  if (this->latitude() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->latitude(), output);
  }

  // int32 longitude = 5;
  if (this->longitude() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->longitude(), output);
  }

  // repeated .autodrive.workflow.proto.Vector2f glb_trajectory_point = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->glb_trajectory_point_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->glb_trajectory_point(static_cast<int>(i)), output);
  }

  // float map_total_height = 7;
  if (this->map_total_height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->map_total_height(), output);
  }

  // float map_total_floor = 8;
  if (this->map_total_floor() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->map_total_floor(), output);
  }

  // int32 slot_parking_times = 9;
  if (this->slot_parking_times() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->slot_parking_times(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.MapCommonHeader)
}

::google::protobuf::uint8* MapCommonHeader::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.MapCommonHeader)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 map_id = 1;
  if (this->map_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->map_id(), target);
  }

  // .autodrive.workflow.proto.MapDataType map_type = 2;
  if (this->map_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->map_type(), target);
  }

  // uint64 utc_time = 3;
  if (this->utc_time() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->utc_time(), target);
  }

  // int32 latitude = 4;
  if (this->latitude() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->latitude(), target);
  }

  // int32 longitude = 5;
  if (this->longitude() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->longitude(), target);
  }

  // repeated .autodrive.workflow.proto.Vector2f glb_trajectory_point = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->glb_trajectory_point_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->glb_trajectory_point(static_cast<int>(i)), deterministic, target);
  }

  // float map_total_height = 7;
  if (this->map_total_height() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->map_total_height(), target);
  }

  // float map_total_floor = 8;
  if (this->map_total_floor() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->map_total_floor(), target);
  }

  // int32 slot_parking_times = 9;
  if (this->slot_parking_times() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->slot_parking_times(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.MapCommonHeader)
  return target;
}

size_t MapCommonHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.MapCommonHeader)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.Vector2f glb_trajectory_point = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->glb_trajectory_point_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->glb_trajectory_point(static_cast<int>(i)));
    }
  }

  // int32 map_id = 1;
  if (this->map_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->map_id());
  }

  // .autodrive.workflow.proto.MapDataType map_type = 2;
  if (this->map_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->map_type());
  }

  // uint64 utc_time = 3;
  if (this->utc_time() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->utc_time());
  }

  // int32 latitude = 4;
  if (this->latitude() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->latitude());
  }

  // int32 longitude = 5;
  if (this->longitude() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->longitude());
  }

  // float map_total_height = 7;
  if (this->map_total_height() != 0) {
    total_size += 1 + 4;
  }

  // float map_total_floor = 8;
  if (this->map_total_floor() != 0) {
    total_size += 1 + 4;
  }

  // int32 slot_parking_times = 9;
  if (this->slot_parking_times() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->slot_parking_times());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapCommonHeader::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.MapCommonHeader)
  GOOGLE_DCHECK_NE(&from, this);
  const MapCommonHeader* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const MapCommonHeader>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.MapCommonHeader)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.MapCommonHeader)
    MergeFrom(*source);
  }
}

void MapCommonHeader::MergeFrom(const MapCommonHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.MapCommonHeader)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  glb_trajectory_point_.MergeFrom(from.glb_trajectory_point_);
  if (from.map_id() != 0) {
    set_map_id(from.map_id());
  }
  if (from.map_type() != 0) {
    set_map_type(from.map_type());
  }
  if (from.utc_time() != 0) {
    set_utc_time(from.utc_time());
  }
  if (from.latitude() != 0) {
    set_latitude(from.latitude());
  }
  if (from.longitude() != 0) {
    set_longitude(from.longitude());
  }
  if (from.map_total_height() != 0) {
    set_map_total_height(from.map_total_height());
  }
  if (from.map_total_floor() != 0) {
    set_map_total_floor(from.map_total_floor());
  }
  if (from.slot_parking_times() != 0) {
    set_slot_parking_times(from.slot_parking_times());
  }
}

void MapCommonHeader::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.MapCommonHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapCommonHeader::CopyFrom(const MapCommonHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.MapCommonHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapCommonHeader::IsInitialized() const {
  return true;
}

void MapCommonHeader::Swap(MapCommonHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MapCommonHeader::InternalSwap(MapCommonHeader* other) {
  using std::swap;
  glb_trajectory_point_.InternalSwap(&other->glb_trajectory_point_);
  swap(map_id_, other->map_id_);
  swap(map_type_, other->map_type_);
  swap(utc_time_, other->utc_time_);
  swap(latitude_, other->latitude_);
  swap(longitude_, other->longitude_);
  swap(map_total_height_, other->map_total_height_);
  swap(map_total_floor_, other->map_total_floor_);
  swap(slot_parking_times_, other->slot_parking_times_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MapCommonHeader::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void MapInfo::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_MapInfo_default_instance_._instance.get_mutable()->header_ = const_cast< ::autodrive::workflow::proto::MapCommonHeader*>(
      ::autodrive::workflow::proto::MapCommonHeader::internal_default_instance());
  ::autodrive::workflow::proto::_MapInfo_default_instance_._instance.get_mutable()->global_trajectory_ = const_cast< ::autodrive::workflow::proto::GlbTrajectory*>(
      ::autodrive::workflow::proto::GlbTrajectory::internal_default_instance());
  ::autodrive::workflow::proto::_MapInfo_default_instance_._instance.get_mutable()->global_percep_parking_slots_ = const_cast< ::autodrive::workflow::proto::GlbPrcpPrkgSlots*>(
      ::autodrive::workflow::proto::GlbPrcpPrkgSlots::internal_default_instance());
  ::autodrive::workflow::proto::_MapInfo_default_instance_._instance.get_mutable()->global_road_mark_map_ = const_cast< ::autodrive::workflow::proto::GlbRoadMakMap*>(
      ::autodrive::workflow::proto::GlbRoadMakMap::internal_default_instance());
  ::autodrive::workflow::proto::_MapInfo_default_instance_._instance.get_mutable()->global_perception_obstacle_ = const_cast< ::autodrive::workflow::proto::GlbPrcpObstacle*>(
      ::autodrive::workflow::proto::GlbPrcpObstacle::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MapInfo::kHeaderFieldNumber;
const int MapInfo::kGlobalTrajectoryFieldNumber;
const int MapInfo::kGlobalPercepParkingSlotsFieldNumber;
const int MapInfo::kGlobalRoadMarkMapFieldNumber;
const int MapInfo::kGlobalPerceptionObstacleFieldNumber;
const int MapInfo::kMapDistanceFieldNumber;
const int MapInfo::kRestMapDistanceFieldNumber;
const int MapInfo::kNumSpeedBumpsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MapInfo::MapInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsMapInfo();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.MapInfo)
}
MapInfo::MapInfo(const MapInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::autodrive::workflow::proto::MapCommonHeader(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_global_trajectory()) {
    global_trajectory_ = new ::autodrive::workflow::proto::GlbTrajectory(*from.global_trajectory_);
  } else {
    global_trajectory_ = NULL;
  }
  if (from.has_global_percep_parking_slots()) {
    global_percep_parking_slots_ = new ::autodrive::workflow::proto::GlbPrcpPrkgSlots(*from.global_percep_parking_slots_);
  } else {
    global_percep_parking_slots_ = NULL;
  }
  if (from.has_global_road_mark_map()) {
    global_road_mark_map_ = new ::autodrive::workflow::proto::GlbRoadMakMap(*from.global_road_mark_map_);
  } else {
    global_road_mark_map_ = NULL;
  }
  if (from.has_global_perception_obstacle()) {
    global_perception_obstacle_ = new ::autodrive::workflow::proto::GlbPrcpObstacle(*from.global_perception_obstacle_);
  } else {
    global_perception_obstacle_ = NULL;
  }
  ::memcpy(&map_distance_, &from.map_distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_speed_bumps_) -
    reinterpret_cast<char*>(&map_distance_)) + sizeof(num_speed_bumps_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.MapInfo)
}

void MapInfo::SharedCtor() {
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_speed_bumps_) -
      reinterpret_cast<char*>(&header_)) + sizeof(num_speed_bumps_));
  _cached_size_ = 0;
}

MapInfo::~MapInfo() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.MapInfo)
  SharedDtor();
}

void MapInfo::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete global_trajectory_;
  if (this != internal_default_instance()) delete global_percep_parking_slots_;
  if (this != internal_default_instance()) delete global_road_mark_map_;
  if (this != internal_default_instance()) delete global_perception_obstacle_;
}

void MapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapInfo::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const MapInfo& MapInfo::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsMapInfo();
  return *internal_default_instance();
}

MapInfo* MapInfo::New(::google::protobuf::Arena* arena) const {
  MapInfo* n = new MapInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.MapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && global_trajectory_ != NULL) {
    delete global_trajectory_;
  }
  global_trajectory_ = NULL;
  if (GetArenaNoVirtual() == NULL && global_percep_parking_slots_ != NULL) {
    delete global_percep_parking_slots_;
  }
  global_percep_parking_slots_ = NULL;
  if (GetArenaNoVirtual() == NULL && global_road_mark_map_ != NULL) {
    delete global_road_mark_map_;
  }
  global_road_mark_map_ = NULL;
  if (GetArenaNoVirtual() == NULL && global_perception_obstacle_ != NULL) {
    delete global_perception_obstacle_;
  }
  global_perception_obstacle_ = NULL;
  ::memset(&map_distance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_speed_bumps_) -
      reinterpret_cast<char*>(&map_distance_)) + sizeof(num_speed_bumps_));
  _internal_metadata_.Clear();
}

bool MapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.MapInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.MapCommonHeader header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.GlbTrajectory global_trajectory = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_global_trajectory()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.GlbPrcpPrkgSlots global_percep_parking_slots = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_global_percep_parking_slots()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.GlbRoadMakMap global_road_mark_map = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_global_road_mark_map()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.GlbPrcpObstacle global_perception_obstacle = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_global_perception_obstacle()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float map_distance = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(53u /* 53 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &map_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float rest_map_distance = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(61u /* 61 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rest_map_distance_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 num_speed_bumps = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_speed_bumps_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.MapInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.MapInfo)
  return false;
#undef DO_
}

void MapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.MapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.MapCommonHeader header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .autodrive.workflow.proto.GlbTrajectory global_trajectory = 2;
  if (this->has_global_trajectory()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->global_trajectory_, output);
  }

  // .autodrive.workflow.proto.GlbPrcpPrkgSlots global_percep_parking_slots = 3;
  if (this->has_global_percep_parking_slots()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->global_percep_parking_slots_, output);
  }

  // .autodrive.workflow.proto.GlbRoadMakMap global_road_mark_map = 4;
  if (this->has_global_road_mark_map()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->global_road_mark_map_, output);
  }

  // .autodrive.workflow.proto.GlbPrcpObstacle global_perception_obstacle = 5;
  if (this->has_global_perception_obstacle()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->global_perception_obstacle_, output);
  }

  // float map_distance = 6;
  if (this->map_distance() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->map_distance(), output);
  }

  // float rest_map_distance = 7;
  if (this->rest_map_distance() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->rest_map_distance(), output);
  }

  // uint32 num_speed_bumps = 8;
  if (this->num_speed_bumps() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->num_speed_bumps(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.MapInfo)
}

::google::protobuf::uint8* MapInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.MapInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.MapCommonHeader header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->header_, deterministic, target);
  }

  // .autodrive.workflow.proto.GlbTrajectory global_trajectory = 2;
  if (this->has_global_trajectory()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->global_trajectory_, deterministic, target);
  }

  // .autodrive.workflow.proto.GlbPrcpPrkgSlots global_percep_parking_slots = 3;
  if (this->has_global_percep_parking_slots()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->global_percep_parking_slots_, deterministic, target);
  }

  // .autodrive.workflow.proto.GlbRoadMakMap global_road_mark_map = 4;
  if (this->has_global_road_mark_map()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, *this->global_road_mark_map_, deterministic, target);
  }

  // .autodrive.workflow.proto.GlbPrcpObstacle global_perception_obstacle = 5;
  if (this->has_global_perception_obstacle()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, *this->global_perception_obstacle_, deterministic, target);
  }

  // float map_distance = 6;
  if (this->map_distance() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->map_distance(), target);
  }

  // float rest_map_distance = 7;
  if (this->rest_map_distance() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->rest_map_distance(), target);
  }

  // uint32 num_speed_bumps = 8;
  if (this->num_speed_bumps() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->num_speed_bumps(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.MapInfo)
  return target;
}

size_t MapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.MapInfo)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .autodrive.workflow.proto.MapCommonHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->header_);
  }

  // .autodrive.workflow.proto.GlbTrajectory global_trajectory = 2;
  if (this->has_global_trajectory()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->global_trajectory_);
  }

  // .autodrive.workflow.proto.GlbPrcpPrkgSlots global_percep_parking_slots = 3;
  if (this->has_global_percep_parking_slots()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->global_percep_parking_slots_);
  }

  // .autodrive.workflow.proto.GlbRoadMakMap global_road_mark_map = 4;
  if (this->has_global_road_mark_map()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->global_road_mark_map_);
  }

  // .autodrive.workflow.proto.GlbPrcpObstacle global_perception_obstacle = 5;
  if (this->has_global_perception_obstacle()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->global_perception_obstacle_);
  }

  // float map_distance = 6;
  if (this->map_distance() != 0) {
    total_size += 1 + 4;
  }

  // float rest_map_distance = 7;
  if (this->rest_map_distance() != 0) {
    total_size += 1 + 4;
  }

  // uint32 num_speed_bumps = 8;
  if (this->num_speed_bumps() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->num_speed_bumps());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.MapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const MapInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const MapInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.MapInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.MapInfo)
    MergeFrom(*source);
  }
}

void MapInfo::MergeFrom(const MapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.MapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_header()) {
    mutable_header()->::autodrive::workflow::proto::MapCommonHeader::MergeFrom(from.header());
  }
  if (from.has_global_trajectory()) {
    mutable_global_trajectory()->::autodrive::workflow::proto::GlbTrajectory::MergeFrom(from.global_trajectory());
  }
  if (from.has_global_percep_parking_slots()) {
    mutable_global_percep_parking_slots()->::autodrive::workflow::proto::GlbPrcpPrkgSlots::MergeFrom(from.global_percep_parking_slots());
  }
  if (from.has_global_road_mark_map()) {
    mutable_global_road_mark_map()->::autodrive::workflow::proto::GlbRoadMakMap::MergeFrom(from.global_road_mark_map());
  }
  if (from.has_global_perception_obstacle()) {
    mutable_global_perception_obstacle()->::autodrive::workflow::proto::GlbPrcpObstacle::MergeFrom(from.global_perception_obstacle());
  }
  if (from.map_distance() != 0) {
    set_map_distance(from.map_distance());
  }
  if (from.rest_map_distance() != 0) {
    set_rest_map_distance(from.rest_map_distance());
  }
  if (from.num_speed_bumps() != 0) {
    set_num_speed_bumps(from.num_speed_bumps());
  }
}

void MapInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.MapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapInfo::CopyFrom(const MapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.MapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapInfo::IsInitialized() const {
  return true;
}

void MapInfo::Swap(MapInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MapInfo::InternalSwap(MapInfo* other) {
  using std::swap;
  swap(header_, other->header_);
  swap(global_trajectory_, other->global_trajectory_);
  swap(global_percep_parking_slots_, other->global_percep_parking_slots_);
  swap(global_road_mark_map_, other->global_road_mark_map_);
  swap(global_perception_obstacle_, other->global_perception_obstacle_);
  swap(map_distance_, other->map_distance_);
  swap(rest_map_distance_, other->rest_map_distance_);
  swap(num_speed_bumps_, other->num_speed_bumps_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MapInfo::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void MapDisplayMsg::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::_MapDisplayMsg_default_instance_._instance.get_mutable()->header_ = const_cast< ::autodrive::workflow::proto::MsgHeader*>(
      ::autodrive::workflow::proto::MsgHeader::internal_default_instance());
  ::autodrive::workflow::proto::_MapDisplayMsg_default_instance_._instance.get_mutable()->error_ = const_cast< ::autodrive::workflow::proto::Error*>(
      ::autodrive::workflow::proto::Error::internal_default_instance());
  ::autodrive::workflow::proto::_MapDisplayMsg_default_instance_._instance.get_mutable()->map_info_ = const_cast< ::autodrive::workflow::proto::MapInfo*>(
      ::autodrive::workflow::proto::MapInfo::internal_default_instance());
}
void MapDisplayMsg::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
}
void MapDisplayMsg::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MapDisplayMsg::kHeaderFieldNumber;
const int MapDisplayMsg::kErrorFieldNumber;
const int MapDisplayMsg::kMapInfoFieldNumber;
const int MapDisplayMsg::kUpdateMapInfoFieldNumber;
const int MapDisplayMsg::kAllMapHeadersFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MapDisplayMsg::MapDisplayMsg()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_map_5fdisplay_2eproto::InitDefaultsMapDisplayMsg();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.MapDisplayMsg)
}
MapDisplayMsg::MapDisplayMsg(const MapDisplayMsg& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      all_map_headers_(from.all_map_headers_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::autodrive::workflow::proto::MsgHeader(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_error()) {
    error_ = new ::autodrive::workflow::proto::Error(*from.error_);
  } else {
    error_ = NULL;
  }
  if (from.has_map_info()) {
    map_info_ = new ::autodrive::workflow::proto::MapInfo(*from.map_info_);
  } else {
    map_info_ = NULL;
  }
  update_map_info_ = from.update_map_info_;
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.MapDisplayMsg)
}

void MapDisplayMsg::SharedCtor() {
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&update_map_info_) -
      reinterpret_cast<char*>(&header_)) + sizeof(update_map_info_));
  _cached_size_ = 0;
}

MapDisplayMsg::~MapDisplayMsg() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.MapDisplayMsg)
  SharedDtor();
}

void MapDisplayMsg::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (this != internal_default_instance()) delete error_;
  if (this != internal_default_instance()) delete map_info_;
}

void MapDisplayMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDisplayMsg::descriptor() {
  ::protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const MapDisplayMsg& MapDisplayMsg::default_instance() {
  ::protobuf_map_5fdisplay_2eproto::InitDefaultsMapDisplayMsg();
  return *internal_default_instance();
}

MapDisplayMsg* MapDisplayMsg::New(::google::protobuf::Arena* arena) const {
  MapDisplayMsg* n = new MapDisplayMsg;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MapDisplayMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.MapDisplayMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  all_map_headers_.Clear();
  if (GetArenaNoVirtual() == NULL && header_ != NULL) {
    delete header_;
  }
  header_ = NULL;
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
  if (GetArenaNoVirtual() == NULL && map_info_ != NULL) {
    delete map_info_;
  }
  map_info_ = NULL;
  update_map_info_ = false;
  _internal_metadata_.Clear();
}

bool MapDisplayMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.MapDisplayMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.MsgHeader header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Error error = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_error()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.MapInfo map_info = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_map_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool update_map_info = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &update_map_info_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.MapCommonHeader all_map_headers = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_all_map_headers()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.MapDisplayMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.MapDisplayMsg)
  return false;
#undef DO_
}

void MapDisplayMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.MapDisplayMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.MsgHeader header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // .autodrive.workflow.proto.Error error = 2;
  if (this->has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->error_, output);
  }

  // .autodrive.workflow.proto.MapInfo map_info = 3;
  if (this->has_map_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->map_info_, output);
  }

  // bool update_map_info = 4;
  if (this->update_map_info() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->update_map_info(), output);
  }

  // repeated .autodrive.workflow.proto.MapCommonHeader all_map_headers = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->all_map_headers_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->all_map_headers(static_cast<int>(i)), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.MapDisplayMsg)
}

::google::protobuf::uint8* MapDisplayMsg::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.MapDisplayMsg)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.MsgHeader header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->header_, deterministic, target);
  }

  // .autodrive.workflow.proto.Error error = 2;
  if (this->has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->error_, deterministic, target);
  }

  // .autodrive.workflow.proto.MapInfo map_info = 3;
  if (this->has_map_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->map_info_, deterministic, target);
  }

  // bool update_map_info = 4;
  if (this->update_map_info() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->update_map_info(), target);
  }

  // repeated .autodrive.workflow.proto.MapCommonHeader all_map_headers = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->all_map_headers_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->all_map_headers(static_cast<int>(i)), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.MapDisplayMsg)
  return target;
}

size_t MapDisplayMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.MapDisplayMsg)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.MapCommonHeader all_map_headers = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->all_map_headers_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->all_map_headers(static_cast<int>(i)));
    }
  }

  // .autodrive.workflow.proto.MsgHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->header_);
  }

  // .autodrive.workflow.proto.Error error = 2;
  if (this->has_error()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->error_);
  }

  // .autodrive.workflow.proto.MapInfo map_info = 3;
  if (this->has_map_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->map_info_);
  }

  // bool update_map_info = 4;
  if (this->update_map_info() != 0) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDisplayMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.MapDisplayMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const MapDisplayMsg* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const MapDisplayMsg>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.MapDisplayMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.MapDisplayMsg)
    MergeFrom(*source);
  }
}

void MapDisplayMsg::MergeFrom(const MapDisplayMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.MapDisplayMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  all_map_headers_.MergeFrom(from.all_map_headers_);
  if (from.has_header()) {
    mutable_header()->::autodrive::workflow::proto::MsgHeader::MergeFrom(from.header());
  }
  if (from.has_error()) {
    mutable_error()->::autodrive::workflow::proto::Error::MergeFrom(from.error());
  }
  if (from.has_map_info()) {
    mutable_map_info()->::autodrive::workflow::proto::MapInfo::MergeFrom(from.map_info());
  }
  if (from.update_map_info() != 0) {
    set_update_map_info(from.update_map_info());
  }
}

void MapDisplayMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.MapDisplayMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDisplayMsg::CopyFrom(const MapDisplayMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.MapDisplayMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDisplayMsg::IsInitialized() const {
  return true;
}

void MapDisplayMsg::Swap(MapDisplayMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MapDisplayMsg::InternalSwap(MapDisplayMsg* other) {
  using std::swap;
  all_map_headers_.InternalSwap(&other->all_map_headers_);
  swap(header_, other->header_);
  swap(error_, other->error_);
  swap(map_info_, other->map_info_);
  swap(update_map_info_, other->update_map_info_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MapDisplayMsg::GetMetadata() const {
  protobuf_map_5fdisplay_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_map_5fdisplay_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

// @@protoc_insertion_point(global_scope)
