// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: parking_slot.proto

#include "parking_slot.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace autodrive {
namespace workflow {
namespace proto {
namespace parking_slot {
class CornerInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CornerInfo>
      _instance;
} _CornerInfo_default_instance_;
class PoseInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PoseInfo>
      _instance;
} _PoseInfo_default_instance_;
class ParkingRodInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ParkingRodInfo>
      _instance;
} _ParkingRodInfo_default_instance_;
class ParkingLockInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ParkingLockInfo>
      _instance;
} _ParkingLockInfo_default_instance_;
class BoundaryInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BoundaryInfo>
      _instance;
} _BoundaryInfo_default_instance_;
class ParkingSlotInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ParkingSlotInfo>
      _instance;
} _ParkingSlotInfo_default_instance_;
}  // namespace parking_slot
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace protobuf_parking_5fslot_2eproto {
void InitDefaultsCornerInfoImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector3f();
  {
    void* ptr = &::autodrive::workflow::proto::parking_slot::_CornerInfo_default_instance_;
    new (ptr) ::autodrive::workflow::proto::parking_slot::CornerInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::parking_slot::CornerInfo::InitAsDefaultInstance();
}

void InitDefaultsCornerInfo() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsCornerInfoImpl);
}

void InitDefaultsPoseInfoImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector3f();
  {
    void* ptr = &::autodrive::workflow::proto::parking_slot::_PoseInfo_default_instance_;
    new (ptr) ::autodrive::workflow::proto::parking_slot::PoseInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::parking_slot::PoseInfo::InitAsDefaultInstance();
}

void InitDefaultsPoseInfo() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsPoseInfoImpl);
}

void InitDefaultsParkingRodInfoImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector3f();
  {
    void* ptr = &::autodrive::workflow::proto::parking_slot::_ParkingRodInfo_default_instance_;
    new (ptr) ::autodrive::workflow::proto::parking_slot::ParkingRodInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::parking_slot::ParkingRodInfo::InitAsDefaultInstance();
}

void InitDefaultsParkingRodInfo() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsParkingRodInfoImpl);
}

void InitDefaultsParkingLockInfoImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector3f();
  {
    void* ptr = &::autodrive::workflow::proto::parking_slot::_ParkingLockInfo_default_instance_;
    new (ptr) ::autodrive::workflow::proto::parking_slot::ParkingLockInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::parking_slot::ParkingLockInfo::InitAsDefaultInstance();
}

void InitDefaultsParkingLockInfo() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsParkingLockInfoImpl);
}

void InitDefaultsBoundaryInfoImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_basic_2eproto::InitDefaultsVector3f();
  {
    void* ptr = &::autodrive::workflow::proto::parking_slot::_BoundaryInfo_default_instance_;
    new (ptr) ::autodrive::workflow::proto::parking_slot::BoundaryInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::parking_slot::BoundaryInfo::InitAsDefaultInstance();
}

void InitDefaultsBoundaryInfo() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsBoundaryInfoImpl);
}

void InitDefaultsParkingSlotInfoImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_parking_5fslot_2eproto::InitDefaultsCornerInfo();
  protobuf_parking_5fslot_2eproto::InitDefaultsPoseInfo();
  protobuf_parking_5fslot_2eproto::InitDefaultsParkingRodInfo();
  protobuf_parking_5fslot_2eproto::InitDefaultsParkingLockInfo();
  protobuf_parking_5fslot_2eproto::InitDefaultsBoundaryInfo();
  {
    void* ptr = &::autodrive::workflow::proto::parking_slot::_ParkingSlotInfo_default_instance_;
    new (ptr) ::autodrive::workflow::proto::parking_slot::ParkingSlotInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::autodrive::workflow::proto::parking_slot::ParkingSlotInfo::InitAsDefaultInstance();
}

void InitDefaultsParkingSlotInfo() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsParkingSlotInfoImpl);
}

::google::protobuf::Metadata file_level_metadata[6];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[9];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::CornerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::CornerInfo, point_vcs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::CornerInfo, point_world_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::CornerInfo, point_cov_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::CornerInfo, valid_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, position_vcs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, position_world_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, length_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, width_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, yaw_vcs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, yaw_world_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, alpha_vcs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, alpha_world_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, corners_vcs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, corners_world_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, slotline_w0_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::PoseInfo, slotline_w1_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingRodInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingRodInfo, end_points_vcs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingRodInfo, end_points_world_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingRodInfo, valid_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingLockInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingLockInfo, point_vcs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingLockInfo, point_world_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingLockInfo, parking_status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingLockInfo, valid_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::BoundaryInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::BoundaryInfo, points_vcs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::BoundaryInfo, points_world_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::BoundaryInfo, boundaries_status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::BoundaryInfo, boundaries_height_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::BoundaryInfo, boundaries_fix_status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::BoundaryInfo, points_delta_ss_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, valid_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, conf_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, polygon_points_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, pose_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, parking_rod_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, parking_lock_info_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, boundary_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, occupancy_status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, parking_source_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, stage_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, occupancy_obs_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, str_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo, parking_release_mode_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::autodrive::workflow::proto::parking_slot::CornerInfo)},
  { 9, -1, sizeof(::autodrive::workflow::proto::parking_slot::PoseInfo)},
  { 26, -1, sizeof(::autodrive::workflow::proto::parking_slot::ParkingRodInfo)},
  { 34, -1, sizeof(::autodrive::workflow::proto::parking_slot::ParkingLockInfo)},
  { 43, -1, sizeof(::autodrive::workflow::proto::parking_slot::BoundaryInfo)},
  { 54, -1, sizeof(::autodrive::workflow::proto::parking_slot::ParkingSlotInfo)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::parking_slot::_CornerInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::parking_slot::_PoseInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::parking_slot::_ParkingRodInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::parking_slot::_ParkingLockInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::parking_slot::_BoundaryInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::autodrive::workflow::proto::parking_slot::_ParkingSlotInfo_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "parking_slot.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 6);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\022parking_slot.proto\022%autodrive.workflow"
      ".proto.parking_slot\032\013basic.proto\"\302\001\n\nCor"
      "nerInfo\0225\n\tpoint_vcs\030\001 \001(\0132\".autodrive.w"
      "orkflow.proto.Vector3f\0227\n\013point_world\030\002 "
      "\001(\0132\".autodrive.workflow.proto.Vector3f\022"
      "5\n\tpoint_cov\030\003 \001(\0132\".autodrive.workflow."
      "proto.Vector3f\022\r\n\005valid\030\004 \001(\010\"\211\003\n\010PoseIn"
      "fo\0228\n\014position_vcs\030\001 \001(\0132\".autodrive.wor"
      "kflow.proto.Vector3f\022:\n\016position_world\030\002"
      " \001(\0132\".autodrive.workflow.proto.Vector3f"
      "\022\016\n\006length\030\003 \001(\002\022\r\n\005width\030\004 \001(\002\022\017\n\007yaw_v"
      "cs\030\005 \001(\002\022\021\n\tyaw_world\030\006 \001(\002\022\021\n\talpha_vcs"
      "\030\007 \001(\002\022\023\n\013alpha_world\030\010 \001(\002\0227\n\013corners_v"
      "cs\030\t \003(\0132\".autodrive.workflow.proto.Vect"
      "or3f\0229\n\rcorners_world\030\n \003(\0132\".autodrive."
      "workflow.proto.Vector3f\022\023\n\013slotline_w0\030\013"
      " \001(\002\022\023\n\013slotline_w1\030\014 \001(\002\"\231\001\n\016ParkingRod"
      "Info\022:\n\016end_points_vcs\030\001 \003(\0132\".autodrive"
      ".workflow.proto.Vector3f\022<\n\020end_points_w"
      "orld\030\002 \003(\0132\".autodrive.workflow.proto.Ve"
      "ctor3f\022\r\n\005valid\030\003 \001(\010\"\342\001\n\017ParkingLockInf"
      "o\0225\n\tpoint_vcs\030\001 \001(\0132\".autodrive.workflo"
      "w.proto.Vector3f\0227\n\013point_world\030\002 \001(\0132\"."
      "autodrive.workflow.proto.Vector3f\022P\n\016par"
      "king_status\030\003 \001(\01628.autodrive.workflow.p"
      "roto.parking_slot.ParkingLockStatus\022\r\n\005v"
      "alid\030\004 \001(\010\"\203\003\n\014BoundaryInfo\0226\n\npoints_vc"
      "s\030\001 \003(\0132\".autodrive.workflow.proto.Vecto"
      "r3f\0228\n\014points_world\030\002 \003(\0132\".autodrive.wo"
      "rkflow.proto.Vector3f\022P\n\021boundaries_stat"
      "us\030\003 \003(\01625.autodrive.workflow.proto.park"
      "ing_slot.BoundaryStatus\022\031\n\021boundaries_he"
      "ight\030\004 \003(\002\022W\n\025boundaries_fix_status\030\005 \003("
      "\01628.autodrive.workflow.proto.parking_slo"
      "t.BoundaryFixStatus\022;\n\017points_delta_ss\030\006"
      " \003(\0132\".autodrive.workflow.proto.Vector3f"
      "\"\213\007\n\017ParkingSlotInfo\022\n\n\002id\030\001 \001(\005\022\r\n\005vali"
      "d\030\002 \001(\005\022\014\n\004conf\030\003 \001(\002\022I\n\016polygon_points\030"
      "\004 \003(\01321.autodrive.workflow.proto.parking"
      "_slot.CornerInfo\022=\n\004pose\030\005 \001(\0132/.autodri"
      "ve.workflow.proto.parking_slot.PoseInfo\022"
      "J\n\013parking_rod\030\006 \001(\01325.autodrive.workflo"
      "w.proto.parking_slot.ParkingRodInfo\022Q\n\021p"
      "arking_lock_info\030\007 \001(\01326.autodrive.workf"
      "low.proto.parking_slot.ParkingLockInfo\022E"
      "\n\010boundary\030\010 \001(\01323.autodrive.workflow.pr"
      "oto.parking_slot.BoundaryInfo\022@\n\004type\030\t "
      "\001(\01622.autodrive.workflow.proto.parking_s"
      "lot.ParkingType\022P\n\020occupancy_status\030\n \001("
      "\01626.autodrive.workflow.proto.parking_slo"
      "t.OccupancyStatus\022L\n\016parking_source\030\013 \001("
      "\01624.autodrive.workflow.proto.parking_slo"
      "t.ParkingSource\022B\n\005stage\030\014 \001(\01623.autodri"
      "ve.workflow.proto.parking_slot.ParkingSt"
      "age\022P\n\022occupancy_obs_type\030\r \001(\01624.autodr"
      "ive.workflow.proto.parking_slot.OccupyOb"
      "jType\022\016\n\006str_id\030\016 \001(\t\022W\n\024parking_release"
      "_mode\030\017 \001(\01629.autodrive.workflow.proto.p"
      "arking_slot.ParkingReleaseMode*s\n\013Parkin"
      "gType\022\027\n\023kParkingTypeUnknown\020\000\022\030\n\024kParki"
      "ngTypeVertical\020\001\022\030\n\024kParkingTypeParallel"
      "\020\002\022\027\n\023kParkingTypeOblique\020\003*m\n\017Occupancy"
      "Status\022\033\n\027kOccupancyStatusUnknown\020\000\022\034\n\030k"
      "OccupancyStatusOccupied\020\001\022\037\n\033kOccupancyS"
      "tatusNotOccupied\020\002*w\n\rParkingSource\022\035\n\031k"
      "ParkingSourceUnspecified\020\000\022\025\n\021kParkingSo"
      "urceIpm\020\001\022\025\n\021kParkingSourceUss\020\002\022\031\n\025kPar"
      "kingSourceUserSel\020\003*\256\001\n\014ParkingStage\022\027\n\023"
      "kParkingStageUninit\020\000\022\034\n\030kParkingStageUn"
      "converged\020\001\022\032\n\026kParkingStageConverged\020\002\022"
      "\034\n\030kParkingStageUpdateError\020\003\022\025\n\021kParkin"
      "gStageLost\020\004\022\026\n\022kParkingStageFixed\020\005*k\n\021"
      "ParkingLockStatus\022\035\n\031kParkingLockStatusU"
      "nknown\020\000\022\032\n\026kParkingLockStatusOpen\020\001\022\033\n\027"
      "kParkingLockStatusClose\020\002*y\n\016BoundarySta"
      "tus\022\036\n\032kBoundaryStatusUnspecified\020\000\022\026\n\022k"
      "BoundaryStatusLow\020\001\022\027\n\023kBoundaryStatusHi"
      "gh\020\002\022\026\n\022kBoundaryStatusMid\020\003*r\n\021Boundary"
      "FixStatus\022!\n\035kBoundaryFixStatusUnspecifi"
      "ed\020\000\022\035\n\031kBoundaryFixStatusUnfixed\020\001\022\033\n\027k"
      "BoundaryFixStatusFixed\020\002*\230\003\n\rOccupyObjTy"
      "pe\022\031\n\025kOccupyObjTypeVehicle\020\000\022\034\n\030kOccupy"
      "ObjTypePedestrain\020\001\022\031\n\025kOccupyObjTypeCyc"
      "list\020\002\022\030\n\024kOccupyObjTypeAnimal\020\003\022\035\n\031kOcc"
      "upyObjTypeTrafficCone\0202\022\036\n\032kOccupyObjTyp"
      "eCementColumn\0203\022\035\n\031kOccupyObjTypeParking"
      "Lock\0204\022\034\n\030kOccupyObjTypeAFrameSign\0205\022\026\n\022"
      "kOccupyObjTypeCurb\0206\022\027\n\023kOccupyObjTypeFe"
      "nce\0207\022\036\n\032kOccupyObjTypeWaterBarrier\0208\022\031\n"
      "\025kOccupyObjTypeTrolley\0209\022\026\n\022kOccupyObjTy"
      "peWall\020:\022\031\n\025kOccupyObjTypeUnknown\020d*A\n\022P"
      "arkingReleaseMode\022\r\n\tkNoneMode\020\000\022\r\n\tkRea"
      "lTime\020\001\022\r\n\tkTracking\020\002b\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 3710);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "parking_slot.proto", &protobuf_RegisterTypes);
  ::protobuf_basic_2eproto::AddDescriptors();
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_parking_5fslot_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
namespace parking_slot {
const ::google::protobuf::EnumDescriptor* ParkingType_descriptor() {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_parking_5fslot_2eproto::file_level_enum_descriptors[0];
}
bool ParkingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* OccupancyStatus_descriptor() {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_parking_5fslot_2eproto::file_level_enum_descriptors[1];
}
bool OccupancyStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ParkingSource_descriptor() {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_parking_5fslot_2eproto::file_level_enum_descriptors[2];
}
bool ParkingSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ParkingStage_descriptor() {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_parking_5fslot_2eproto::file_level_enum_descriptors[3];
}
bool ParkingStage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ParkingLockStatus_descriptor() {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_parking_5fslot_2eproto::file_level_enum_descriptors[4];
}
bool ParkingLockStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* BoundaryStatus_descriptor() {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_parking_5fslot_2eproto::file_level_enum_descriptors[5];
}
bool BoundaryStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* BoundaryFixStatus_descriptor() {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_parking_5fslot_2eproto::file_level_enum_descriptors[6];
}
bool BoundaryFixStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* OccupyObjType_descriptor() {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_parking_5fslot_2eproto::file_level_enum_descriptors[7];
}
bool OccupyObjType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 100:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ParkingReleaseMode_descriptor() {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_parking_5fslot_2eproto::file_level_enum_descriptors[8];
}
bool ParkingReleaseMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void CornerInfo::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::parking_slot::_CornerInfo_default_instance_._instance.get_mutable()->point_vcs_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
  ::autodrive::workflow::proto::parking_slot::_CornerInfo_default_instance_._instance.get_mutable()->point_world_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
  ::autodrive::workflow::proto::parking_slot::_CornerInfo_default_instance_._instance.get_mutable()->point_cov_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
}
void CornerInfo::clear_point_vcs() {
  if (GetArenaNoVirtual() == NULL && point_vcs_ != NULL) {
    delete point_vcs_;
  }
  point_vcs_ = NULL;
}
void CornerInfo::clear_point_world() {
  if (GetArenaNoVirtual() == NULL && point_world_ != NULL) {
    delete point_world_;
  }
  point_world_ = NULL;
}
void CornerInfo::clear_point_cov() {
  if (GetArenaNoVirtual() == NULL && point_cov_ != NULL) {
    delete point_cov_;
  }
  point_cov_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CornerInfo::kPointVcsFieldNumber;
const int CornerInfo::kPointWorldFieldNumber;
const int CornerInfo::kPointCovFieldNumber;
const int CornerInfo::kValidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CornerInfo::CornerInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_parking_5fslot_2eproto::InitDefaultsCornerInfo();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.parking_slot.CornerInfo)
}
CornerInfo::CornerInfo(const CornerInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_point_vcs()) {
    point_vcs_ = new ::autodrive::workflow::proto::Vector3f(*from.point_vcs_);
  } else {
    point_vcs_ = NULL;
  }
  if (from.has_point_world()) {
    point_world_ = new ::autodrive::workflow::proto::Vector3f(*from.point_world_);
  } else {
    point_world_ = NULL;
  }
  if (from.has_point_cov()) {
    point_cov_ = new ::autodrive::workflow::proto::Vector3f(*from.point_cov_);
  } else {
    point_cov_ = NULL;
  }
  valid_ = from.valid_;
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.parking_slot.CornerInfo)
}

void CornerInfo::SharedCtor() {
  ::memset(&point_vcs_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&valid_) -
      reinterpret_cast<char*>(&point_vcs_)) + sizeof(valid_));
  _cached_size_ = 0;
}

CornerInfo::~CornerInfo() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.parking_slot.CornerInfo)
  SharedDtor();
}

void CornerInfo::SharedDtor() {
  if (this != internal_default_instance()) delete point_vcs_;
  if (this != internal_default_instance()) delete point_world_;
  if (this != internal_default_instance()) delete point_cov_;
}

void CornerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CornerInfo::descriptor() {
  ::protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CornerInfo& CornerInfo::default_instance() {
  ::protobuf_parking_5fslot_2eproto::InitDefaultsCornerInfo();
  return *internal_default_instance();
}

CornerInfo* CornerInfo::New(::google::protobuf::Arena* arena) const {
  CornerInfo* n = new CornerInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CornerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.parking_slot.CornerInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && point_vcs_ != NULL) {
    delete point_vcs_;
  }
  point_vcs_ = NULL;
  if (GetArenaNoVirtual() == NULL && point_world_ != NULL) {
    delete point_world_;
  }
  point_world_ = NULL;
  if (GetArenaNoVirtual() == NULL && point_cov_ != NULL) {
    delete point_cov_;
  }
  point_cov_ = NULL;
  valid_ = false;
  _internal_metadata_.Clear();
}

bool CornerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.parking_slot.CornerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.Vector3f point_vcs = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_point_vcs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Vector3f point_world = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_point_world()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Vector3f point_cov = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_point_cov()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool valid = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &valid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.parking_slot.CornerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.parking_slot.CornerInfo)
  return false;
#undef DO_
}

void CornerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.parking_slot.CornerInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f point_vcs = 1;
  if (this->has_point_vcs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->point_vcs_, output);
  }

  // .autodrive.workflow.proto.Vector3f point_world = 2;
  if (this->has_point_world()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->point_world_, output);
  }

  // .autodrive.workflow.proto.Vector3f point_cov = 3;
  if (this->has_point_cov()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->point_cov_, output);
  }

  // bool valid = 4;
  if (this->valid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->valid(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.parking_slot.CornerInfo)
}

::google::protobuf::uint8* CornerInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.parking_slot.CornerInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f point_vcs = 1;
  if (this->has_point_vcs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->point_vcs_, deterministic, target);
  }

  // .autodrive.workflow.proto.Vector3f point_world = 2;
  if (this->has_point_world()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->point_world_, deterministic, target);
  }

  // .autodrive.workflow.proto.Vector3f point_cov = 3;
  if (this->has_point_cov()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, *this->point_cov_, deterministic, target);
  }

  // bool valid = 4;
  if (this->valid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->valid(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.parking_slot.CornerInfo)
  return target;
}

size_t CornerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.parking_slot.CornerInfo)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .autodrive.workflow.proto.Vector3f point_vcs = 1;
  if (this->has_point_vcs()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->point_vcs_);
  }

  // .autodrive.workflow.proto.Vector3f point_world = 2;
  if (this->has_point_world()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->point_world_);
  }

  // .autodrive.workflow.proto.Vector3f point_cov = 3;
  if (this->has_point_cov()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->point_cov_);
  }

  // bool valid = 4;
  if (this->valid() != 0) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CornerInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.parking_slot.CornerInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const CornerInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CornerInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.parking_slot.CornerInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.parking_slot.CornerInfo)
    MergeFrom(*source);
  }
}

void CornerInfo::MergeFrom(const CornerInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.parking_slot.CornerInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_point_vcs()) {
    mutable_point_vcs()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.point_vcs());
  }
  if (from.has_point_world()) {
    mutable_point_world()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.point_world());
  }
  if (from.has_point_cov()) {
    mutable_point_cov()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.point_cov());
  }
  if (from.valid() != 0) {
    set_valid(from.valid());
  }
}

void CornerInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.parking_slot.CornerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CornerInfo::CopyFrom(const CornerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.parking_slot.CornerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CornerInfo::IsInitialized() const {
  return true;
}

void CornerInfo::Swap(CornerInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CornerInfo::InternalSwap(CornerInfo* other) {
  using std::swap;
  swap(point_vcs_, other->point_vcs_);
  swap(point_world_, other->point_world_);
  swap(point_cov_, other->point_cov_);
  swap(valid_, other->valid_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CornerInfo::GetMetadata() const {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void PoseInfo::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::parking_slot::_PoseInfo_default_instance_._instance.get_mutable()->position_vcs_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
  ::autodrive::workflow::proto::parking_slot::_PoseInfo_default_instance_._instance.get_mutable()->position_world_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
}
void PoseInfo::clear_position_vcs() {
  if (GetArenaNoVirtual() == NULL && position_vcs_ != NULL) {
    delete position_vcs_;
  }
  position_vcs_ = NULL;
}
void PoseInfo::clear_position_world() {
  if (GetArenaNoVirtual() == NULL && position_world_ != NULL) {
    delete position_world_;
  }
  position_world_ = NULL;
}
void PoseInfo::clear_corners_vcs() {
  corners_vcs_.Clear();
}
void PoseInfo::clear_corners_world() {
  corners_world_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PoseInfo::kPositionVcsFieldNumber;
const int PoseInfo::kPositionWorldFieldNumber;
const int PoseInfo::kLengthFieldNumber;
const int PoseInfo::kWidthFieldNumber;
const int PoseInfo::kYawVcsFieldNumber;
const int PoseInfo::kYawWorldFieldNumber;
const int PoseInfo::kAlphaVcsFieldNumber;
const int PoseInfo::kAlphaWorldFieldNumber;
const int PoseInfo::kCornersVcsFieldNumber;
const int PoseInfo::kCornersWorldFieldNumber;
const int PoseInfo::kSlotlineW0FieldNumber;
const int PoseInfo::kSlotlineW1FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PoseInfo::PoseInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_parking_5fslot_2eproto::InitDefaultsPoseInfo();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.parking_slot.PoseInfo)
}
PoseInfo::PoseInfo(const PoseInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      corners_vcs_(from.corners_vcs_),
      corners_world_(from.corners_world_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position_vcs()) {
    position_vcs_ = new ::autodrive::workflow::proto::Vector3f(*from.position_vcs_);
  } else {
    position_vcs_ = NULL;
  }
  if (from.has_position_world()) {
    position_world_ = new ::autodrive::workflow::proto::Vector3f(*from.position_world_);
  } else {
    position_world_ = NULL;
  }
  ::memcpy(&length_, &from.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&slotline_w1_) -
    reinterpret_cast<char*>(&length_)) + sizeof(slotline_w1_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.parking_slot.PoseInfo)
}

void PoseInfo::SharedCtor() {
  ::memset(&position_vcs_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&slotline_w1_) -
      reinterpret_cast<char*>(&position_vcs_)) + sizeof(slotline_w1_));
  _cached_size_ = 0;
}

PoseInfo::~PoseInfo() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.parking_slot.PoseInfo)
  SharedDtor();
}

void PoseInfo::SharedDtor() {
  if (this != internal_default_instance()) delete position_vcs_;
  if (this != internal_default_instance()) delete position_world_;
}

void PoseInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PoseInfo::descriptor() {
  ::protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PoseInfo& PoseInfo::default_instance() {
  ::protobuf_parking_5fslot_2eproto::InitDefaultsPoseInfo();
  return *internal_default_instance();
}

PoseInfo* PoseInfo::New(::google::protobuf::Arena* arena) const {
  PoseInfo* n = new PoseInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PoseInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.parking_slot.PoseInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  corners_vcs_.Clear();
  corners_world_.Clear();
  if (GetArenaNoVirtual() == NULL && position_vcs_ != NULL) {
    delete position_vcs_;
  }
  position_vcs_ = NULL;
  if (GetArenaNoVirtual() == NULL && position_world_ != NULL) {
    delete position_world_;
  }
  position_world_ = NULL;
  ::memset(&length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&slotline_w1_) -
      reinterpret_cast<char*>(&length_)) + sizeof(slotline_w1_));
  _internal_metadata_.Clear();
}

bool PoseInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.parking_slot.PoseInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.Vector3f position_vcs = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position_vcs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Vector3f position_world = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position_world()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float length = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u /* 29 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float width = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u /* 37 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float yaw_vcs = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(45u /* 45 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_vcs_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float yaw_world = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(53u /* 53 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_world_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float alpha_vcs = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(61u /* 61 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alpha_vcs_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float alpha_world = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(69u /* 69 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alpha_world_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.Vector3f corners_vcs = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_corners_vcs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.Vector3f corners_world = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u /* 82 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_corners_world()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float slotline_w0 = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(93u /* 93 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &slotline_w0_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float slotline_w1 = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(101u /* 101 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &slotline_w1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.parking_slot.PoseInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.parking_slot.PoseInfo)
  return false;
#undef DO_
}

void PoseInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.parking_slot.PoseInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f position_vcs = 1;
  if (this->has_position_vcs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_vcs_, output);
  }

  // .autodrive.workflow.proto.Vector3f position_world = 2;
  if (this->has_position_world()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->position_world_, output);
  }

  // float length = 3;
  if (this->length() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->length(), output);
  }

  // float width = 4;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->width(), output);
  }

  // float yaw_vcs = 5;
  if (this->yaw_vcs() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->yaw_vcs(), output);
  }

  // float yaw_world = 6;
  if (this->yaw_world() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->yaw_world(), output);
  }

  // float alpha_vcs = 7;
  if (this->alpha_vcs() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->alpha_vcs(), output);
  }

  // float alpha_world = 8;
  if (this->alpha_world() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->alpha_world(), output);
  }

  // repeated .autodrive.workflow.proto.Vector3f corners_vcs = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->corners_vcs_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->corners_vcs(static_cast<int>(i)), output);
  }

  // repeated .autodrive.workflow.proto.Vector3f corners_world = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->corners_world_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->corners_world(static_cast<int>(i)), output);
  }

  // float slotline_w0 = 11;
  if (this->slotline_w0() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->slotline_w0(), output);
  }

  // float slotline_w1 = 12;
  if (this->slotline_w1() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->slotline_w1(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.parking_slot.PoseInfo)
}

::google::protobuf::uint8* PoseInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.parking_slot.PoseInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f position_vcs = 1;
  if (this->has_position_vcs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->position_vcs_, deterministic, target);
  }

  // .autodrive.workflow.proto.Vector3f position_world = 2;
  if (this->has_position_world()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->position_world_, deterministic, target);
  }

  // float length = 3;
  if (this->length() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->length(), target);
  }

  // float width = 4;
  if (this->width() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->width(), target);
  }

  // float yaw_vcs = 5;
  if (this->yaw_vcs() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->yaw_vcs(), target);
  }

  // float yaw_world = 6;
  if (this->yaw_world() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->yaw_world(), target);
  }

  // float alpha_vcs = 7;
  if (this->alpha_vcs() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->alpha_vcs(), target);
  }

  // float alpha_world = 8;
  if (this->alpha_world() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->alpha_world(), target);
  }

  // repeated .autodrive.workflow.proto.Vector3f corners_vcs = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->corners_vcs_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, this->corners_vcs(static_cast<int>(i)), deterministic, target);
  }

  // repeated .autodrive.workflow.proto.Vector3f corners_world = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->corners_world_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, this->corners_world(static_cast<int>(i)), deterministic, target);
  }

  // float slotline_w0 = 11;
  if (this->slotline_w0() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->slotline_w0(), target);
  }

  // float slotline_w1 = 12;
  if (this->slotline_w1() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->slotline_w1(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.parking_slot.PoseInfo)
  return target;
}

size_t PoseInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.parking_slot.PoseInfo)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.Vector3f corners_vcs = 9;
  {
    unsigned int count = static_cast<unsigned int>(this->corners_vcs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->corners_vcs(static_cast<int>(i)));
    }
  }

  // repeated .autodrive.workflow.proto.Vector3f corners_world = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->corners_world_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->corners_world(static_cast<int>(i)));
    }
  }

  // .autodrive.workflow.proto.Vector3f position_vcs = 1;
  if (this->has_position_vcs()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->position_vcs_);
  }

  // .autodrive.workflow.proto.Vector3f position_world = 2;
  if (this->has_position_world()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->position_world_);
  }

  // float length = 3;
  if (this->length() != 0) {
    total_size += 1 + 4;
  }

  // float width = 4;
  if (this->width() != 0) {
    total_size += 1 + 4;
  }

  // float yaw_vcs = 5;
  if (this->yaw_vcs() != 0) {
    total_size += 1 + 4;
  }

  // float yaw_world = 6;
  if (this->yaw_world() != 0) {
    total_size += 1 + 4;
  }

  // float alpha_vcs = 7;
  if (this->alpha_vcs() != 0) {
    total_size += 1 + 4;
  }

  // float alpha_world = 8;
  if (this->alpha_world() != 0) {
    total_size += 1 + 4;
  }

  // float slotline_w0 = 11;
  if (this->slotline_w0() != 0) {
    total_size += 1 + 4;
  }

  // float slotline_w1 = 12;
  if (this->slotline_w1() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PoseInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.parking_slot.PoseInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const PoseInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PoseInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.parking_slot.PoseInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.parking_slot.PoseInfo)
    MergeFrom(*source);
  }
}

void PoseInfo::MergeFrom(const PoseInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.parking_slot.PoseInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  corners_vcs_.MergeFrom(from.corners_vcs_);
  corners_world_.MergeFrom(from.corners_world_);
  if (from.has_position_vcs()) {
    mutable_position_vcs()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.position_vcs());
  }
  if (from.has_position_world()) {
    mutable_position_world()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.position_world());
  }
  if (from.length() != 0) {
    set_length(from.length());
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.yaw_vcs() != 0) {
    set_yaw_vcs(from.yaw_vcs());
  }
  if (from.yaw_world() != 0) {
    set_yaw_world(from.yaw_world());
  }
  if (from.alpha_vcs() != 0) {
    set_alpha_vcs(from.alpha_vcs());
  }
  if (from.alpha_world() != 0) {
    set_alpha_world(from.alpha_world());
  }
  if (from.slotline_w0() != 0) {
    set_slotline_w0(from.slotline_w0());
  }
  if (from.slotline_w1() != 0) {
    set_slotline_w1(from.slotline_w1());
  }
}

void PoseInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.parking_slot.PoseInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PoseInfo::CopyFrom(const PoseInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.parking_slot.PoseInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PoseInfo::IsInitialized() const {
  return true;
}

void PoseInfo::Swap(PoseInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PoseInfo::InternalSwap(PoseInfo* other) {
  using std::swap;
  corners_vcs_.InternalSwap(&other->corners_vcs_);
  corners_world_.InternalSwap(&other->corners_world_);
  swap(position_vcs_, other->position_vcs_);
  swap(position_world_, other->position_world_);
  swap(length_, other->length_);
  swap(width_, other->width_);
  swap(yaw_vcs_, other->yaw_vcs_);
  swap(yaw_world_, other->yaw_world_);
  swap(alpha_vcs_, other->alpha_vcs_);
  swap(alpha_world_, other->alpha_world_);
  swap(slotline_w0_, other->slotline_w0_);
  swap(slotline_w1_, other->slotline_w1_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PoseInfo::GetMetadata() const {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void ParkingRodInfo::InitAsDefaultInstance() {
}
void ParkingRodInfo::clear_end_points_vcs() {
  end_points_vcs_.Clear();
}
void ParkingRodInfo::clear_end_points_world() {
  end_points_world_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ParkingRodInfo::kEndPointsVcsFieldNumber;
const int ParkingRodInfo::kEndPointsWorldFieldNumber;
const int ParkingRodInfo::kValidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ParkingRodInfo::ParkingRodInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_parking_5fslot_2eproto::InitDefaultsParkingRodInfo();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
}
ParkingRodInfo::ParkingRodInfo(const ParkingRodInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      end_points_vcs_(from.end_points_vcs_),
      end_points_world_(from.end_points_world_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  valid_ = from.valid_;
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
}

void ParkingRodInfo::SharedCtor() {
  valid_ = false;
  _cached_size_ = 0;
}

ParkingRodInfo::~ParkingRodInfo() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  SharedDtor();
}

void ParkingRodInfo::SharedDtor() {
}

void ParkingRodInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ParkingRodInfo::descriptor() {
  ::protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ParkingRodInfo& ParkingRodInfo::default_instance() {
  ::protobuf_parking_5fslot_2eproto::InitDefaultsParkingRodInfo();
  return *internal_default_instance();
}

ParkingRodInfo* ParkingRodInfo::New(::google::protobuf::Arena* arena) const {
  ParkingRodInfo* n = new ParkingRodInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ParkingRodInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  end_points_vcs_.Clear();
  end_points_world_.Clear();
  valid_ = false;
  _internal_metadata_.Clear();
}

bool ParkingRodInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .autodrive.workflow.proto.Vector3f end_points_vcs = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_end_points_vcs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.Vector3f end_points_world = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_end_points_world()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool valid = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &valid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  return false;
#undef DO_
}

void ParkingRodInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.Vector3f end_points_vcs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->end_points_vcs_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->end_points_vcs(static_cast<int>(i)), output);
  }

  // repeated .autodrive.workflow.proto.Vector3f end_points_world = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->end_points_world_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->end_points_world(static_cast<int>(i)), output);
  }

  // bool valid = 3;
  if (this->valid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->valid(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
}

::google::protobuf::uint8* ParkingRodInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.Vector3f end_points_vcs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->end_points_vcs_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->end_points_vcs(static_cast<int>(i)), deterministic, target);
  }

  // repeated .autodrive.workflow.proto.Vector3f end_points_world = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->end_points_world_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->end_points_world(static_cast<int>(i)), deterministic, target);
  }

  // bool valid = 3;
  if (this->valid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->valid(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  return target;
}

size_t ParkingRodInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.Vector3f end_points_vcs = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->end_points_vcs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->end_points_vcs(static_cast<int>(i)));
    }
  }

  // repeated .autodrive.workflow.proto.Vector3f end_points_world = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->end_points_world_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->end_points_world(static_cast<int>(i)));
    }
  }

  // bool valid = 3;
  if (this->valid() != 0) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParkingRodInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const ParkingRodInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ParkingRodInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
    MergeFrom(*source);
  }
}

void ParkingRodInfo::MergeFrom(const ParkingRodInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  end_points_vcs_.MergeFrom(from.end_points_vcs_);
  end_points_world_.MergeFrom(from.end_points_world_);
  if (from.valid() != 0) {
    set_valid(from.valid());
  }
}

void ParkingRodInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParkingRodInfo::CopyFrom(const ParkingRodInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.parking_slot.ParkingRodInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParkingRodInfo::IsInitialized() const {
  return true;
}

void ParkingRodInfo::Swap(ParkingRodInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ParkingRodInfo::InternalSwap(ParkingRodInfo* other) {
  using std::swap;
  end_points_vcs_.InternalSwap(&other->end_points_vcs_);
  end_points_world_.InternalSwap(&other->end_points_world_);
  swap(valid_, other->valid_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ParkingRodInfo::GetMetadata() const {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void ParkingLockInfo::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::parking_slot::_ParkingLockInfo_default_instance_._instance.get_mutable()->point_vcs_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
  ::autodrive::workflow::proto::parking_slot::_ParkingLockInfo_default_instance_._instance.get_mutable()->point_world_ = const_cast< ::autodrive::workflow::proto::Vector3f*>(
      ::autodrive::workflow::proto::Vector3f::internal_default_instance());
}
void ParkingLockInfo::clear_point_vcs() {
  if (GetArenaNoVirtual() == NULL && point_vcs_ != NULL) {
    delete point_vcs_;
  }
  point_vcs_ = NULL;
}
void ParkingLockInfo::clear_point_world() {
  if (GetArenaNoVirtual() == NULL && point_world_ != NULL) {
    delete point_world_;
  }
  point_world_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ParkingLockInfo::kPointVcsFieldNumber;
const int ParkingLockInfo::kPointWorldFieldNumber;
const int ParkingLockInfo::kParkingStatusFieldNumber;
const int ParkingLockInfo::kValidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ParkingLockInfo::ParkingLockInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_parking_5fslot_2eproto::InitDefaultsParkingLockInfo();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
}
ParkingLockInfo::ParkingLockInfo(const ParkingLockInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_point_vcs()) {
    point_vcs_ = new ::autodrive::workflow::proto::Vector3f(*from.point_vcs_);
  } else {
    point_vcs_ = NULL;
  }
  if (from.has_point_world()) {
    point_world_ = new ::autodrive::workflow::proto::Vector3f(*from.point_world_);
  } else {
    point_world_ = NULL;
  }
  ::memcpy(&parking_status_, &from.parking_status_,
    static_cast<size_t>(reinterpret_cast<char*>(&valid_) -
    reinterpret_cast<char*>(&parking_status_)) + sizeof(valid_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
}

void ParkingLockInfo::SharedCtor() {
  ::memset(&point_vcs_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&valid_) -
      reinterpret_cast<char*>(&point_vcs_)) + sizeof(valid_));
  _cached_size_ = 0;
}

ParkingLockInfo::~ParkingLockInfo() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  SharedDtor();
}

void ParkingLockInfo::SharedDtor() {
  if (this != internal_default_instance()) delete point_vcs_;
  if (this != internal_default_instance()) delete point_world_;
}

void ParkingLockInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ParkingLockInfo::descriptor() {
  ::protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ParkingLockInfo& ParkingLockInfo::default_instance() {
  ::protobuf_parking_5fslot_2eproto::InitDefaultsParkingLockInfo();
  return *internal_default_instance();
}

ParkingLockInfo* ParkingLockInfo::New(::google::protobuf::Arena* arena) const {
  ParkingLockInfo* n = new ParkingLockInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ParkingLockInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && point_vcs_ != NULL) {
    delete point_vcs_;
  }
  point_vcs_ = NULL;
  if (GetArenaNoVirtual() == NULL && point_world_ != NULL) {
    delete point_world_;
  }
  point_world_ = NULL;
  ::memset(&parking_status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&valid_) -
      reinterpret_cast<char*>(&parking_status_)) + sizeof(valid_));
  _internal_metadata_.Clear();
}

bool ParkingLockInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .autodrive.workflow.proto.Vector3f point_vcs = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_point_vcs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.Vector3f point_world = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_point_world()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.ParkingLockStatus parking_status = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_parking_status(static_cast< ::autodrive::workflow::proto::parking_slot::ParkingLockStatus >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool valid = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &valid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  return false;
#undef DO_
}

void ParkingLockInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f point_vcs = 1;
  if (this->has_point_vcs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->point_vcs_, output);
  }

  // .autodrive.workflow.proto.Vector3f point_world = 2;
  if (this->has_point_world()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->point_world_, output);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingLockStatus parking_status = 3;
  if (this->parking_status() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->parking_status(), output);
  }

  // bool valid = 4;
  if (this->valid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->valid(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
}

::google::protobuf::uint8* ParkingLockInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .autodrive.workflow.proto.Vector3f point_vcs = 1;
  if (this->has_point_vcs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->point_vcs_, deterministic, target);
  }

  // .autodrive.workflow.proto.Vector3f point_world = 2;
  if (this->has_point_world()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, *this->point_world_, deterministic, target);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingLockStatus parking_status = 3;
  if (this->parking_status() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->parking_status(), target);
  }

  // bool valid = 4;
  if (this->valid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->valid(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  return target;
}

size_t ParkingLockInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .autodrive.workflow.proto.Vector3f point_vcs = 1;
  if (this->has_point_vcs()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->point_vcs_);
  }

  // .autodrive.workflow.proto.Vector3f point_world = 2;
  if (this->has_point_world()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->point_world_);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingLockStatus parking_status = 3;
  if (this->parking_status() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->parking_status());
  }

  // bool valid = 4;
  if (this->valid() != 0) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParkingLockInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const ParkingLockInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ParkingLockInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
    MergeFrom(*source);
  }
}

void ParkingLockInfo::MergeFrom(const ParkingLockInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_point_vcs()) {
    mutable_point_vcs()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.point_vcs());
  }
  if (from.has_point_world()) {
    mutable_point_world()->::autodrive::workflow::proto::Vector3f::MergeFrom(from.point_world());
  }
  if (from.parking_status() != 0) {
    set_parking_status(from.parking_status());
  }
  if (from.valid() != 0) {
    set_valid(from.valid());
  }
}

void ParkingLockInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParkingLockInfo::CopyFrom(const ParkingLockInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.parking_slot.ParkingLockInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParkingLockInfo::IsInitialized() const {
  return true;
}

void ParkingLockInfo::Swap(ParkingLockInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ParkingLockInfo::InternalSwap(ParkingLockInfo* other) {
  using std::swap;
  swap(point_vcs_, other->point_vcs_);
  swap(point_world_, other->point_world_);
  swap(parking_status_, other->parking_status_);
  swap(valid_, other->valid_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ParkingLockInfo::GetMetadata() const {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void BoundaryInfo::InitAsDefaultInstance() {
}
void BoundaryInfo::clear_points_vcs() {
  points_vcs_.Clear();
}
void BoundaryInfo::clear_points_world() {
  points_world_.Clear();
}
void BoundaryInfo::clear_points_delta_ss() {
  points_delta_ss_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BoundaryInfo::kPointsVcsFieldNumber;
const int BoundaryInfo::kPointsWorldFieldNumber;
const int BoundaryInfo::kBoundariesStatusFieldNumber;
const int BoundaryInfo::kBoundariesHeightFieldNumber;
const int BoundaryInfo::kBoundariesFixStatusFieldNumber;
const int BoundaryInfo::kPointsDeltaSsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BoundaryInfo::BoundaryInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_parking_5fslot_2eproto::InitDefaultsBoundaryInfo();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.parking_slot.BoundaryInfo)
}
BoundaryInfo::BoundaryInfo(const BoundaryInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      points_vcs_(from.points_vcs_),
      points_world_(from.points_world_),
      boundaries_status_(from.boundaries_status_),
      boundaries_height_(from.boundaries_height_),
      boundaries_fix_status_(from.boundaries_fix_status_),
      points_delta_ss_(from.points_delta_ss_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.parking_slot.BoundaryInfo)
}

void BoundaryInfo::SharedCtor() {
  _cached_size_ = 0;
}

BoundaryInfo::~BoundaryInfo() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  SharedDtor();
}

void BoundaryInfo::SharedDtor() {
}

void BoundaryInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BoundaryInfo::descriptor() {
  ::protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const BoundaryInfo& BoundaryInfo::default_instance() {
  ::protobuf_parking_5fslot_2eproto::InitDefaultsBoundaryInfo();
  return *internal_default_instance();
}

BoundaryInfo* BoundaryInfo::New(::google::protobuf::Arena* arena) const {
  BoundaryInfo* n = new BoundaryInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BoundaryInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points_vcs_.Clear();
  points_world_.Clear();
  boundaries_status_.Clear();
  boundaries_height_.Clear();
  boundaries_fix_status_.Clear();
  points_delta_ss_.Clear();
  _internal_metadata_.Clear();
}

bool BoundaryInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .autodrive.workflow.proto.Vector3f points_vcs = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_points_vcs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.Vector3f points_world = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_points_world()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.parking_slot.BoundaryStatus boundaries_status = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit = input->PushLimit(static_cast<int>(length));
          while (input->BytesUntilLimit() > 0) {
            int value;
            DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
            add_boundaries_status(static_cast< ::autodrive::workflow::proto::parking_slot::BoundaryStatus >(value));
          }
          input->PopLimit(limit);
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          add_boundaries_status(static_cast< ::autodrive::workflow::proto::parking_slot::BoundaryStatus >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float boundaries_height = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_boundaries_height())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u /* 37 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 34u, input, this->mutable_boundaries_height())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.parking_slot.BoundaryFixStatus boundaries_fix_status = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          ::google::protobuf::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::google::protobuf::io::CodedInputStream::Limit limit = input->PushLimit(static_cast<int>(length));
          while (input->BytesUntilLimit() > 0) {
            int value;
            DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
            add_boundaries_fix_status(static_cast< ::autodrive::workflow::proto::parking_slot::BoundaryFixStatus >(value));
          }
          input->PopLimit(limit);
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          add_boundaries_fix_status(static_cast< ::autodrive::workflow::proto::parking_slot::BoundaryFixStatus >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.Vector3f points_delta_ss = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_points_delta_ss()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  return false;
#undef DO_
}

void BoundaryInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.Vector3f points_vcs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_vcs_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->points_vcs(static_cast<int>(i)), output);
  }

  // repeated .autodrive.workflow.proto.Vector3f points_world = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_world_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->points_world(static_cast<int>(i)), output);
  }

  // repeated .autodrive.workflow.proto.parking_slot.BoundaryStatus boundaries_status = 3;
  if (this->boundaries_status_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      output);
    output->WriteVarint32(
        static_cast< ::google::protobuf::uint32>(_boundaries_status_cached_byte_size_));
  }
  for (int i = 0, n = this->boundaries_status_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnumNoTag(
      this->boundaries_status(i), output);
  }

  // repeated float boundaries_height = 4;
  if (this->boundaries_height_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(4, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(static_cast< ::google::protobuf::uint32>(
        _boundaries_height_cached_byte_size_));
    ::google::protobuf::internal::WireFormatLite::WriteFloatArray(
      this->boundaries_height().data(), this->boundaries_height_size(), output);
  }

  // repeated .autodrive.workflow.proto.parking_slot.BoundaryFixStatus boundaries_fix_status = 5;
  if (this->boundaries_fix_status_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(
      5,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      output);
    output->WriteVarint32(
        static_cast< ::google::protobuf::uint32>(_boundaries_fix_status_cached_byte_size_));
  }
  for (int i = 0, n = this->boundaries_fix_status_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnumNoTag(
      this->boundaries_fix_status(i), output);
  }

  // repeated .autodrive.workflow.proto.Vector3f points_delta_ss = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_delta_ss_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->points_delta_ss(static_cast<int>(i)), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.parking_slot.BoundaryInfo)
}

::google::protobuf::uint8* BoundaryInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .autodrive.workflow.proto.Vector3f points_vcs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_vcs_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->points_vcs(static_cast<int>(i)), deterministic, target);
  }

  // repeated .autodrive.workflow.proto.Vector3f points_world = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_world_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->points_world(static_cast<int>(i)), deterministic, target);
  }

  // repeated .autodrive.workflow.proto.parking_slot.BoundaryStatus boundaries_status = 3;
  if (this->boundaries_status_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(      static_cast< ::google::protobuf::uint32>(
            _boundaries_status_cached_byte_size_), target);
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumNoTagToArray(
      this->boundaries_status_, target);
  }

  // repeated float boundaries_height = 4;
  if (this->boundaries_height_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      4,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
        static_cast< ::google::protobuf::int32>(
            _boundaries_height_cached_byte_size_), target);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatNoTagToArray(this->boundaries_height_, target);
  }

  // repeated .autodrive.workflow.proto.parking_slot.BoundaryFixStatus boundaries_fix_status = 5;
  if (this->boundaries_fix_status_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      5,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(      static_cast< ::google::protobuf::uint32>(
            _boundaries_fix_status_cached_byte_size_), target);
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumNoTagToArray(
      this->boundaries_fix_status_, target);
  }

  // repeated .autodrive.workflow.proto.Vector3f points_delta_ss = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->points_delta_ss_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->points_delta_ss(static_cast<int>(i)), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  return target;
}

size_t BoundaryInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.Vector3f points_vcs = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->points_vcs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->points_vcs(static_cast<int>(i)));
    }
  }

  // repeated .autodrive.workflow.proto.Vector3f points_world = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->points_world_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->points_world(static_cast<int>(i)));
    }
  }

  // repeated .autodrive.workflow.proto.parking_slot.BoundaryStatus boundaries_status = 3;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->boundaries_status_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->boundaries_status(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast< ::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _boundaries_status_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated float boundaries_height = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->boundaries_height_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast< ::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _boundaries_height_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .autodrive.workflow.proto.parking_slot.BoundaryFixStatus boundaries_fix_status = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->boundaries_fix_status_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->boundaries_fix_status(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast< ::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _boundaries_fix_status_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .autodrive.workflow.proto.Vector3f points_delta_ss = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->points_delta_ss_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->points_delta_ss(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BoundaryInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const BoundaryInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const BoundaryInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.parking_slot.BoundaryInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.parking_slot.BoundaryInfo)
    MergeFrom(*source);
  }
}

void BoundaryInfo::MergeFrom(const BoundaryInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  points_vcs_.MergeFrom(from.points_vcs_);
  points_world_.MergeFrom(from.points_world_);
  boundaries_status_.MergeFrom(from.boundaries_status_);
  boundaries_height_.MergeFrom(from.boundaries_height_);
  boundaries_fix_status_.MergeFrom(from.boundaries_fix_status_);
  points_delta_ss_.MergeFrom(from.points_delta_ss_);
}

void BoundaryInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BoundaryInfo::CopyFrom(const BoundaryInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.parking_slot.BoundaryInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoundaryInfo::IsInitialized() const {
  return true;
}

void BoundaryInfo::Swap(BoundaryInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BoundaryInfo::InternalSwap(BoundaryInfo* other) {
  using std::swap;
  points_vcs_.InternalSwap(&other->points_vcs_);
  points_world_.InternalSwap(&other->points_world_);
  boundaries_status_.InternalSwap(&other->boundaries_status_);
  boundaries_height_.InternalSwap(&other->boundaries_height_);
  boundaries_fix_status_.InternalSwap(&other->boundaries_fix_status_);
  points_delta_ss_.InternalSwap(&other->points_delta_ss_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BoundaryInfo::GetMetadata() const {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void ParkingSlotInfo::InitAsDefaultInstance() {
  ::autodrive::workflow::proto::parking_slot::_ParkingSlotInfo_default_instance_._instance.get_mutable()->pose_ = const_cast< ::autodrive::workflow::proto::parking_slot::PoseInfo*>(
      ::autodrive::workflow::proto::parking_slot::PoseInfo::internal_default_instance());
  ::autodrive::workflow::proto::parking_slot::_ParkingSlotInfo_default_instance_._instance.get_mutable()->parking_rod_ = const_cast< ::autodrive::workflow::proto::parking_slot::ParkingRodInfo*>(
      ::autodrive::workflow::proto::parking_slot::ParkingRodInfo::internal_default_instance());
  ::autodrive::workflow::proto::parking_slot::_ParkingSlotInfo_default_instance_._instance.get_mutable()->parking_lock_info_ = const_cast< ::autodrive::workflow::proto::parking_slot::ParkingLockInfo*>(
      ::autodrive::workflow::proto::parking_slot::ParkingLockInfo::internal_default_instance());
  ::autodrive::workflow::proto::parking_slot::_ParkingSlotInfo_default_instance_._instance.get_mutable()->boundary_ = const_cast< ::autodrive::workflow::proto::parking_slot::BoundaryInfo*>(
      ::autodrive::workflow::proto::parking_slot::BoundaryInfo::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ParkingSlotInfo::kIdFieldNumber;
const int ParkingSlotInfo::kValidFieldNumber;
const int ParkingSlotInfo::kConfFieldNumber;
const int ParkingSlotInfo::kPolygonPointsFieldNumber;
const int ParkingSlotInfo::kPoseFieldNumber;
const int ParkingSlotInfo::kParkingRodFieldNumber;
const int ParkingSlotInfo::kParkingLockInfoFieldNumber;
const int ParkingSlotInfo::kBoundaryFieldNumber;
const int ParkingSlotInfo::kTypeFieldNumber;
const int ParkingSlotInfo::kOccupancyStatusFieldNumber;
const int ParkingSlotInfo::kParkingSourceFieldNumber;
const int ParkingSlotInfo::kStageFieldNumber;
const int ParkingSlotInfo::kOccupancyObsTypeFieldNumber;
const int ParkingSlotInfo::kStrIdFieldNumber;
const int ParkingSlotInfo::kParkingReleaseModeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ParkingSlotInfo::ParkingSlotInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_parking_5fslot_2eproto::InitDefaultsParkingSlotInfo();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
}
ParkingSlotInfo::ParkingSlotInfo(const ParkingSlotInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      polygon_points_(from.polygon_points_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  str_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.str_id().size() > 0) {
    str_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.str_id_);
  }
  if (from.has_pose()) {
    pose_ = new ::autodrive::workflow::proto::parking_slot::PoseInfo(*from.pose_);
  } else {
    pose_ = NULL;
  }
  if (from.has_parking_rod()) {
    parking_rod_ = new ::autodrive::workflow::proto::parking_slot::ParkingRodInfo(*from.parking_rod_);
  } else {
    parking_rod_ = NULL;
  }
  if (from.has_parking_lock_info()) {
    parking_lock_info_ = new ::autodrive::workflow::proto::parking_slot::ParkingLockInfo(*from.parking_lock_info_);
  } else {
    parking_lock_info_ = NULL;
  }
  if (from.has_boundary()) {
    boundary_ = new ::autodrive::workflow::proto::parking_slot::BoundaryInfo(*from.boundary_);
  } else {
    boundary_ = NULL;
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&parking_release_mode_) -
    reinterpret_cast<char*>(&id_)) + sizeof(parking_release_mode_));
  // @@protoc_insertion_point(copy_constructor:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
}

void ParkingSlotInfo::SharedCtor() {
  str_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&pose_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&parking_release_mode_) -
      reinterpret_cast<char*>(&pose_)) + sizeof(parking_release_mode_));
  _cached_size_ = 0;
}

ParkingSlotInfo::~ParkingSlotInfo() {
  // @@protoc_insertion_point(destructor:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  SharedDtor();
}

void ParkingSlotInfo::SharedDtor() {
  str_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete pose_;
  if (this != internal_default_instance()) delete parking_rod_;
  if (this != internal_default_instance()) delete parking_lock_info_;
  if (this != internal_default_instance()) delete boundary_;
}

void ParkingSlotInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ParkingSlotInfo::descriptor() {
  ::protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ParkingSlotInfo& ParkingSlotInfo::default_instance() {
  ::protobuf_parking_5fslot_2eproto::InitDefaultsParkingSlotInfo();
  return *internal_default_instance();
}

ParkingSlotInfo* ParkingSlotInfo::New(::google::protobuf::Arena* arena) const {
  ParkingSlotInfo* n = new ParkingSlotInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ParkingSlotInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  polygon_points_.Clear();
  str_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && pose_ != NULL) {
    delete pose_;
  }
  pose_ = NULL;
  if (GetArenaNoVirtual() == NULL && parking_rod_ != NULL) {
    delete parking_rod_;
  }
  parking_rod_ = NULL;
  if (GetArenaNoVirtual() == NULL && parking_lock_info_ != NULL) {
    delete parking_lock_info_;
  }
  parking_lock_info_ = NULL;
  if (GetArenaNoVirtual() == NULL && boundary_ != NULL) {
    delete boundary_;
  }
  boundary_ = NULL;
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&parking_release_mode_) -
      reinterpret_cast<char*>(&id_)) + sizeof(parking_release_mode_));
  _internal_metadata_.Clear();
}

bool ParkingSlotInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 valid = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &valid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float conf = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u /* 29 & 0xFF */)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &conf_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .autodrive.workflow.proto.parking_slot.CornerInfo polygon_points = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_polygon_points()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.PoseInfo pose = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.ParkingRodInfo parking_rod = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_parking_rod()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.ParkingLockInfo parking_lock_info = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_parking_lock_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.BoundaryInfo boundary = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_boundary()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.ParkingType type = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::autodrive::workflow::proto::parking_slot::ParkingType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.OccupancyStatus occupancy_status = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_occupancy_status(static_cast< ::autodrive::workflow::proto::parking_slot::OccupancyStatus >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.ParkingSource parking_source = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_parking_source(static_cast< ::autodrive::workflow::proto::parking_slot::ParkingSource >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.ParkingStage stage = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u /* 96 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_stage(static_cast< ::autodrive::workflow::proto::parking_slot::ParkingStage >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.OccupyObjType occupancy_obs_type = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u /* 104 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_occupancy_obs_type(static_cast< ::autodrive::workflow::proto::parking_slot::OccupyObjType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string str_id = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(114u /* 114 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_str_id()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->str_id().data(), static_cast<int>(this->str_id().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .autodrive.workflow.proto.parking_slot.ParkingReleaseMode parking_release_mode = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(120u /* 120 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_parking_release_mode(static_cast< ::autodrive::workflow::proto::parking_slot::ParkingReleaseMode >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  return false;
#undef DO_
}

void ParkingSlotInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // int32 valid = 2;
  if (this->valid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->valid(), output);
  }

  // float conf = 3;
  if (this->conf() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->conf(), output);
  }

  // repeated .autodrive.workflow.proto.parking_slot.CornerInfo polygon_points = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->polygon_points_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->polygon_points(static_cast<int>(i)), output);
  }

  // .autodrive.workflow.proto.parking_slot.PoseInfo pose = 5;
  if (this->has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->pose_, output);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingRodInfo parking_rod = 6;
  if (this->has_parking_rod()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->parking_rod_, output);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingLockInfo parking_lock_info = 7;
  if (this->has_parking_lock_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->parking_lock_info_, output);
  }

  // .autodrive.workflow.proto.parking_slot.BoundaryInfo boundary = 8;
  if (this->has_boundary()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->boundary_, output);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingType type = 9;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->type(), output);
  }

  // .autodrive.workflow.proto.parking_slot.OccupancyStatus occupancy_status = 10;
  if (this->occupancy_status() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->occupancy_status(), output);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingSource parking_source = 11;
  if (this->parking_source() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->parking_source(), output);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingStage stage = 12;
  if (this->stage() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      12, this->stage(), output);
  }

  // .autodrive.workflow.proto.parking_slot.OccupyObjType occupancy_obs_type = 13;
  if (this->occupancy_obs_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      13, this->occupancy_obs_type(), output);
  }

  // string str_id = 14;
  if (this->str_id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->str_id().data(), static_cast<int>(this->str_id().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->str_id(), output);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingReleaseMode parking_release_mode = 15;
  if (this->parking_release_mode() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      15, this->parking_release_mode(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
}

::google::protobuf::uint8* ParkingSlotInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // int32 valid = 2;
  if (this->valid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->valid(), target);
  }

  // float conf = 3;
  if (this->conf() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->conf(), target);
  }

  // repeated .autodrive.workflow.proto.parking_slot.CornerInfo polygon_points = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->polygon_points_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->polygon_points(static_cast<int>(i)), deterministic, target);
  }

  // .autodrive.workflow.proto.parking_slot.PoseInfo pose = 5;
  if (this->has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, *this->pose_, deterministic, target);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingRodInfo parking_rod = 6;
  if (this->has_parking_rod()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, *this->parking_rod_, deterministic, target);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingLockInfo parking_lock_info = 7;
  if (this->has_parking_lock_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, *this->parking_lock_info_, deterministic, target);
  }

  // .autodrive.workflow.proto.parking_slot.BoundaryInfo boundary = 8;
  if (this->has_boundary()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, *this->boundary_, deterministic, target);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingType type = 9;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->type(), target);
  }

  // .autodrive.workflow.proto.parking_slot.OccupancyStatus occupancy_status = 10;
  if (this->occupancy_status() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->occupancy_status(), target);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingSource parking_source = 11;
  if (this->parking_source() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      11, this->parking_source(), target);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingStage stage = 12;
  if (this->stage() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      12, this->stage(), target);
  }

  // .autodrive.workflow.proto.parking_slot.OccupyObjType occupancy_obs_type = 13;
  if (this->occupancy_obs_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      13, this->occupancy_obs_type(), target);
  }

  // string str_id = 14;
  if (this->str_id().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->str_id().data(), static_cast<int>(this->str_id().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "autodrive.workflow.proto.parking_slot.ParkingSlotInfo.str_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->str_id(), target);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingReleaseMode parking_release_mode = 15;
  if (this->parking_release_mode() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      15, this->parking_release_mode(), target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  return target;
}

size_t ParkingSlotInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .autodrive.workflow.proto.parking_slot.CornerInfo polygon_points = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->polygon_points_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->polygon_points(static_cast<int>(i)));
    }
  }

  // string str_id = 14;
  if (this->str_id().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->str_id());
  }

  // .autodrive.workflow.proto.parking_slot.PoseInfo pose = 5;
  if (this->has_pose()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->pose_);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingRodInfo parking_rod = 6;
  if (this->has_parking_rod()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->parking_rod_);
  }

  // .autodrive.workflow.proto.parking_slot.ParkingLockInfo parking_lock_info = 7;
  if (this->has_parking_lock_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->parking_lock_info_);
  }

  // .autodrive.workflow.proto.parking_slot.BoundaryInfo boundary = 8;
  if (this->has_boundary()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->boundary_);
  }

  // int32 id = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  // int32 valid = 2;
  if (this->valid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->valid());
  }

  // float conf = 3;
  if (this->conf() != 0) {
    total_size += 1 + 4;
  }

  // .autodrive.workflow.proto.parking_slot.ParkingType type = 9;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // .autodrive.workflow.proto.parking_slot.OccupancyStatus occupancy_status = 10;
  if (this->occupancy_status() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->occupancy_status());
  }

  // .autodrive.workflow.proto.parking_slot.ParkingSource parking_source = 11;
  if (this->parking_source() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->parking_source());
  }

  // .autodrive.workflow.proto.parking_slot.ParkingStage stage = 12;
  if (this->stage() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->stage());
  }

  // .autodrive.workflow.proto.parking_slot.OccupyObjType occupancy_obs_type = 13;
  if (this->occupancy_obs_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->occupancy_obs_type());
  }

  // .autodrive.workflow.proto.parking_slot.ParkingReleaseMode parking_release_mode = 15;
  if (this->parking_release_mode() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->parking_release_mode());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParkingSlotInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const ParkingSlotInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ParkingSlotInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
    MergeFrom(*source);
  }
}

void ParkingSlotInfo::MergeFrom(const ParkingSlotInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  polygon_points_.MergeFrom(from.polygon_points_);
  if (from.str_id().size() > 0) {

    str_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.str_id_);
  }
  if (from.has_pose()) {
    mutable_pose()->::autodrive::workflow::proto::parking_slot::PoseInfo::MergeFrom(from.pose());
  }
  if (from.has_parking_rod()) {
    mutable_parking_rod()->::autodrive::workflow::proto::parking_slot::ParkingRodInfo::MergeFrom(from.parking_rod());
  }
  if (from.has_parking_lock_info()) {
    mutable_parking_lock_info()->::autodrive::workflow::proto::parking_slot::ParkingLockInfo::MergeFrom(from.parking_lock_info());
  }
  if (from.has_boundary()) {
    mutable_boundary()->::autodrive::workflow::proto::parking_slot::BoundaryInfo::MergeFrom(from.boundary());
  }
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.valid() != 0) {
    set_valid(from.valid());
  }
  if (from.conf() != 0) {
    set_conf(from.conf());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.occupancy_status() != 0) {
    set_occupancy_status(from.occupancy_status());
  }
  if (from.parking_source() != 0) {
    set_parking_source(from.parking_source());
  }
  if (from.stage() != 0) {
    set_stage(from.stage());
  }
  if (from.occupancy_obs_type() != 0) {
    set_occupancy_obs_type(from.occupancy_obs_type());
  }
  if (from.parking_release_mode() != 0) {
    set_parking_release_mode(from.parking_release_mode());
  }
}

void ParkingSlotInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParkingSlotInfo::CopyFrom(const ParkingSlotInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:autodrive.workflow.proto.parking_slot.ParkingSlotInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParkingSlotInfo::IsInitialized() const {
  return true;
}

void ParkingSlotInfo::Swap(ParkingSlotInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ParkingSlotInfo::InternalSwap(ParkingSlotInfo* other) {
  using std::swap;
  polygon_points_.InternalSwap(&other->polygon_points_);
  str_id_.Swap(&other->str_id_);
  swap(pose_, other->pose_);
  swap(parking_rod_, other->parking_rod_);
  swap(parking_lock_info_, other->parking_lock_info_);
  swap(boundary_, other->boundary_);
  swap(id_, other->id_);
  swap(valid_, other->valid_);
  swap(conf_, other->conf_);
  swap(type_, other->type_);
  swap(occupancy_status_, other->occupancy_status_);
  swap(parking_source_, other->parking_source_);
  swap(stage_, other->stage_);
  swap(occupancy_obs_type_, other->occupancy_obs_type_);
  swap(parking_release_mode_, other->parking_release_mode_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ParkingSlotInfo::GetMetadata() const {
  protobuf_parking_5fslot_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_parking_5fslot_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace parking_slot
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

// @@protoc_insertion_point(global_scope)
