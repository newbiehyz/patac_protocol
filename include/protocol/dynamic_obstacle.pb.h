// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dynamic_obstacle.proto

#ifndef PROTOBUF_dynamic_5fobstacle_2eproto__INCLUDED
#define PROTOBUF_dynamic_5fobstacle_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
#include "perception_base.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_dynamic_5fobstacle_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsDynamicObstVelocityImpl();
void InitDefaultsDynamicObstVelocity();
void InitDefaultsDynamicObstAccelerateImpl();
void InitDefaultsDynamicObstAccelerate();
void InitDefaultsObstacleAngleImpl();
void InitDefaultsObstacleAngle();
void InitDefaultsDynamicObstWorldSpaceInfoImpl();
void InitDefaultsDynamicObstWorldSpaceInfo();
void InitDefaultsDynamicObstacleImpl();
void InitDefaultsDynamicObstacle();
inline void InitDefaults() {
  InitDefaultsDynamicObstVelocity();
  InitDefaultsDynamicObstAccelerate();
  InitDefaultsObstacleAngle();
  InitDefaultsDynamicObstWorldSpaceInfo();
  InitDefaultsDynamicObstacle();
}
}  // namespace protobuf_dynamic_5fobstacle_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
class DynamicObstAccelerate;
class DynamicObstAccelerateDefaultTypeInternal;
extern DynamicObstAccelerateDefaultTypeInternal _DynamicObstAccelerate_default_instance_;
class DynamicObstVelocity;
class DynamicObstVelocityDefaultTypeInternal;
extern DynamicObstVelocityDefaultTypeInternal _DynamicObstVelocity_default_instance_;
class DynamicObstWorldSpaceInfo;
class DynamicObstWorldSpaceInfoDefaultTypeInternal;
extern DynamicObstWorldSpaceInfoDefaultTypeInternal _DynamicObstWorldSpaceInfo_default_instance_;
class DynamicObstacle;
class DynamicObstacleDefaultTypeInternal;
extern DynamicObstacleDefaultTypeInternal _DynamicObstacle_default_instance_;
class ObstacleAngle;
class ObstacleAngleDefaultTypeInternal;
extern ObstacleAngleDefaultTypeInternal _ObstacleAngle_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {

enum DynamicObstacleType {
  kObstacleTypeVehicleRear = 0,
  kObstacleTypeVehicleFull = 1,
  kObstacleTypePedestrian = 2,
  kObstacleTypeCyclist = 18,
  kObstacleTypeAnimal = 28,
  kObstacleTypeUnknown = 50,
  DynamicObstacleType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DynamicObstacleType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DynamicObstacleType_IsValid(int value);
const DynamicObstacleType DynamicObstacleType_MIN = kObstacleTypeVehicleRear;
const DynamicObstacleType DynamicObstacleType_MAX = kObstacleTypeUnknown;
const int DynamicObstacleType_ARRAYSIZE = DynamicObstacleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DynamicObstacleType_descriptor();
inline const ::std::string& DynamicObstacleType_Name(DynamicObstacleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DynamicObstacleType_descriptor(), value);
}
inline bool DynamicObstacleType_Parse(
    const ::std::string& name, DynamicObstacleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DynamicObstacleType>(
    DynamicObstacleType_descriptor(), name, value);
}
enum VehicleType {
  kVehicleTypeUnknown = 0,
  kVehicleTypeCar = 1,
  kVehicleTypeSUV = 2,
  kVehicleTypeVan = 3,
  kVehicleTypeBus = 4,
  kVehicleTypeTruck = 5,
  kVehicleTypeAmbulance = 6,
  kVehicleTypePoliceCar = 7,
  kVehicleTypeFireTruck = 8,
  kVehicleTypeTricycle = 9,
  kVehicleTypeSpecialCar = 10,
  kVehicleTypeTinyCar = 11,
  kVehicleTypeMotor = 12,
  VehicleType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VehicleType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VehicleType_IsValid(int value);
const VehicleType VehicleType_MIN = kVehicleTypeUnknown;
const VehicleType VehicleType_MAX = kVehicleTypeMotor;
const int VehicleType_ARRAYSIZE = VehicleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehicleType_descriptor();
inline const ::std::string& VehicleType_Name(VehicleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehicleType_descriptor(), value);
}
inline bool VehicleType_Parse(
    const ::std::string& name, VehicleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleType>(
    VehicleType_descriptor(), name, value);
}
enum DynamicObstacleMotionStatus {
  kMotionStatusInvalid = 0,
  kMotionStatusUnknown = 1,
  kMotionStatusMoving = 2,
  kMotionStatusStationary = 3,
  kMotionStatusStopped = 4,
  kMotionStatusMovingSlowly = 5,
  kMotionStatusEnumSize = 6,
  DynamicObstacleMotionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DynamicObstacleMotionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DynamicObstacleMotionStatus_IsValid(int value);
const DynamicObstacleMotionStatus DynamicObstacleMotionStatus_MIN = kMotionStatusInvalid;
const DynamicObstacleMotionStatus DynamicObstacleMotionStatus_MAX = kMotionStatusEnumSize;
const int DynamicObstacleMotionStatus_ARRAYSIZE = DynamicObstacleMotionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* DynamicObstacleMotionStatus_descriptor();
inline const ::std::string& DynamicObstacleMotionStatus_Name(DynamicObstacleMotionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    DynamicObstacleMotionStatus_descriptor(), value);
}
inline bool DynamicObstacleMotionStatus_Parse(
    const ::std::string& name, DynamicObstacleMotionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DynamicObstacleMotionStatus>(
    DynamicObstacleMotionStatus_descriptor(), name, value);
}
enum MotionCategory {
  kMotionCategoryInvalid = 0,
  kMotionCategoryUndefined = 1,
  kMotionCategoryPassing = 2,
  kMotionCategoryPassingIn = 3,
  kMotionCategoryPassingOut = 4,
  kMotionCategoryCloseCutIn = 5,
  kMotionCategoryMovingIn = 6,
  kMotionCategoryMovingOut = 7,
  kMotionCategoryCrossing = 8,
  kMotionCategoryLeftTurnAP = 9,
  kMotionCategoryRightTurnAP = 10,
  kMotionCategoryMoving = 11,
  kMotionCategoryPreceding = 12,
  kMotionCategoryOncoming = 13,
  kMotionCategoryEnumSize = 14,
  MotionCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MotionCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MotionCategory_IsValid(int value);
const MotionCategory MotionCategory_MIN = kMotionCategoryInvalid;
const MotionCategory MotionCategory_MAX = kMotionCategoryEnumSize;
const int MotionCategory_ARRAYSIZE = MotionCategory_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionCategory_descriptor();
inline const ::std::string& MotionCategory_Name(MotionCategory value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionCategory_descriptor(), value);
}
inline bool MotionCategory_Parse(
    const ::std::string& name, MotionCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionCategory>(
    MotionCategory_descriptor(), name, value);
}
enum MotionOrientation {
  kMotionOrientationUndefined = 0,
  kMotionOrientationDriftingRight = 1,
  kMotionOrientationCrossingRight = 2,
  kMotionOrientationOncomingDriftRight = 3,
  kMotionOrientationOncoming = 4,
  kMotionOrientationOncomingDriftLeft = 5,
  kMotionOrientationCrossingLeft = 6,
  kMotionOrientationDriftingLeft = 7,
  kMotionOrientationPreceding = 8,
  MotionOrientation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MotionOrientation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MotionOrientation_IsValid(int value);
const MotionOrientation MotionOrientation_MIN = kMotionOrientationUndefined;
const MotionOrientation MotionOrientation_MAX = kMotionOrientationPreceding;
const int MotionOrientation_ARRAYSIZE = MotionOrientation_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionOrientation_descriptor();
inline const ::std::string& MotionOrientation_Name(MotionOrientation value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionOrientation_descriptor(), value);
}
inline bool MotionOrientation_Parse(
    const ::std::string& name, MotionOrientation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionOrientation>(
    MotionOrientation_descriptor(), name, value);
}
enum VisibleSide {
  kVisibleSideUnknown = 0,
  kVisibleSideRight = 1,
  kVisibleSideLeft = 2,
  VisibleSide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VisibleSide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VisibleSide_IsValid(int value);
const VisibleSide VisibleSide_MIN = kVisibleSideUnknown;
const VisibleSide VisibleSide_MAX = kVisibleSideLeft;
const int VisibleSide_ARRAYSIZE = VisibleSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* VisibleSide_descriptor();
inline const ::std::string& VisibleSide_Name(VisibleSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    VisibleSide_descriptor(), value);
}
inline bool VisibleSide_Parse(
    const ::std::string& name, VisibleSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VisibleSide>(
    VisibleSide_descriptor(), name, value);
}
enum VisibleRect {
  kVisibleRectUnknown = 0,
  kVisibleRectFront = 1,
  kVisibleRectBack = 2,
  VisibleRect_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VisibleRect_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VisibleRect_IsValid(int value);
const VisibleRect VisibleRect_MIN = kVisibleRectUnknown;
const VisibleRect VisibleRect_MAX = kVisibleRectBack;
const int VisibleRect_ARRAYSIZE = VisibleRect_MAX + 1;

const ::google::protobuf::EnumDescriptor* VisibleRect_descriptor();
inline const ::std::string& VisibleRect_Name(VisibleRect value) {
  return ::google::protobuf::internal::NameOfEnum(
    VisibleRect_descriptor(), value);
}
inline bool VisibleRect_Parse(
    const ::std::string& name, VisibleRect* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VisibleRect>(
    VisibleRect_descriptor(), name, value);
}
enum OutputObsPositionType {
  kOutputObsPositionTypeUnknownPoint = 0,
  kOutputObsPositionTypeRearLeftPoint = 1,
  kOutputObsPositionTypeRearCenterPoint = 2,
  kOutputObsPositionTypeRearRightPoint = 3,
  kOutputObsPositionTypeFrontLeftPoint = 4,
  kOutputObsPositionTypeFrontCenterPoint = 5,
  kOutputObsPositionTypeFrontRightPoint = 6,
  kOutputObsPositionTypeLeftCenterPoint = 7,
  kOutputObsPositionTypeRightCenterPoint = 8,
  kOutputObsPositionTypeCenterPoint = 9,
  OutputObsPositionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OutputObsPositionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OutputObsPositionType_IsValid(int value);
const OutputObsPositionType OutputObsPositionType_MIN = kOutputObsPositionTypeUnknownPoint;
const OutputObsPositionType OutputObsPositionType_MAX = kOutputObsPositionTypeCenterPoint;
const int OutputObsPositionType_ARRAYSIZE = OutputObsPositionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OutputObsPositionType_descriptor();
inline const ::std::string& OutputObsPositionType_Name(OutputObsPositionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OutputObsPositionType_descriptor(), value);
}
inline bool OutputObsPositionType_Parse(
    const ::std::string& name, OutputObsPositionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OutputObsPositionType>(
    OutputObsPositionType_descriptor(), name, value);
}
// ===================================================================

class DynamicObstVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.DynamicObstVelocity) */ {
 public:
  DynamicObstVelocity();
  virtual ~DynamicObstVelocity();

  DynamicObstVelocity(const DynamicObstVelocity& from);

  inline DynamicObstVelocity& operator=(const DynamicObstVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DynamicObstVelocity(DynamicObstVelocity&& from) noexcept
    : DynamicObstVelocity() {
    *this = ::std::move(from);
  }

  inline DynamicObstVelocity& operator=(DynamicObstVelocity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicObstVelocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicObstVelocity* internal_default_instance() {
    return reinterpret_cast<const DynamicObstVelocity*>(
               &_DynamicObstVelocity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DynamicObstVelocity* other);
  friend void swap(DynamicObstVelocity& a, DynamicObstVelocity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DynamicObstVelocity* New() const PROTOBUF_FINAL { return New(NULL); }

  DynamicObstVelocity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DynamicObstVelocity& from);
  void MergeFrom(const DynamicObstVelocity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DynamicObstVelocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float vx = 1;
  void clear_vx();
  static const int kVxFieldNumber = 1;
  float vx() const;
  void set_vx(float value);

  // float vy = 2;
  void clear_vy();
  static const int kVyFieldNumber = 2;
  float vy() const;
  void set_vy(float value);

  // float vz = 3;
  void clear_vz();
  static const int kVzFieldNumber = 3;
  float vz() const;
  void set_vz(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.DynamicObstVelocity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float vx_;
  float vy_;
  float vz_;
  mutable int _cached_size_;
  friend struct ::protobuf_dynamic_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5fobstacle_2eproto::InitDefaultsDynamicObstVelocityImpl();
};
// -------------------------------------------------------------------

class DynamicObstAccelerate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.DynamicObstAccelerate) */ {
 public:
  DynamicObstAccelerate();
  virtual ~DynamicObstAccelerate();

  DynamicObstAccelerate(const DynamicObstAccelerate& from);

  inline DynamicObstAccelerate& operator=(const DynamicObstAccelerate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DynamicObstAccelerate(DynamicObstAccelerate&& from) noexcept
    : DynamicObstAccelerate() {
    *this = ::std::move(from);
  }

  inline DynamicObstAccelerate& operator=(DynamicObstAccelerate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicObstAccelerate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicObstAccelerate* internal_default_instance() {
    return reinterpret_cast<const DynamicObstAccelerate*>(
               &_DynamicObstAccelerate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DynamicObstAccelerate* other);
  friend void swap(DynamicObstAccelerate& a, DynamicObstAccelerate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DynamicObstAccelerate* New() const PROTOBUF_FINAL { return New(NULL); }

  DynamicObstAccelerate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DynamicObstAccelerate& from);
  void MergeFrom(const DynamicObstAccelerate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DynamicObstAccelerate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float ax = 1;
  void clear_ax();
  static const int kAxFieldNumber = 1;
  float ax() const;
  void set_ax(float value);

  // float ay = 2;
  void clear_ay();
  static const int kAyFieldNumber = 2;
  float ay() const;
  void set_ay(float value);

  // float az = 3;
  void clear_az();
  static const int kAzFieldNumber = 3;
  float az() const;
  void set_az(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.DynamicObstAccelerate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float ax_;
  float ay_;
  float az_;
  mutable int _cached_size_;
  friend struct ::protobuf_dynamic_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5fobstacle_2eproto::InitDefaultsDynamicObstAccelerateImpl();
};
// -------------------------------------------------------------------

class ObstacleAngle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ObstacleAngle) */ {
 public:
  ObstacleAngle();
  virtual ~ObstacleAngle();

  ObstacleAngle(const ObstacleAngle& from);

  inline ObstacleAngle& operator=(const ObstacleAngle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleAngle(ObstacleAngle&& from) noexcept
    : ObstacleAngle() {
    *this = ::std::move(from);
  }

  inline ObstacleAngle& operator=(ObstacleAngle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleAngle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleAngle* internal_default_instance() {
    return reinterpret_cast<const ObstacleAngle*>(
               &_ObstacleAngle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ObstacleAngle* other);
  friend void swap(ObstacleAngle& a, ObstacleAngle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleAngle* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstacleAngle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstacleAngle& from);
  void MergeFrom(const ObstacleAngle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstacleAngle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float angle_left_v = 1;
  void clear_angle_left_v();
  static const int kAngleLeftVFieldNumber = 1;
  float angle_left_v() const;
  void set_angle_left_v(float value);

  // float angle_left = 2;
  void clear_angle_left();
  static const int kAngleLeftFieldNumber = 2;
  float angle_left() const;
  void set_angle_left(float value);

  // float angle_middle_v = 3;
  void clear_angle_middle_v();
  static const int kAngleMiddleVFieldNumber = 3;
  float angle_middle_v() const;
  void set_angle_middle_v(float value);

  // float angle_middle = 4;
  void clear_angle_middle();
  static const int kAngleMiddleFieldNumber = 4;
  float angle_middle() const;
  void set_angle_middle(float value);

  // float angle_right_v = 5;
  void clear_angle_right_v();
  static const int kAngleRightVFieldNumber = 5;
  float angle_right_v() const;
  void set_angle_right_v(float value);

  // float angle_right = 6;
  void clear_angle_right();
  static const int kAngleRightFieldNumber = 6;
  float angle_right() const;
  void set_angle_right(float value);

  // float angle_side_v = 7;
  void clear_angle_side_v();
  static const int kAngleSideVFieldNumber = 7;
  float angle_side_v() const;
  void set_angle_side_v(float value);

  // float angle_side = 8;
  void clear_angle_side();
  static const int kAngleSideFieldNumber = 8;
  float angle_side() const;
  void set_angle_side(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ObstacleAngle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float angle_left_v_;
  float angle_left_;
  float angle_middle_v_;
  float angle_middle_;
  float angle_right_v_;
  float angle_right_;
  float angle_side_v_;
  float angle_side_;
  mutable int _cached_size_;
  friend struct ::protobuf_dynamic_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5fobstacle_2eproto::InitDefaultsObstacleAngleImpl();
};
// -------------------------------------------------------------------

class DynamicObstWorldSpaceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.DynamicObstWorldSpaceInfo) */ {
 public:
  DynamicObstWorldSpaceInfo();
  virtual ~DynamicObstWorldSpaceInfo();

  DynamicObstWorldSpaceInfo(const DynamicObstWorldSpaceInfo& from);

  inline DynamicObstWorldSpaceInfo& operator=(const DynamicObstWorldSpaceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DynamicObstWorldSpaceInfo(DynamicObstWorldSpaceInfo&& from) noexcept
    : DynamicObstWorldSpaceInfo() {
    *this = ::std::move(from);
  }

  inline DynamicObstWorldSpaceInfo& operator=(DynamicObstWorldSpaceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicObstWorldSpaceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicObstWorldSpaceInfo* internal_default_instance() {
    return reinterpret_cast<const DynamicObstWorldSpaceInfo*>(
               &_DynamicObstWorldSpaceInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DynamicObstWorldSpaceInfo* other);
  friend void swap(DynamicObstWorldSpaceInfo& a, DynamicObstWorldSpaceInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DynamicObstWorldSpaceInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DynamicObstWorldSpaceInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DynamicObstWorldSpaceInfo& from);
  void MergeFrom(const DynamicObstWorldSpaceInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DynamicObstWorldSpaceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float sigma_vel = 15;
  int sigma_vel_size() const;
  void clear_sigma_vel();
  static const int kSigmaVelFieldNumber = 15;
  float sigma_vel(int index) const;
  void set_sigma_vel(int index, float value);
  void add_sigma_vel(float value);
  const ::google::protobuf::RepeatedField< float >&
      sigma_vel() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_sigma_vel();

  // repeated float sigma_position = 20;
  int sigma_position_size() const;
  void clear_sigma_position();
  static const int kSigmaPositionFieldNumber = 20;
  float sigma_position(int index) const;
  void set_sigma_position(int index, float value);
  void add_sigma_position(float value);
  const ::google::protobuf::RepeatedField< float >&
      sigma_position() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_sigma_position();

  // repeated float sigma_acc_ref = 23;
  int sigma_acc_ref_size() const;
  void clear_sigma_acc_ref();
  static const int kSigmaAccRefFieldNumber = 23;
  float sigma_acc_ref(int index) const;
  void set_sigma_acc_ref(int index, float value);
  void add_sigma_acc_ref(float value);
  const ::google::protobuf::RepeatedField< float >&
      sigma_acc_ref() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_sigma_acc_ref();

  // repeated float sigma_rbc_position = 32;
  int sigma_rbc_position_size() const;
  void clear_sigma_rbc_position();
  static const int kSigmaRbcPositionFieldNumber = 32;
  float sigma_rbc_position(int index) const;
  void set_sigma_rbc_position(int index, float value);
  void add_sigma_rbc_position(float value);
  const ::google::protobuf::RepeatedField< float >&
      sigma_rbc_position() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_sigma_rbc_position();

  // .autodrive.workflow.proto.Vector3f position = 5;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 5;
  const ::autodrive::workflow::proto::Vector3f& position() const;
  ::autodrive::workflow::proto::Vector3f* release_position();
  ::autodrive::workflow::proto::Vector3f* mutable_position();
  void set_allocated_position(::autodrive::workflow::proto::Vector3f* position);

  // .autodrive.workflow.proto.DynamicObstVelocity vel_abs_world = 7;
  bool has_vel_abs_world() const;
  void clear_vel_abs_world();
  static const int kVelAbsWorldFieldNumber = 7;
  const ::autodrive::workflow::proto::DynamicObstVelocity& vel_abs_world() const;
  ::autodrive::workflow::proto::DynamicObstVelocity* release_vel_abs_world();
  ::autodrive::workflow::proto::DynamicObstVelocity* mutable_vel_abs_world();
  void set_allocated_vel_abs_world(::autodrive::workflow::proto::DynamicObstVelocity* vel_abs_world);

  // .autodrive.workflow.proto.DynamicObstAccelerate acc_abs_world = 8;
  bool has_acc_abs_world() const;
  void clear_acc_abs_world();
  static const int kAccAbsWorldFieldNumber = 8;
  const ::autodrive::workflow::proto::DynamicObstAccelerate& acc_abs_world() const;
  ::autodrive::workflow::proto::DynamicObstAccelerate* release_acc_abs_world();
  ::autodrive::workflow::proto::DynamicObstAccelerate* mutable_acc_abs_world();
  void set_allocated_acc_abs_world(::autodrive::workflow::proto::DynamicObstAccelerate* acc_abs_world);

  // .autodrive.workflow.proto.ObstacleAngle obj_angle = 24;
  bool has_obj_angle() const;
  void clear_obj_angle();
  static const int kObjAngleFieldNumber = 24;
  const ::autodrive::workflow::proto::ObstacleAngle& obj_angle() const;
  ::autodrive::workflow::proto::ObstacleAngle* release_obj_angle();
  ::autodrive::workflow::proto::ObstacleAngle* mutable_obj_angle();
  void set_allocated_obj_angle(::autodrive::workflow::proto::ObstacleAngle* obj_angle);

  // .autodrive.workflow.proto.DynamicObstVelocity vel = 27;
  bool has_vel() const;
  void clear_vel();
  static const int kVelFieldNumber = 27;
  const ::autodrive::workflow::proto::DynamicObstVelocity& vel() const;
  ::autodrive::workflow::proto::DynamicObstVelocity* release_vel();
  ::autodrive::workflow::proto::DynamicObstVelocity* mutable_vel();
  void set_allocated_vel(::autodrive::workflow::proto::DynamicObstVelocity* vel);

  // .autodrive.workflow.proto.perception_base.Polygon poly = 28;
  bool has_poly() const;
  void clear_poly();
  static const int kPolyFieldNumber = 28;
  const ::autodrive::workflow::proto::perception_base::Polygon& poly() const;
  ::autodrive::workflow::proto::perception_base::Polygon* release_poly();
  ::autodrive::workflow::proto::perception_base::Polygon* mutable_poly();
  void set_allocated_poly(::autodrive::workflow::proto::perception_base::Polygon* poly);

  // .autodrive.workflow.proto.perception_base.Polygon poly_vcs = 29;
  bool has_poly_vcs() const;
  void clear_poly_vcs();
  static const int kPolyVcsFieldNumber = 29;
  const ::autodrive::workflow::proto::perception_base::Polygon& poly_vcs() const;
  ::autodrive::workflow::proto::perception_base::Polygon* release_poly_vcs();
  ::autodrive::workflow::proto::perception_base::Polygon* mutable_poly_vcs();
  void set_allocated_poly_vcs(::autodrive::workflow::proto::perception_base::Polygon* poly_vcs);

  // .autodrive.workflow.proto.Vector3f rbc_position = 31;
  bool has_rbc_position() const;
  void clear_rbc_position();
  static const int kRbcPositionFieldNumber = 31;
  const ::autodrive::workflow::proto::Vector3f& rbc_position() const;
  ::autodrive::workflow::proto::Vector3f* release_rbc_position();
  ::autodrive::workflow::proto::Vector3f* mutable_rbc_position();
  void set_allocated_rbc_position(::autodrive::workflow::proto::Vector3f* rbc_position);

  // .autodrive.workflow.proto.DynamicObstAccelerate acc = 34;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 34;
  const ::autodrive::workflow::proto::DynamicObstAccelerate& acc() const;
  ::autodrive::workflow::proto::DynamicObstAccelerate* release_acc();
  ::autodrive::workflow::proto::DynamicObstAccelerate* mutable_acc();
  void set_allocated_acc(::autodrive::workflow::proto::DynamicObstAccelerate* acc);

  // float yaw = 1;
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  float yaw() const;
  void set_yaw(float value);

  // float length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  float length() const;
  void set_length(float value);

  // float width = 3;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  float width() const;
  void set_width(float value);

  // float height = 4;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  float height() const;
  void set_height(float value);

  // float ttc = 6;
  void clear_ttc();
  static const int kTtcFieldNumber = 6;
  float ttc() const;
  void set_ttc(float value);

  // .autodrive.workflow.proto.DynamicObstacleMotionStatus motion_status = 9;
  void clear_motion_status();
  static const int kMotionStatusFieldNumber = 9;
  ::autodrive::workflow::proto::DynamicObstacleMotionStatus motion_status() const;
  void set_motion_status(::autodrive::workflow::proto::DynamicObstacleMotionStatus value);

  // .autodrive.workflow.proto.MotionCategory motion_category = 10;
  void clear_motion_category();
  static const int kMotionCategoryFieldNumber = 10;
  ::autodrive::workflow::proto::MotionCategory motion_category() const;
  void set_motion_category(::autodrive::workflow::proto::MotionCategory value);

  // .autodrive.workflow.proto.OutputObsPositionType position_type = 11;
  void clear_position_type();
  static const int kPositionTypeFieldNumber = 11;
  ::autodrive::workflow::proto::OutputObsPositionType position_type() const;
  void set_position_type(::autodrive::workflow::proto::OutputObsPositionType value);

  // float yaw_rate = 12;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 12;
  float yaw_rate() const;
  void set_yaw_rate(float value);

  // .autodrive.workflow.proto.VisibleSide visible_side = 13;
  void clear_visible_side();
  static const int kVisibleSideFieldNumber = 13;
  ::autodrive::workflow::proto::VisibleSide visible_side() const;
  void set_visible_side(::autodrive::workflow::proto::VisibleSide value);

  // .autodrive.workflow.proto.MotionOrientation motion_orientation = 14;
  void clear_motion_orientation();
  static const int kMotionOrientationFieldNumber = 14;
  ::autodrive::workflow::proto::MotionOrientation motion_orientation() const;
  void set_motion_orientation(::autodrive::workflow::proto::MotionOrientation value);

  // float sigma_yaw = 16;
  void clear_sigma_yaw();
  static const int kSigmaYawFieldNumber = 16;
  float sigma_yaw() const;
  void set_sigma_yaw(float value);

  // float sigma_width = 17;
  void clear_sigma_width();
  static const int kSigmaWidthFieldNumber = 17;
  float sigma_width() const;
  void set_sigma_width(float value);

  // float sigma_height = 18;
  void clear_sigma_height();
  static const int kSigmaHeightFieldNumber = 18;
  float sigma_height() const;
  void set_sigma_height(float value);

  // float sigma_length = 19;
  void clear_sigma_length();
  static const int kSigmaLengthFieldNumber = 19;
  float sigma_length() const;
  void set_sigma_length(float value);

  // float sigma_yaw_rate = 21;
  void clear_sigma_yaw_rate();
  static const int kSigmaYawRateFieldNumber = 21;
  float sigma_yaw_rate() const;
  void set_sigma_yaw_rate(float value);

  // int32 head_rear_type = 22;
  void clear_head_rear_type();
  static const int kHeadRearTypeFieldNumber = 22;
  ::google::protobuf::int32 head_rear_type() const;
  void set_head_rear_type(::google::protobuf::int32 value);

  // int32 lane_assignment = 25;
  void clear_lane_assignment();
  static const int kLaneAssignmentFieldNumber = 25;
  ::google::protobuf::int32 lane_assignment() const;
  void set_lane_assignment(::google::protobuf::int32 value);

  // int32 traversable = 26;
  void clear_traversable();
  static const int kTraversableFieldNumber = 26;
  ::google::protobuf::int32 traversable() const;
  void set_traversable(::google::protobuf::int32 value);

  // .autodrive.workflow.proto.VisibleRect visible_rect = 30;
  void clear_visible_rect();
  static const int kVisibleRectFieldNumber = 30;
  ::autodrive::workflow::proto::VisibleRect visible_rect() const;
  void set_visible_rect(::autodrive::workflow::proto::VisibleRect value);

  // int32 cipv = 33;
  void clear_cipv();
  static const int kCipvFieldNumber = 33;
  ::google::protobuf::int32 cipv() const;
  void set_cipv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.DynamicObstWorldSpaceInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > sigma_vel_;
  mutable int _sigma_vel_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > sigma_position_;
  mutable int _sigma_position_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > sigma_acc_ref_;
  mutable int _sigma_acc_ref_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > sigma_rbc_position_;
  mutable int _sigma_rbc_position_cached_byte_size_;
  ::autodrive::workflow::proto::Vector3f* position_;
  ::autodrive::workflow::proto::DynamicObstVelocity* vel_abs_world_;
  ::autodrive::workflow::proto::DynamicObstAccelerate* acc_abs_world_;
  ::autodrive::workflow::proto::ObstacleAngle* obj_angle_;
  ::autodrive::workflow::proto::DynamicObstVelocity* vel_;
  ::autodrive::workflow::proto::perception_base::Polygon* poly_;
  ::autodrive::workflow::proto::perception_base::Polygon* poly_vcs_;
  ::autodrive::workflow::proto::Vector3f* rbc_position_;
  ::autodrive::workflow::proto::DynamicObstAccelerate* acc_;
  float yaw_;
  float length_;
  float width_;
  float height_;
  float ttc_;
  int motion_status_;
  int motion_category_;
  int position_type_;
  float yaw_rate_;
  int visible_side_;
  int motion_orientation_;
  float sigma_yaw_;
  float sigma_width_;
  float sigma_height_;
  float sigma_length_;
  float sigma_yaw_rate_;
  ::google::protobuf::int32 head_rear_type_;
  ::google::protobuf::int32 lane_assignment_;
  ::google::protobuf::int32 traversable_;
  int visible_rect_;
  ::google::protobuf::int32 cipv_;
  mutable int _cached_size_;
  friend struct ::protobuf_dynamic_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5fobstacle_2eproto::InitDefaultsDynamicObstWorldSpaceInfoImpl();
};
// -------------------------------------------------------------------

class DynamicObstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.DynamicObstacle) */ {
 public:
  DynamicObstacle();
  virtual ~DynamicObstacle();

  DynamicObstacle(const DynamicObstacle& from);

  inline DynamicObstacle& operator=(const DynamicObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DynamicObstacle(DynamicObstacle&& from) noexcept
    : DynamicObstacle() {
    *this = ::std::move(from);
  }

  inline DynamicObstacle& operator=(DynamicObstacle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicObstacle* internal_default_instance() {
    return reinterpret_cast<const DynamicObstacle*>(
               &_DynamicObstacle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DynamicObstacle* other);
  friend void swap(DynamicObstacle& a, DynamicObstacle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DynamicObstacle* New() const PROTOBUF_FINAL { return New(NULL); }

  DynamicObstacle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DynamicObstacle& from);
  void MergeFrom(const DynamicObstacle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DynamicObstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.perception_base.Category category = 13;
  int category_size() const;
  void clear_category();
  static const int kCategoryFieldNumber = 13;
  const ::autodrive::workflow::proto::perception_base::Category& category(int index) const;
  ::autodrive::workflow::proto::perception_base::Category* mutable_category(int index);
  ::autodrive::workflow::proto::perception_base::Category* add_category();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >*
      mutable_category();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >&
      category() const;

  // .autodrive.workflow.proto.perception_base.ImageSpace img_info = 9;
  bool has_img_info() const;
  void clear_img_info();
  static const int kImgInfoFieldNumber = 9;
  const ::autodrive::workflow::proto::perception_base::ImageSpace& img_info() const;
  ::autodrive::workflow::proto::perception_base::ImageSpace* release_img_info();
  ::autodrive::workflow::proto::perception_base::ImageSpace* mutable_img_info();
  void set_allocated_img_info(::autodrive::workflow::proto::perception_base::ImageSpace* img_info);

  // .autodrive.workflow.proto.DynamicObstWorldSpaceInfo world_info = 10;
  bool has_world_info() const;
  void clear_world_info();
  static const int kWorldInfoFieldNumber = 10;
  const ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo& world_info() const;
  ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo* release_world_info();
  ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo* mutable_world_info();
  void set_allocated_world_info(::autodrive::workflow::proto::DynamicObstWorldSpaceInfo* world_info);

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // int32 life_time = 2;
  void clear_life_time();
  static const int kLifeTimeFieldNumber = 2;
  ::google::protobuf::int32 life_time() const;
  void set_life_time(::google::protobuf::int32 value);

  // int32 cam_id = 3;
  void clear_cam_id();
  static const int kCamIdFieldNumber = 3;
  ::google::protobuf::int32 cam_id() const;
  void set_cam_id(::google::protobuf::int32 value);

  // .autodrive.workflow.proto.DynamicObstacleType type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::autodrive::workflow::proto::DynamicObstacleType type() const;
  void set_type(::autodrive::workflow::proto::DynamicObstacleType value);

  // int64 time_stamp = 6;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 6;
  ::google::protobuf::int64 time_stamp() const;
  void set_time_stamp(::google::protobuf::int64 value);

  // .autodrive.workflow.proto.VehicleType sub_type = 5;
  void clear_sub_type();
  static const int kSubTypeFieldNumber = 5;
  ::autodrive::workflow::proto::VehicleType sub_type() const;
  void set_sub_type(::autodrive::workflow::proto::VehicleType value);

  // float conf = 7;
  void clear_conf();
  static const int kConfFieldNumber = 7;
  float conf() const;
  void set_conf(float value);

  // uint32 age = 8;
  void clear_age();
  static const int kAgeFieldNumber = 8;
  ::google::protobuf::uint32 age() const;
  void set_age(::google::protobuf::uint32 value);

  // int32 valid_info = 11;
  void clear_valid_info();
  static const int kValidInfoFieldNumber = 11;
  ::google::protobuf::int32 valid_info() const;
  void set_valid_info(::google::protobuf::int32 value);

  // int32 select_level = 12;
  void clear_select_level();
  static const int kSelectLevelFieldNumber = 12;
  ::google::protobuf::int32 select_level() const;
  void set_select_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.DynamicObstacle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category > category_;
  ::autodrive::workflow::proto::perception_base::ImageSpace* img_info_;
  ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo* world_info_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::int32 life_time_;
  ::google::protobuf::int32 cam_id_;
  int type_;
  ::google::protobuf::int64 time_stamp_;
  int sub_type_;
  float conf_;
  ::google::protobuf::uint32 age_;
  ::google::protobuf::int32 valid_info_;
  ::google::protobuf::int32 select_level_;
  mutable int _cached_size_;
  friend struct ::protobuf_dynamic_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_dynamic_5fobstacle_2eproto::InitDefaultsDynamicObstacleImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DynamicObstVelocity

// float vx = 1;
inline void DynamicObstVelocity::clear_vx() {
  vx_ = 0;
}
inline float DynamicObstVelocity::vx() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstVelocity.vx)
  return vx_;
}
inline void DynamicObstVelocity::set_vx(float value) {
  
  vx_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstVelocity.vx)
}

// float vy = 2;
inline void DynamicObstVelocity::clear_vy() {
  vy_ = 0;
}
inline float DynamicObstVelocity::vy() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstVelocity.vy)
  return vy_;
}
inline void DynamicObstVelocity::set_vy(float value) {
  
  vy_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstVelocity.vy)
}

// float vz = 3;
inline void DynamicObstVelocity::clear_vz() {
  vz_ = 0;
}
inline float DynamicObstVelocity::vz() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstVelocity.vz)
  return vz_;
}
inline void DynamicObstVelocity::set_vz(float value) {
  
  vz_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstVelocity.vz)
}

// -------------------------------------------------------------------

// DynamicObstAccelerate

// float ax = 1;
inline void DynamicObstAccelerate::clear_ax() {
  ax_ = 0;
}
inline float DynamicObstAccelerate::ax() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstAccelerate.ax)
  return ax_;
}
inline void DynamicObstAccelerate::set_ax(float value) {
  
  ax_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstAccelerate.ax)
}

// float ay = 2;
inline void DynamicObstAccelerate::clear_ay() {
  ay_ = 0;
}
inline float DynamicObstAccelerate::ay() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstAccelerate.ay)
  return ay_;
}
inline void DynamicObstAccelerate::set_ay(float value) {
  
  ay_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstAccelerate.ay)
}

// float az = 3;
inline void DynamicObstAccelerate::clear_az() {
  az_ = 0;
}
inline float DynamicObstAccelerate::az() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstAccelerate.az)
  return az_;
}
inline void DynamicObstAccelerate::set_az(float value) {
  
  az_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstAccelerate.az)
}

// -------------------------------------------------------------------

// ObstacleAngle

// float angle_left_v = 1;
inline void ObstacleAngle::clear_angle_left_v() {
  angle_left_v_ = 0;
}
inline float ObstacleAngle::angle_left_v() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleAngle.angle_left_v)
  return angle_left_v_;
}
inline void ObstacleAngle::set_angle_left_v(float value) {
  
  angle_left_v_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleAngle.angle_left_v)
}

// float angle_left = 2;
inline void ObstacleAngle::clear_angle_left() {
  angle_left_ = 0;
}
inline float ObstacleAngle::angle_left() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleAngle.angle_left)
  return angle_left_;
}
inline void ObstacleAngle::set_angle_left(float value) {
  
  angle_left_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleAngle.angle_left)
}

// float angle_middle_v = 3;
inline void ObstacleAngle::clear_angle_middle_v() {
  angle_middle_v_ = 0;
}
inline float ObstacleAngle::angle_middle_v() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleAngle.angle_middle_v)
  return angle_middle_v_;
}
inline void ObstacleAngle::set_angle_middle_v(float value) {
  
  angle_middle_v_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleAngle.angle_middle_v)
}

// float angle_middle = 4;
inline void ObstacleAngle::clear_angle_middle() {
  angle_middle_ = 0;
}
inline float ObstacleAngle::angle_middle() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleAngle.angle_middle)
  return angle_middle_;
}
inline void ObstacleAngle::set_angle_middle(float value) {
  
  angle_middle_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleAngle.angle_middle)
}

// float angle_right_v = 5;
inline void ObstacleAngle::clear_angle_right_v() {
  angle_right_v_ = 0;
}
inline float ObstacleAngle::angle_right_v() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleAngle.angle_right_v)
  return angle_right_v_;
}
inline void ObstacleAngle::set_angle_right_v(float value) {
  
  angle_right_v_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleAngle.angle_right_v)
}

// float angle_right = 6;
inline void ObstacleAngle::clear_angle_right() {
  angle_right_ = 0;
}
inline float ObstacleAngle::angle_right() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleAngle.angle_right)
  return angle_right_;
}
inline void ObstacleAngle::set_angle_right(float value) {
  
  angle_right_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleAngle.angle_right)
}

// float angle_side_v = 7;
inline void ObstacleAngle::clear_angle_side_v() {
  angle_side_v_ = 0;
}
inline float ObstacleAngle::angle_side_v() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleAngle.angle_side_v)
  return angle_side_v_;
}
inline void ObstacleAngle::set_angle_side_v(float value) {
  
  angle_side_v_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleAngle.angle_side_v)
}

// float angle_side = 8;
inline void ObstacleAngle::clear_angle_side() {
  angle_side_ = 0;
}
inline float ObstacleAngle::angle_side() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleAngle.angle_side)
  return angle_side_;
}
inline void ObstacleAngle::set_angle_side(float value) {
  
  angle_side_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleAngle.angle_side)
}

// -------------------------------------------------------------------

// DynamicObstWorldSpaceInfo

// float yaw = 1;
inline void DynamicObstWorldSpaceInfo::clear_yaw() {
  yaw_ = 0;
}
inline float DynamicObstWorldSpaceInfo::yaw() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.yaw)
  return yaw_;
}
inline void DynamicObstWorldSpaceInfo::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.yaw)
}

// float length = 2;
inline void DynamicObstWorldSpaceInfo::clear_length() {
  length_ = 0;
}
inline float DynamicObstWorldSpaceInfo::length() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.length)
  return length_;
}
inline void DynamicObstWorldSpaceInfo::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.length)
}

// float width = 3;
inline void DynamicObstWorldSpaceInfo::clear_width() {
  width_ = 0;
}
inline float DynamicObstWorldSpaceInfo::width() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.width)
  return width_;
}
inline void DynamicObstWorldSpaceInfo::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.width)
}

// float height = 4;
inline void DynamicObstWorldSpaceInfo::clear_height() {
  height_ = 0;
}
inline float DynamicObstWorldSpaceInfo::height() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.height)
  return height_;
}
inline void DynamicObstWorldSpaceInfo::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.height)
}

// .autodrive.workflow.proto.Vector3f position = 5;
inline bool DynamicObstWorldSpaceInfo::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& DynamicObstWorldSpaceInfo::position() const {
  const ::autodrive::workflow::proto::Vector3f* p = position_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.position)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* DynamicObstWorldSpaceInfo::release_position() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.position)
  
  ::autodrive::workflow::proto::Vector3f* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* DynamicObstWorldSpaceInfo::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.position)
  return position_;
}
inline void DynamicObstWorldSpaceInfo::set_allocated_position(::autodrive::workflow::proto::Vector3f* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.position)
}

// float ttc = 6;
inline void DynamicObstWorldSpaceInfo::clear_ttc() {
  ttc_ = 0;
}
inline float DynamicObstWorldSpaceInfo::ttc() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.ttc)
  return ttc_;
}
inline void DynamicObstWorldSpaceInfo::set_ttc(float value) {
  
  ttc_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.ttc)
}

// .autodrive.workflow.proto.DynamicObstVelocity vel_abs_world = 7;
inline bool DynamicObstWorldSpaceInfo::has_vel_abs_world() const {
  return this != internal_default_instance() && vel_abs_world_ != NULL;
}
inline void DynamicObstWorldSpaceInfo::clear_vel_abs_world() {
  if (GetArenaNoVirtual() == NULL && vel_abs_world_ != NULL) {
    delete vel_abs_world_;
  }
  vel_abs_world_ = NULL;
}
inline const ::autodrive::workflow::proto::DynamicObstVelocity& DynamicObstWorldSpaceInfo::vel_abs_world() const {
  const ::autodrive::workflow::proto::DynamicObstVelocity* p = vel_abs_world_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.vel_abs_world)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::DynamicObstVelocity*>(
      &::autodrive::workflow::proto::_DynamicObstVelocity_default_instance_);
}
inline ::autodrive::workflow::proto::DynamicObstVelocity* DynamicObstWorldSpaceInfo::release_vel_abs_world() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.vel_abs_world)
  
  ::autodrive::workflow::proto::DynamicObstVelocity* temp = vel_abs_world_;
  vel_abs_world_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::DynamicObstVelocity* DynamicObstWorldSpaceInfo::mutable_vel_abs_world() {
  
  if (vel_abs_world_ == NULL) {
    vel_abs_world_ = new ::autodrive::workflow::proto::DynamicObstVelocity;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.vel_abs_world)
  return vel_abs_world_;
}
inline void DynamicObstWorldSpaceInfo::set_allocated_vel_abs_world(::autodrive::workflow::proto::DynamicObstVelocity* vel_abs_world) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vel_abs_world_;
  }
  if (vel_abs_world) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vel_abs_world = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vel_abs_world, submessage_arena);
    }
    
  } else {
    
  }
  vel_abs_world_ = vel_abs_world;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.vel_abs_world)
}

// .autodrive.workflow.proto.DynamicObstAccelerate acc_abs_world = 8;
inline bool DynamicObstWorldSpaceInfo::has_acc_abs_world() const {
  return this != internal_default_instance() && acc_abs_world_ != NULL;
}
inline void DynamicObstWorldSpaceInfo::clear_acc_abs_world() {
  if (GetArenaNoVirtual() == NULL && acc_abs_world_ != NULL) {
    delete acc_abs_world_;
  }
  acc_abs_world_ = NULL;
}
inline const ::autodrive::workflow::proto::DynamicObstAccelerate& DynamicObstWorldSpaceInfo::acc_abs_world() const {
  const ::autodrive::workflow::proto::DynamicObstAccelerate* p = acc_abs_world_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.acc_abs_world)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::DynamicObstAccelerate*>(
      &::autodrive::workflow::proto::_DynamicObstAccelerate_default_instance_);
}
inline ::autodrive::workflow::proto::DynamicObstAccelerate* DynamicObstWorldSpaceInfo::release_acc_abs_world() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.acc_abs_world)
  
  ::autodrive::workflow::proto::DynamicObstAccelerate* temp = acc_abs_world_;
  acc_abs_world_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::DynamicObstAccelerate* DynamicObstWorldSpaceInfo::mutable_acc_abs_world() {
  
  if (acc_abs_world_ == NULL) {
    acc_abs_world_ = new ::autodrive::workflow::proto::DynamicObstAccelerate;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.acc_abs_world)
  return acc_abs_world_;
}
inline void DynamicObstWorldSpaceInfo::set_allocated_acc_abs_world(::autodrive::workflow::proto::DynamicObstAccelerate* acc_abs_world) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acc_abs_world_;
  }
  if (acc_abs_world) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acc_abs_world = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acc_abs_world, submessage_arena);
    }
    
  } else {
    
  }
  acc_abs_world_ = acc_abs_world;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.acc_abs_world)
}

// .autodrive.workflow.proto.DynamicObstacleMotionStatus motion_status = 9;
inline void DynamicObstWorldSpaceInfo::clear_motion_status() {
  motion_status_ = 0;
}
inline ::autodrive::workflow::proto::DynamicObstacleMotionStatus DynamicObstWorldSpaceInfo::motion_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.motion_status)
  return static_cast< ::autodrive::workflow::proto::DynamicObstacleMotionStatus >(motion_status_);
}
inline void DynamicObstWorldSpaceInfo::set_motion_status(::autodrive::workflow::proto::DynamicObstacleMotionStatus value) {
  
  motion_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.motion_status)
}

// .autodrive.workflow.proto.MotionCategory motion_category = 10;
inline void DynamicObstWorldSpaceInfo::clear_motion_category() {
  motion_category_ = 0;
}
inline ::autodrive::workflow::proto::MotionCategory DynamicObstWorldSpaceInfo::motion_category() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.motion_category)
  return static_cast< ::autodrive::workflow::proto::MotionCategory >(motion_category_);
}
inline void DynamicObstWorldSpaceInfo::set_motion_category(::autodrive::workflow::proto::MotionCategory value) {
  
  motion_category_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.motion_category)
}

// .autodrive.workflow.proto.OutputObsPositionType position_type = 11;
inline void DynamicObstWorldSpaceInfo::clear_position_type() {
  position_type_ = 0;
}
inline ::autodrive::workflow::proto::OutputObsPositionType DynamicObstWorldSpaceInfo::position_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.position_type)
  return static_cast< ::autodrive::workflow::proto::OutputObsPositionType >(position_type_);
}
inline void DynamicObstWorldSpaceInfo::set_position_type(::autodrive::workflow::proto::OutputObsPositionType value) {
  
  position_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.position_type)
}

// float yaw_rate = 12;
inline void DynamicObstWorldSpaceInfo::clear_yaw_rate() {
  yaw_rate_ = 0;
}
inline float DynamicObstWorldSpaceInfo::yaw_rate() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.yaw_rate)
  return yaw_rate_;
}
inline void DynamicObstWorldSpaceInfo::set_yaw_rate(float value) {
  
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.yaw_rate)
}

// .autodrive.workflow.proto.VisibleSide visible_side = 13;
inline void DynamicObstWorldSpaceInfo::clear_visible_side() {
  visible_side_ = 0;
}
inline ::autodrive::workflow::proto::VisibleSide DynamicObstWorldSpaceInfo::visible_side() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.visible_side)
  return static_cast< ::autodrive::workflow::proto::VisibleSide >(visible_side_);
}
inline void DynamicObstWorldSpaceInfo::set_visible_side(::autodrive::workflow::proto::VisibleSide value) {
  
  visible_side_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.visible_side)
}

// .autodrive.workflow.proto.MotionOrientation motion_orientation = 14;
inline void DynamicObstWorldSpaceInfo::clear_motion_orientation() {
  motion_orientation_ = 0;
}
inline ::autodrive::workflow::proto::MotionOrientation DynamicObstWorldSpaceInfo::motion_orientation() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.motion_orientation)
  return static_cast< ::autodrive::workflow::proto::MotionOrientation >(motion_orientation_);
}
inline void DynamicObstWorldSpaceInfo::set_motion_orientation(::autodrive::workflow::proto::MotionOrientation value) {
  
  motion_orientation_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.motion_orientation)
}

// repeated float sigma_vel = 15;
inline int DynamicObstWorldSpaceInfo::sigma_vel_size() const {
  return sigma_vel_.size();
}
inline void DynamicObstWorldSpaceInfo::clear_sigma_vel() {
  sigma_vel_.Clear();
}
inline float DynamicObstWorldSpaceInfo::sigma_vel(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_vel)
  return sigma_vel_.Get(index);
}
inline void DynamicObstWorldSpaceInfo::set_sigma_vel(int index, float value) {
  sigma_vel_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_vel)
}
inline void DynamicObstWorldSpaceInfo::add_sigma_vel(float value) {
  sigma_vel_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_vel)
}
inline const ::google::protobuf::RepeatedField< float >&
DynamicObstWorldSpaceInfo::sigma_vel() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_vel)
  return sigma_vel_;
}
inline ::google::protobuf::RepeatedField< float >*
DynamicObstWorldSpaceInfo::mutable_sigma_vel() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_vel)
  return &sigma_vel_;
}

// float sigma_yaw = 16;
inline void DynamicObstWorldSpaceInfo::clear_sigma_yaw() {
  sigma_yaw_ = 0;
}
inline float DynamicObstWorldSpaceInfo::sigma_yaw() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_yaw)
  return sigma_yaw_;
}
inline void DynamicObstWorldSpaceInfo::set_sigma_yaw(float value) {
  
  sigma_yaw_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_yaw)
}

// float sigma_width = 17;
inline void DynamicObstWorldSpaceInfo::clear_sigma_width() {
  sigma_width_ = 0;
}
inline float DynamicObstWorldSpaceInfo::sigma_width() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_width)
  return sigma_width_;
}
inline void DynamicObstWorldSpaceInfo::set_sigma_width(float value) {
  
  sigma_width_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_width)
}

// float sigma_height = 18;
inline void DynamicObstWorldSpaceInfo::clear_sigma_height() {
  sigma_height_ = 0;
}
inline float DynamicObstWorldSpaceInfo::sigma_height() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_height)
  return sigma_height_;
}
inline void DynamicObstWorldSpaceInfo::set_sigma_height(float value) {
  
  sigma_height_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_height)
}

// float sigma_length = 19;
inline void DynamicObstWorldSpaceInfo::clear_sigma_length() {
  sigma_length_ = 0;
}
inline float DynamicObstWorldSpaceInfo::sigma_length() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_length)
  return sigma_length_;
}
inline void DynamicObstWorldSpaceInfo::set_sigma_length(float value) {
  
  sigma_length_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_length)
}

// repeated float sigma_position = 20;
inline int DynamicObstWorldSpaceInfo::sigma_position_size() const {
  return sigma_position_.size();
}
inline void DynamicObstWorldSpaceInfo::clear_sigma_position() {
  sigma_position_.Clear();
}
inline float DynamicObstWorldSpaceInfo::sigma_position(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_position)
  return sigma_position_.Get(index);
}
inline void DynamicObstWorldSpaceInfo::set_sigma_position(int index, float value) {
  sigma_position_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_position)
}
inline void DynamicObstWorldSpaceInfo::add_sigma_position(float value) {
  sigma_position_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_position)
}
inline const ::google::protobuf::RepeatedField< float >&
DynamicObstWorldSpaceInfo::sigma_position() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_position)
  return sigma_position_;
}
inline ::google::protobuf::RepeatedField< float >*
DynamicObstWorldSpaceInfo::mutable_sigma_position() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_position)
  return &sigma_position_;
}

// float sigma_yaw_rate = 21;
inline void DynamicObstWorldSpaceInfo::clear_sigma_yaw_rate() {
  sigma_yaw_rate_ = 0;
}
inline float DynamicObstWorldSpaceInfo::sigma_yaw_rate() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_yaw_rate)
  return sigma_yaw_rate_;
}
inline void DynamicObstWorldSpaceInfo::set_sigma_yaw_rate(float value) {
  
  sigma_yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_yaw_rate)
}

// int32 head_rear_type = 22;
inline void DynamicObstWorldSpaceInfo::clear_head_rear_type() {
  head_rear_type_ = 0;
}
inline ::google::protobuf::int32 DynamicObstWorldSpaceInfo::head_rear_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.head_rear_type)
  return head_rear_type_;
}
inline void DynamicObstWorldSpaceInfo::set_head_rear_type(::google::protobuf::int32 value) {
  
  head_rear_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.head_rear_type)
}

// repeated float sigma_acc_ref = 23;
inline int DynamicObstWorldSpaceInfo::sigma_acc_ref_size() const {
  return sigma_acc_ref_.size();
}
inline void DynamicObstWorldSpaceInfo::clear_sigma_acc_ref() {
  sigma_acc_ref_.Clear();
}
inline float DynamicObstWorldSpaceInfo::sigma_acc_ref(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_acc_ref)
  return sigma_acc_ref_.Get(index);
}
inline void DynamicObstWorldSpaceInfo::set_sigma_acc_ref(int index, float value) {
  sigma_acc_ref_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_acc_ref)
}
inline void DynamicObstWorldSpaceInfo::add_sigma_acc_ref(float value) {
  sigma_acc_ref_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_acc_ref)
}
inline const ::google::protobuf::RepeatedField< float >&
DynamicObstWorldSpaceInfo::sigma_acc_ref() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_acc_ref)
  return sigma_acc_ref_;
}
inline ::google::protobuf::RepeatedField< float >*
DynamicObstWorldSpaceInfo::mutable_sigma_acc_ref() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_acc_ref)
  return &sigma_acc_ref_;
}

// .autodrive.workflow.proto.ObstacleAngle obj_angle = 24;
inline bool DynamicObstWorldSpaceInfo::has_obj_angle() const {
  return this != internal_default_instance() && obj_angle_ != NULL;
}
inline void DynamicObstWorldSpaceInfo::clear_obj_angle() {
  if (GetArenaNoVirtual() == NULL && obj_angle_ != NULL) {
    delete obj_angle_;
  }
  obj_angle_ = NULL;
}
inline const ::autodrive::workflow::proto::ObstacleAngle& DynamicObstWorldSpaceInfo::obj_angle() const {
  const ::autodrive::workflow::proto::ObstacleAngle* p = obj_angle_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.obj_angle)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::ObstacleAngle*>(
      &::autodrive::workflow::proto::_ObstacleAngle_default_instance_);
}
inline ::autodrive::workflow::proto::ObstacleAngle* DynamicObstWorldSpaceInfo::release_obj_angle() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.obj_angle)
  
  ::autodrive::workflow::proto::ObstacleAngle* temp = obj_angle_;
  obj_angle_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::ObstacleAngle* DynamicObstWorldSpaceInfo::mutable_obj_angle() {
  
  if (obj_angle_ == NULL) {
    obj_angle_ = new ::autodrive::workflow::proto::ObstacleAngle;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.obj_angle)
  return obj_angle_;
}
inline void DynamicObstWorldSpaceInfo::set_allocated_obj_angle(::autodrive::workflow::proto::ObstacleAngle* obj_angle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete obj_angle_;
  }
  if (obj_angle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      obj_angle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, obj_angle, submessage_arena);
    }
    
  } else {
    
  }
  obj_angle_ = obj_angle;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.obj_angle)
}

// int32 lane_assignment = 25;
inline void DynamicObstWorldSpaceInfo::clear_lane_assignment() {
  lane_assignment_ = 0;
}
inline ::google::protobuf::int32 DynamicObstWorldSpaceInfo::lane_assignment() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.lane_assignment)
  return lane_assignment_;
}
inline void DynamicObstWorldSpaceInfo::set_lane_assignment(::google::protobuf::int32 value) {
  
  lane_assignment_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.lane_assignment)
}

// int32 traversable = 26;
inline void DynamicObstWorldSpaceInfo::clear_traversable() {
  traversable_ = 0;
}
inline ::google::protobuf::int32 DynamicObstWorldSpaceInfo::traversable() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.traversable)
  return traversable_;
}
inline void DynamicObstWorldSpaceInfo::set_traversable(::google::protobuf::int32 value) {
  
  traversable_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.traversable)
}

// .autodrive.workflow.proto.DynamicObstVelocity vel = 27;
inline bool DynamicObstWorldSpaceInfo::has_vel() const {
  return this != internal_default_instance() && vel_ != NULL;
}
inline void DynamicObstWorldSpaceInfo::clear_vel() {
  if (GetArenaNoVirtual() == NULL && vel_ != NULL) {
    delete vel_;
  }
  vel_ = NULL;
}
inline const ::autodrive::workflow::proto::DynamicObstVelocity& DynamicObstWorldSpaceInfo::vel() const {
  const ::autodrive::workflow::proto::DynamicObstVelocity* p = vel_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.vel)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::DynamicObstVelocity*>(
      &::autodrive::workflow::proto::_DynamicObstVelocity_default_instance_);
}
inline ::autodrive::workflow::proto::DynamicObstVelocity* DynamicObstWorldSpaceInfo::release_vel() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.vel)
  
  ::autodrive::workflow::proto::DynamicObstVelocity* temp = vel_;
  vel_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::DynamicObstVelocity* DynamicObstWorldSpaceInfo::mutable_vel() {
  
  if (vel_ == NULL) {
    vel_ = new ::autodrive::workflow::proto::DynamicObstVelocity;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.vel)
  return vel_;
}
inline void DynamicObstWorldSpaceInfo::set_allocated_vel(::autodrive::workflow::proto::DynamicObstVelocity* vel) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vel_;
  }
  if (vel) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vel = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vel, submessage_arena);
    }
    
  } else {
    
  }
  vel_ = vel;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.vel)
}

// .autodrive.workflow.proto.perception_base.Polygon poly = 28;
inline bool DynamicObstWorldSpaceInfo::has_poly() const {
  return this != internal_default_instance() && poly_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Polygon& DynamicObstWorldSpaceInfo::poly() const {
  const ::autodrive::workflow::proto::perception_base::Polygon* p = poly_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.poly)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Polygon*>(
      &::autodrive::workflow::proto::perception_base::_Polygon_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Polygon* DynamicObstWorldSpaceInfo::release_poly() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.poly)
  
  ::autodrive::workflow::proto::perception_base::Polygon* temp = poly_;
  poly_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Polygon* DynamicObstWorldSpaceInfo::mutable_poly() {
  
  if (poly_ == NULL) {
    poly_ = new ::autodrive::workflow::proto::perception_base::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.poly)
  return poly_;
}
inline void DynamicObstWorldSpaceInfo::set_allocated_poly(::autodrive::workflow::proto::perception_base::Polygon* poly) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(poly_);
  }
  if (poly) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      poly = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, poly, submessage_arena);
    }
    
  } else {
    
  }
  poly_ = poly;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.poly)
}

// .autodrive.workflow.proto.perception_base.Polygon poly_vcs = 29;
inline bool DynamicObstWorldSpaceInfo::has_poly_vcs() const {
  return this != internal_default_instance() && poly_vcs_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Polygon& DynamicObstWorldSpaceInfo::poly_vcs() const {
  const ::autodrive::workflow::proto::perception_base::Polygon* p = poly_vcs_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.poly_vcs)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Polygon*>(
      &::autodrive::workflow::proto::perception_base::_Polygon_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Polygon* DynamicObstWorldSpaceInfo::release_poly_vcs() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.poly_vcs)
  
  ::autodrive::workflow::proto::perception_base::Polygon* temp = poly_vcs_;
  poly_vcs_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Polygon* DynamicObstWorldSpaceInfo::mutable_poly_vcs() {
  
  if (poly_vcs_ == NULL) {
    poly_vcs_ = new ::autodrive::workflow::proto::perception_base::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.poly_vcs)
  return poly_vcs_;
}
inline void DynamicObstWorldSpaceInfo::set_allocated_poly_vcs(::autodrive::workflow::proto::perception_base::Polygon* poly_vcs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(poly_vcs_);
  }
  if (poly_vcs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      poly_vcs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, poly_vcs, submessage_arena);
    }
    
  } else {
    
  }
  poly_vcs_ = poly_vcs;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.poly_vcs)
}

// .autodrive.workflow.proto.VisibleRect visible_rect = 30;
inline void DynamicObstWorldSpaceInfo::clear_visible_rect() {
  visible_rect_ = 0;
}
inline ::autodrive::workflow::proto::VisibleRect DynamicObstWorldSpaceInfo::visible_rect() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.visible_rect)
  return static_cast< ::autodrive::workflow::proto::VisibleRect >(visible_rect_);
}
inline void DynamicObstWorldSpaceInfo::set_visible_rect(::autodrive::workflow::proto::VisibleRect value) {
  
  visible_rect_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.visible_rect)
}

// .autodrive.workflow.proto.Vector3f rbc_position = 31;
inline bool DynamicObstWorldSpaceInfo::has_rbc_position() const {
  return this != internal_default_instance() && rbc_position_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& DynamicObstWorldSpaceInfo::rbc_position() const {
  const ::autodrive::workflow::proto::Vector3f* p = rbc_position_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.rbc_position)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* DynamicObstWorldSpaceInfo::release_rbc_position() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.rbc_position)
  
  ::autodrive::workflow::proto::Vector3f* temp = rbc_position_;
  rbc_position_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* DynamicObstWorldSpaceInfo::mutable_rbc_position() {
  
  if (rbc_position_ == NULL) {
    rbc_position_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.rbc_position)
  return rbc_position_;
}
inline void DynamicObstWorldSpaceInfo::set_allocated_rbc_position(::autodrive::workflow::proto::Vector3f* rbc_position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rbc_position_);
  }
  if (rbc_position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rbc_position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rbc_position, submessage_arena);
    }
    
  } else {
    
  }
  rbc_position_ = rbc_position;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.rbc_position)
}

// repeated float sigma_rbc_position = 32;
inline int DynamicObstWorldSpaceInfo::sigma_rbc_position_size() const {
  return sigma_rbc_position_.size();
}
inline void DynamicObstWorldSpaceInfo::clear_sigma_rbc_position() {
  sigma_rbc_position_.Clear();
}
inline float DynamicObstWorldSpaceInfo::sigma_rbc_position(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_rbc_position)
  return sigma_rbc_position_.Get(index);
}
inline void DynamicObstWorldSpaceInfo::set_sigma_rbc_position(int index, float value) {
  sigma_rbc_position_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_rbc_position)
}
inline void DynamicObstWorldSpaceInfo::add_sigma_rbc_position(float value) {
  sigma_rbc_position_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_rbc_position)
}
inline const ::google::protobuf::RepeatedField< float >&
DynamicObstWorldSpaceInfo::sigma_rbc_position() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_rbc_position)
  return sigma_rbc_position_;
}
inline ::google::protobuf::RepeatedField< float >*
DynamicObstWorldSpaceInfo::mutable_sigma_rbc_position() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.sigma_rbc_position)
  return &sigma_rbc_position_;
}

// int32 cipv = 33;
inline void DynamicObstWorldSpaceInfo::clear_cipv() {
  cipv_ = 0;
}
inline ::google::protobuf::int32 DynamicObstWorldSpaceInfo::cipv() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.cipv)
  return cipv_;
}
inline void DynamicObstWorldSpaceInfo::set_cipv(::google::protobuf::int32 value) {
  
  cipv_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.cipv)
}

// .autodrive.workflow.proto.DynamicObstAccelerate acc = 34;
inline bool DynamicObstWorldSpaceInfo::has_acc() const {
  return this != internal_default_instance() && acc_ != NULL;
}
inline void DynamicObstWorldSpaceInfo::clear_acc() {
  if (GetArenaNoVirtual() == NULL && acc_ != NULL) {
    delete acc_;
  }
  acc_ = NULL;
}
inline const ::autodrive::workflow::proto::DynamicObstAccelerate& DynamicObstWorldSpaceInfo::acc() const {
  const ::autodrive::workflow::proto::DynamicObstAccelerate* p = acc_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.acc)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::DynamicObstAccelerate*>(
      &::autodrive::workflow::proto::_DynamicObstAccelerate_default_instance_);
}
inline ::autodrive::workflow::proto::DynamicObstAccelerate* DynamicObstWorldSpaceInfo::release_acc() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.acc)
  
  ::autodrive::workflow::proto::DynamicObstAccelerate* temp = acc_;
  acc_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::DynamicObstAccelerate* DynamicObstWorldSpaceInfo::mutable_acc() {
  
  if (acc_ == NULL) {
    acc_ = new ::autodrive::workflow::proto::DynamicObstAccelerate;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.acc)
  return acc_;
}
inline void DynamicObstWorldSpaceInfo::set_allocated_acc(::autodrive::workflow::proto::DynamicObstAccelerate* acc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete acc_;
  }
  if (acc) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    
  } else {
    
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstWorldSpaceInfo.acc)
}

// -------------------------------------------------------------------

// DynamicObstacle

// uint32 id = 1;
inline void DynamicObstacle::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 DynamicObstacle::id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.id)
  return id_;
}
inline void DynamicObstacle::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstacle.id)
}

// int32 life_time = 2;
inline void DynamicObstacle::clear_life_time() {
  life_time_ = 0;
}
inline ::google::protobuf::int32 DynamicObstacle::life_time() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.life_time)
  return life_time_;
}
inline void DynamicObstacle::set_life_time(::google::protobuf::int32 value) {
  
  life_time_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstacle.life_time)
}

// int32 cam_id = 3;
inline void DynamicObstacle::clear_cam_id() {
  cam_id_ = 0;
}
inline ::google::protobuf::int32 DynamicObstacle::cam_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.cam_id)
  return cam_id_;
}
inline void DynamicObstacle::set_cam_id(::google::protobuf::int32 value) {
  
  cam_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstacle.cam_id)
}

// .autodrive.workflow.proto.DynamicObstacleType type = 4;
inline void DynamicObstacle::clear_type() {
  type_ = 0;
}
inline ::autodrive::workflow::proto::DynamicObstacleType DynamicObstacle::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.type)
  return static_cast< ::autodrive::workflow::proto::DynamicObstacleType >(type_);
}
inline void DynamicObstacle::set_type(::autodrive::workflow::proto::DynamicObstacleType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstacle.type)
}

// .autodrive.workflow.proto.VehicleType sub_type = 5;
inline void DynamicObstacle::clear_sub_type() {
  sub_type_ = 0;
}
inline ::autodrive::workflow::proto::VehicleType DynamicObstacle::sub_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.sub_type)
  return static_cast< ::autodrive::workflow::proto::VehicleType >(sub_type_);
}
inline void DynamicObstacle::set_sub_type(::autodrive::workflow::proto::VehicleType value) {
  
  sub_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstacle.sub_type)
}

// int64 time_stamp = 6;
inline void DynamicObstacle::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DynamicObstacle::time_stamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.time_stamp)
  return time_stamp_;
}
inline void DynamicObstacle::set_time_stamp(::google::protobuf::int64 value) {
  
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstacle.time_stamp)
}

// float conf = 7;
inline void DynamicObstacle::clear_conf() {
  conf_ = 0;
}
inline float DynamicObstacle::conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.conf)
  return conf_;
}
inline void DynamicObstacle::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstacle.conf)
}

// uint32 age = 8;
inline void DynamicObstacle::clear_age() {
  age_ = 0u;
}
inline ::google::protobuf::uint32 DynamicObstacle::age() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.age)
  return age_;
}
inline void DynamicObstacle::set_age(::google::protobuf::uint32 value) {
  
  age_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstacle.age)
}

// .autodrive.workflow.proto.perception_base.ImageSpace img_info = 9;
inline bool DynamicObstacle::has_img_info() const {
  return this != internal_default_instance() && img_info_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::ImageSpace& DynamicObstacle::img_info() const {
  const ::autodrive::workflow::proto::perception_base::ImageSpace* p = img_info_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.img_info)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::ImageSpace*>(
      &::autodrive::workflow::proto::perception_base::_ImageSpace_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::ImageSpace* DynamicObstacle::release_img_info() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstacle.img_info)
  
  ::autodrive::workflow::proto::perception_base::ImageSpace* temp = img_info_;
  img_info_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::ImageSpace* DynamicObstacle::mutable_img_info() {
  
  if (img_info_ == NULL) {
    img_info_ = new ::autodrive::workflow::proto::perception_base::ImageSpace;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstacle.img_info)
  return img_info_;
}
inline void DynamicObstacle::set_allocated_img_info(::autodrive::workflow::proto::perception_base::ImageSpace* img_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(img_info_);
  }
  if (img_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      img_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, img_info, submessage_arena);
    }
    
  } else {
    
  }
  img_info_ = img_info;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstacle.img_info)
}

// .autodrive.workflow.proto.DynamicObstWorldSpaceInfo world_info = 10;
inline bool DynamicObstacle::has_world_info() const {
  return this != internal_default_instance() && world_info_ != NULL;
}
inline void DynamicObstacle::clear_world_info() {
  if (GetArenaNoVirtual() == NULL && world_info_ != NULL) {
    delete world_info_;
  }
  world_info_ = NULL;
}
inline const ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo& DynamicObstacle::world_info() const {
  const ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo* p = world_info_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.world_info)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo*>(
      &::autodrive::workflow::proto::_DynamicObstWorldSpaceInfo_default_instance_);
}
inline ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo* DynamicObstacle::release_world_info() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DynamicObstacle.world_info)
  
  ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo* temp = world_info_;
  world_info_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo* DynamicObstacle::mutable_world_info() {
  
  if (world_info_ == NULL) {
    world_info_ = new ::autodrive::workflow::proto::DynamicObstWorldSpaceInfo;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstacle.world_info)
  return world_info_;
}
inline void DynamicObstacle::set_allocated_world_info(::autodrive::workflow::proto::DynamicObstWorldSpaceInfo* world_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete world_info_;
  }
  if (world_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_info, submessage_arena);
    }
    
  } else {
    
  }
  world_info_ = world_info;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DynamicObstacle.world_info)
}

// int32 valid_info = 11;
inline void DynamicObstacle::clear_valid_info() {
  valid_info_ = 0;
}
inline ::google::protobuf::int32 DynamicObstacle::valid_info() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.valid_info)
  return valid_info_;
}
inline void DynamicObstacle::set_valid_info(::google::protobuf::int32 value) {
  
  valid_info_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstacle.valid_info)
}

// int32 select_level = 12;
inline void DynamicObstacle::clear_select_level() {
  select_level_ = 0;
}
inline ::google::protobuf::int32 DynamicObstacle::select_level() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.select_level)
  return select_level_;
}
inline void DynamicObstacle::set_select_level(::google::protobuf::int32 value) {
  
  select_level_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DynamicObstacle.select_level)
}

// repeated .autodrive.workflow.proto.perception_base.Category category = 13;
inline int DynamicObstacle::category_size() const {
  return category_.size();
}
inline const ::autodrive::workflow::proto::perception_base::Category& DynamicObstacle::category(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DynamicObstacle.category)
  return category_.Get(index);
}
inline ::autodrive::workflow::proto::perception_base::Category* DynamicObstacle::mutable_category(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DynamicObstacle.category)
  return category_.Mutable(index);
}
inline ::autodrive::workflow::proto::perception_base::Category* DynamicObstacle::add_category() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.DynamicObstacle.category)
  return category_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >*
DynamicObstacle::mutable_category() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.DynamicObstacle.category)
  return &category_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >&
DynamicObstacle::category() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.DynamicObstacle.category)
  return category_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::DynamicObstacleType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::DynamicObstacleType>() {
  return ::autodrive::workflow::proto::DynamicObstacleType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::VehicleType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::VehicleType>() {
  return ::autodrive::workflow::proto::VehicleType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::DynamicObstacleMotionStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::DynamicObstacleMotionStatus>() {
  return ::autodrive::workflow::proto::DynamicObstacleMotionStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::MotionCategory> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::MotionCategory>() {
  return ::autodrive::workflow::proto::MotionCategory_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::MotionOrientation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::MotionOrientation>() {
  return ::autodrive::workflow::proto::MotionOrientation_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::VisibleSide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::VisibleSide>() {
  return ::autodrive::workflow::proto::VisibleSide_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::VisibleRect> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::VisibleRect>() {
  return ::autodrive::workflow::proto::VisibleRect_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::OutputObsPositionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::OutputObsPositionType>() {
  return ::autodrive::workflow::proto::OutputObsPositionType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dynamic_5fobstacle_2eproto__INCLUDED
