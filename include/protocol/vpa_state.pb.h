// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vpa_state.proto

#ifndef PROTOBUF_vpa_5fstate_2eproto__INCLUDED
#define PROTOBUF_vpa_5fstate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_vpa_5fstate_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsVpaStateMsgImpl();
void InitDefaultsVpaStateMsg();
inline void InitDefaults() {
  InitDefaultsVpaStateMsg();
}
}  // namespace protobuf_vpa_5fstate_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
class VpaStateMsg;
class VpaStateMsgDefaultTypeInternal;
extern VpaStateMsgDefaultTypeInternal _VpaStateMsg_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {

enum MapDeletingStage {
  kMapDeletingStageDefault = 0,
  kMapDeletingStageDeleting = 1,
  kMapDeletingStageDeleteSucessful = 2,
  kMapDeletingStageDeleteFailed = 3,
  MapDeletingStage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MapDeletingStage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MapDeletingStage_IsValid(int value);
const MapDeletingStage MapDeletingStage_MIN = kMapDeletingStageDefault;
const MapDeletingStage MapDeletingStage_MAX = kMapDeletingStageDeleteFailed;
const int MapDeletingStage_ARRAYSIZE = MapDeletingStage_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapDeletingStage_descriptor();
inline const ::std::string& MapDeletingStage_Name(MapDeletingStage value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapDeletingStage_descriptor(), value);
}
inline bool MapDeletingStage_Parse(
    const ::std::string& name, MapDeletingStage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapDeletingStage>(
    MapDeletingStage_descriptor(), name, value);
}
enum MapSavingStage {
  kMapSavingStageDefault = 0,
  kMapSavingStageSaving = 1,
  kMapSavingStageSaveSucessful = 2,
  kMapSavingStageSaveFailed = 3,
  MapSavingStage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MapSavingStage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MapSavingStage_IsValid(int value);
const MapSavingStage MapSavingStage_MIN = kMapSavingStageDefault;
const MapSavingStage MapSavingStage_MAX = kMapSavingStageSaveFailed;
const int MapSavingStage_ARRAYSIZE = MapSavingStage_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapSavingStage_descriptor();
inline const ::std::string& MapSavingStage_Name(MapSavingStage value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapSavingStage_descriptor(), value);
}
inline bool MapSavingStage_Parse(
    const ::std::string& name, MapSavingStage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapSavingStage>(
    MapSavingStage_descriptor(), name, value);
}
enum MappingOddType {
  kMappingOddDefault = 0,
  kMappingOddOk = 1,
  kMappingOddNokNotIndoor = 2,
  kMappingOddNokNotUndergroundPark = 3,
  kMappingOddNokSpeedOutOfLimit = 4,
  kMappingOddNokNoSemanticInfo = 5,
  kMappingOddNokNotEnoughSemanticInfo = 6,
  kMappingOddNokLightnessNok = 7,
  kMappingOddNokRainFallNok = 8,
  kMappingOddNokSlopeOutOfLimit = 9,
  kMappingOddNokPreConditionCheck = 10,
  kMappingOddNokReserved = 11,
  MappingOddType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MappingOddType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MappingOddType_IsValid(int value);
const MappingOddType MappingOddType_MIN = kMappingOddDefault;
const MappingOddType MappingOddType_MAX = kMappingOddNokReserved;
const int MappingOddType_ARRAYSIZE = MappingOddType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MappingOddType_descriptor();
inline const ::std::string& MappingOddType_Name(MappingOddType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MappingOddType_descriptor(), value);
}
inline bool MappingOddType_Parse(
    const ::std::string& name, MappingOddType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MappingOddType>(
    MappingOddType_descriptor(), name, value);
}
enum LocOddType {
  kLocOddDefault = 0,
  kLocOddOk = 1,
  kLocOddNokNotIndoor = 2,
  kLocOddNokNotUndergroundPark = 3,
  kLocOddNokSpeedOutOfLimit = 4,
  kLocOddNokNoSemanticInfo = 5,
  kLocOddNokNotEnoughSemanticInfo = 6,
  kLocOddNokLightnessNok = 7,
  kLocOddNokRainFallNok = 8,
  kLocOddNokSlopeOutOfLimit = 9,
  kLocOddNokPreConditionCheck = 10,
  kLocOddNokReserved = 11,
  LocOddType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LocOddType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LocOddType_IsValid(int value);
const LocOddType LocOddType_MIN = kLocOddDefault;
const LocOddType LocOddType_MAX = kLocOddNokReserved;
const int LocOddType_ARRAYSIZE = LocOddType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocOddType_descriptor();
inline const ::std::string& LocOddType_Name(LocOddType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocOddType_descriptor(), value);
}
inline bool LocOddType_Parse(
    const ::std::string& name, LocOddType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocOddType>(
    LocOddType_descriptor(), name, value);
}
enum LocalLocStage {
  kLocalLocStageNO = 0,
  kLocalLocStageOngoing = 1,
  kLocalLocStageSuccess = 2,
  LocalLocStage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LocalLocStage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LocalLocStage_IsValid(int value);
const LocalLocStage LocalLocStage_MIN = kLocalLocStageNO;
const LocalLocStage LocalLocStage_MAX = kLocalLocStageSuccess;
const int LocalLocStage_ARRAYSIZE = LocalLocStage_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocalLocStage_descriptor();
inline const ::std::string& LocalLocStage_Name(LocalLocStage value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocalLocStage_descriptor(), value);
}
inline bool LocalLocStage_Parse(
    const ::std::string& name, LocalLocStage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocalLocStage>(
    LocalLocStage_descriptor(), name, value);
}
enum ErrorCode {
  kNoError = 0,
  kErrorInsufficientDiskFreespace = 1,
  kErrorTsReset = 1000,
  kErrorNoPerception = 1001,
  kError3dOdoAbnormal = 1002,
  kErrorOdomError = 1003,
  kErrorNoSyncGnss = 1004,
  kErrorInvalidGnss = 1005,
  kErrorWaitForSlotTooLong = 2000,
  kErrorOutdoorInMapping = 2001,
  kErrorMapUnsuitableForLocalization = 2002,
  kErrorMapOptimizationTimeOut = 2003,
  kErrorMappingDistTooLong = 2004,
  kErrorMappingDistTooShort = 2005,
  kErrorMapPlanningFailed = 2006,
  kErrorMapSaveFailed = 2007,
  kErrorMappingCrossFloor = 2008,
  kErrorMapLoopClosure = 2009,
  kErrorDeleteNotExistMap = 2010,
  kErrorOverSpeed = 2011,
  kErrorOverSpeedTimeOut = 2012,
  kErrorOverSlope = 2013,
  kErrorGearRDistanceTooLong = 2014,
  kErrorNoAvaliableMapFound = 2015,
  kErrorNotInParkingSlot = 2016,
  kErrorLocDeviationFromNavigation = 3000,
  kErrorMapMatchingError = 3001,
  kErrorOutOfMap = 3002,
  kErrorMissMapKeyElements = 3003,
  kErrorPoseOdomInconsistency = 3004,
  kErrorMapError = 3005,
  kErrorNoMap = 3006,
  kErrorMapFileError = 3007,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = kNoError;
const ErrorCode ErrorCode_MAX = kErrorMapFileError;
const int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor();
inline const ::std::string& ErrorCode_Name(ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorCode_descriptor(), value);
}
inline bool ErrorCode_Parse(
    const ::std::string& name, ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
enum HPAState {
  kHPAStateDefault = 0,
  kHPAStateOff = 1,
  kHPAStateStandby = 2,
  kHPAStatePathLearning = 3,
  kHPAStateCruising = 4,
  kHPAStatekPreConditionCheck = 5,
  HPAState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  HPAState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool HPAState_IsValid(int value);
const HPAState HPAState_MIN = kHPAStateDefault;
const HPAState HPAState_MAX = kHPAStatekPreConditionCheck;
const int HPAState_ARRAYSIZE = HPAState_MAX + 1;

const ::google::protobuf::EnumDescriptor* HPAState_descriptor();
inline const ::std::string& HPAState_Name(HPAState value) {
  return ::google::protobuf::internal::NameOfEnum(
    HPAState_descriptor(), value);
}
inline bool HPAState_Parse(
    const ::std::string& name, HPAState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HPAState>(
    HPAState_descriptor(), name, value);
}
enum VPAEventType {
  kVPAEventTypeDefault = 0,
  kVPAEventTypeErrorEvent = 1,
  kVPAEventTypeRequestMappingEvent = 2,
  kVPAEventTypeRequestLocalizationEvent = 3,
  kVPAEventTypeLocOddEvent = 4,
  kVPAEventTypeMappingOddEvent = 5,
  kVPAEventTypeHpaStateEvent = 6,
  kVPAEventTypeMapSavingStageEvent = 7,
  kVPAEventTypeLocalLocStageEvent = 8,
  kVPAEventTypeFirstTimeMappingEvent = 9,
  kVPAEventTypeFirstTimeCurParkingMappingEvent = 10,
  kVPAEventTypeFindAvailableMapEvent = 11,
  kVPAEventTypeMapDeleteStageEvent = 12,
  kVPAEventTypeEnterUndergroundParkingEvent = 13,
  kInParkingSlotEvent = 14,
  kMappingStageEvent = 15,
  kMappingOptimizeStageEvent = 16,
  kOutUndergroundParkingEvent = 17,
  kFindValidGNSSEvent = 18,
  VPAEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VPAEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VPAEventType_IsValid(int value);
const VPAEventType VPAEventType_MIN = kVPAEventTypeDefault;
const VPAEventType VPAEventType_MAX = kFindValidGNSSEvent;
const int VPAEventType_ARRAYSIZE = VPAEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* VPAEventType_descriptor();
inline const ::std::string& VPAEventType_Name(VPAEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    VPAEventType_descriptor(), value);
}
inline bool VPAEventType_Parse(
    const ::std::string& name, VPAEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VPAEventType>(
    VPAEventType_descriptor(), name, value);
}
enum MappingStage {
  kDefaultMappingStage = 0,
  kMapping = 1,
  kMappingSuccess = 2,
  kMappingFailed = 3,
  MappingStage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MappingStage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MappingStage_IsValid(int value);
const MappingStage MappingStage_MIN = kDefaultMappingStage;
const MappingStage MappingStage_MAX = kMappingFailed;
const int MappingStage_ARRAYSIZE = MappingStage_MAX + 1;

const ::google::protobuf::EnumDescriptor* MappingStage_descriptor();
inline const ::std::string& MappingStage_Name(MappingStage value) {
  return ::google::protobuf::internal::NameOfEnum(
    MappingStage_descriptor(), value);
}
inline bool MappingStage_Parse(
    const ::std::string& name, MappingStage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MappingStage>(
    MappingStage_descriptor(), name, value);
}
enum MapOptimizeStage {
  kDefaultMapOptimizeStage = 0,
  kOptimizing = 1,
  kOptimizeSuccess = 2,
  kOptimizeFailed = 3,
  MapOptimizeStage_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MapOptimizeStage_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MapOptimizeStage_IsValid(int value);
const MapOptimizeStage MapOptimizeStage_MIN = kDefaultMapOptimizeStage;
const MapOptimizeStage MapOptimizeStage_MAX = kOptimizeFailed;
const int MapOptimizeStage_ARRAYSIZE = MapOptimizeStage_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapOptimizeStage_descriptor();
inline const ::std::string& MapOptimizeStage_Name(MapOptimizeStage value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapOptimizeStage_descriptor(), value);
}
inline bool MapOptimizeStage_Parse(
    const ::std::string& name, MapOptimizeStage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapOptimizeStage>(
    MapOptimizeStage_descriptor(), name, value);
}
// ===================================================================

class VpaStateMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.VpaStateMsg) */ {
 public:
  VpaStateMsg();
  virtual ~VpaStateMsg();

  VpaStateMsg(const VpaStateMsg& from);

  inline VpaStateMsg& operator=(const VpaStateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VpaStateMsg(VpaStateMsg&& from) noexcept
    : VpaStateMsg() {
    *this = ::std::move(from);
  }

  inline VpaStateMsg& operator=(VpaStateMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VpaStateMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VpaStateMsg* internal_default_instance() {
    return reinterpret_cast<const VpaStateMsg*>(
               &_VpaStateMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(VpaStateMsg* other);
  friend void swap(VpaStateMsg& a, VpaStateMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VpaStateMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  VpaStateMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VpaStateMsg& from);
  void MergeFrom(const VpaStateMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VpaStateMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.MsgHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::MsgHeader& header() const;
  ::autodrive::workflow::proto::MsgHeader* release_header();
  ::autodrive::workflow::proto::MsgHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::MsgHeader* header);

  // .autodrive.workflow.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::autodrive::workflow::proto::Error& error() const;
  ::autodrive::workflow::proto::Error* release_error();
  ::autodrive::workflow::proto::Error* mutable_error();
  void set_allocated_error(::autodrive::workflow::proto::Error* error);

  // .autodrive.workflow.proto.VPAEventType vpa_event = 3;
  void clear_vpa_event();
  static const int kVpaEventFieldNumber = 3;
  ::autodrive::workflow::proto::VPAEventType vpa_event() const;
  void set_vpa_event(::autodrive::workflow::proto::VPAEventType value);

  // .autodrive.workflow.proto.HPAState hpa_state = 4;
  void clear_hpa_state();
  static const int kHpaStateFieldNumber = 4;
  ::autodrive::workflow::proto::HPAState hpa_state() const;
  void set_hpa_state(::autodrive::workflow::proto::HPAState value);

  // .autodrive.workflow.proto.MappingOddType mapping_odd_type = 5;
  void clear_mapping_odd_type();
  static const int kMappingOddTypeFieldNumber = 5;
  ::autodrive::workflow::proto::MappingOddType mapping_odd_type() const;
  void set_mapping_odd_type(::autodrive::workflow::proto::MappingOddType value);

  // .autodrive.workflow.proto.LocOddType loc_odd_type = 6;
  void clear_loc_odd_type();
  static const int kLocOddTypeFieldNumber = 6;
  ::autodrive::workflow::proto::LocOddType loc_odd_type() const;
  void set_loc_odd_type(::autodrive::workflow::proto::LocOddType value);

  // .autodrive.workflow.proto.MapSavingStage map_saving_stage = 7;
  void clear_map_saving_stage();
  static const int kMapSavingStageFieldNumber = 7;
  ::autodrive::workflow::proto::MapSavingStage map_saving_stage() const;
  void set_map_saving_stage(::autodrive::workflow::proto::MapSavingStage value);

  // .autodrive.workflow.proto.LocalLocStage local_loc_stage = 8;
  void clear_local_loc_stage();
  static const int kLocalLocStageFieldNumber = 8;
  ::autodrive::workflow::proto::LocalLocStage local_loc_stage() const;
  void set_local_loc_stage(::autodrive::workflow::proto::LocalLocStage value);

  // .autodrive.workflow.proto.MapDeletingStage map_deleted_stage = 9;
  void clear_map_deleted_stage();
  static const int kMapDeletedStageFieldNumber = 9;
  ::autodrive::workflow::proto::MapDeletingStage map_deleted_stage() const;
  void set_map_deleted_stage(::autodrive::workflow::proto::MapDeletingStage value);

  // .autodrive.workflow.proto.MappingStage map_stage = 10;
  void clear_map_stage();
  static const int kMapStageFieldNumber = 10;
  ::autodrive::workflow::proto::MappingStage map_stage() const;
  void set_map_stage(::autodrive::workflow::proto::MappingStage value);

  // .autodrive.workflow.proto.MapOptimizeStage map_optimized_stage = 11;
  void clear_map_optimized_stage();
  static const int kMapOptimizedStageFieldNumber = 11;
  ::autodrive::workflow::proto::MapOptimizeStage map_optimized_stage() const;
  void set_map_optimized_stage(::autodrive::workflow::proto::MapOptimizeStage value);

  // .autodrive.workflow.proto.ErrorCode error_code = 12;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 12;
  ::autodrive::workflow::proto::ErrorCode error_code() const;
  void set_error_code(::autodrive::workflow::proto::ErrorCode value);

  // int32 target_parking_slot_id = 13;
  void clear_target_parking_slot_id();
  static const int kTargetParkingSlotIdFieldNumber = 13;
  ::google::protobuf::int32 target_parking_slot_id() const;
  void set_target_parking_slot_id(::google::protobuf::int32 value);

  // uint32 map_saving_progress = 14;
  void clear_map_saving_progress();
  static const int kMapSavingProgressFieldNumber = 14;
  ::google::protobuf::uint32 map_saving_progress() const;
  void set_map_saving_progress(::google::protobuf::uint32 value);

  // uint32 avaliable_map_id = 15;
  void clear_avaliable_map_id();
  static const int kAvaliableMapIdFieldNumber = 15;
  ::google::protobuf::uint32 avaliable_map_id() const;
  void set_avaliable_map_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.VpaStateMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::MsgHeader* header_;
  ::autodrive::workflow::proto::Error* error_;
  int vpa_event_;
  int hpa_state_;
  int mapping_odd_type_;
  int loc_odd_type_;
  int map_saving_stage_;
  int local_loc_stage_;
  int map_deleted_stage_;
  int map_stage_;
  int map_optimized_stage_;
  int error_code_;
  ::google::protobuf::int32 target_parking_slot_id_;
  ::google::protobuf::uint32 map_saving_progress_;
  ::google::protobuf::uint32 avaliable_map_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_vpa_5fstate_2eproto::TableStruct;
  friend void ::protobuf_vpa_5fstate_2eproto::InitDefaultsVpaStateMsgImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VpaStateMsg

// .autodrive.workflow.proto.MsgHeader header = 1;
inline bool VpaStateMsg::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::MsgHeader& VpaStateMsg::header() const {
  const ::autodrive::workflow::proto::MsgHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::MsgHeader*>(
      &::autodrive::workflow::proto::_MsgHeader_default_instance_);
}
inline ::autodrive::workflow::proto::MsgHeader* VpaStateMsg::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.VpaStateMsg.header)
  
  ::autodrive::workflow::proto::MsgHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::MsgHeader* VpaStateMsg::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::MsgHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.VpaStateMsg.header)
  return header_;
}
inline void VpaStateMsg::set_allocated_header(::autodrive::workflow::proto::MsgHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.VpaStateMsg.header)
}

// .autodrive.workflow.proto.Error error = 2;
inline bool VpaStateMsg::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::autodrive::workflow::proto::Error& VpaStateMsg::error() const {
  const ::autodrive::workflow::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.error)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Error*>(
      &::autodrive::workflow::proto::_Error_default_instance_);
}
inline ::autodrive::workflow::proto::Error* VpaStateMsg::release_error() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.VpaStateMsg.error)
  
  ::autodrive::workflow::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Error* VpaStateMsg::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::autodrive::workflow::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.VpaStateMsg.error)
  return error_;
}
inline void VpaStateMsg::set_allocated_error(::autodrive::workflow::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.VpaStateMsg.error)
}

// .autodrive.workflow.proto.VPAEventType vpa_event = 3;
inline void VpaStateMsg::clear_vpa_event() {
  vpa_event_ = 0;
}
inline ::autodrive::workflow::proto::VPAEventType VpaStateMsg::vpa_event() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.vpa_event)
  return static_cast< ::autodrive::workflow::proto::VPAEventType >(vpa_event_);
}
inline void VpaStateMsg::set_vpa_event(::autodrive::workflow::proto::VPAEventType value) {
  
  vpa_event_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.vpa_event)
}

// .autodrive.workflow.proto.HPAState hpa_state = 4;
inline void VpaStateMsg::clear_hpa_state() {
  hpa_state_ = 0;
}
inline ::autodrive::workflow::proto::HPAState VpaStateMsg::hpa_state() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.hpa_state)
  return static_cast< ::autodrive::workflow::proto::HPAState >(hpa_state_);
}
inline void VpaStateMsg::set_hpa_state(::autodrive::workflow::proto::HPAState value) {
  
  hpa_state_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.hpa_state)
}

// .autodrive.workflow.proto.MappingOddType mapping_odd_type = 5;
inline void VpaStateMsg::clear_mapping_odd_type() {
  mapping_odd_type_ = 0;
}
inline ::autodrive::workflow::proto::MappingOddType VpaStateMsg::mapping_odd_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.mapping_odd_type)
  return static_cast< ::autodrive::workflow::proto::MappingOddType >(mapping_odd_type_);
}
inline void VpaStateMsg::set_mapping_odd_type(::autodrive::workflow::proto::MappingOddType value) {
  
  mapping_odd_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.mapping_odd_type)
}

// .autodrive.workflow.proto.LocOddType loc_odd_type = 6;
inline void VpaStateMsg::clear_loc_odd_type() {
  loc_odd_type_ = 0;
}
inline ::autodrive::workflow::proto::LocOddType VpaStateMsg::loc_odd_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.loc_odd_type)
  return static_cast< ::autodrive::workflow::proto::LocOddType >(loc_odd_type_);
}
inline void VpaStateMsg::set_loc_odd_type(::autodrive::workflow::proto::LocOddType value) {
  
  loc_odd_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.loc_odd_type)
}

// .autodrive.workflow.proto.MapSavingStage map_saving_stage = 7;
inline void VpaStateMsg::clear_map_saving_stage() {
  map_saving_stage_ = 0;
}
inline ::autodrive::workflow::proto::MapSavingStage VpaStateMsg::map_saving_stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.map_saving_stage)
  return static_cast< ::autodrive::workflow::proto::MapSavingStage >(map_saving_stage_);
}
inline void VpaStateMsg::set_map_saving_stage(::autodrive::workflow::proto::MapSavingStage value) {
  
  map_saving_stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.map_saving_stage)
}

// .autodrive.workflow.proto.LocalLocStage local_loc_stage = 8;
inline void VpaStateMsg::clear_local_loc_stage() {
  local_loc_stage_ = 0;
}
inline ::autodrive::workflow::proto::LocalLocStage VpaStateMsg::local_loc_stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.local_loc_stage)
  return static_cast< ::autodrive::workflow::proto::LocalLocStage >(local_loc_stage_);
}
inline void VpaStateMsg::set_local_loc_stage(::autodrive::workflow::proto::LocalLocStage value) {
  
  local_loc_stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.local_loc_stage)
}

// .autodrive.workflow.proto.MapDeletingStage map_deleted_stage = 9;
inline void VpaStateMsg::clear_map_deleted_stage() {
  map_deleted_stage_ = 0;
}
inline ::autodrive::workflow::proto::MapDeletingStage VpaStateMsg::map_deleted_stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.map_deleted_stage)
  return static_cast< ::autodrive::workflow::proto::MapDeletingStage >(map_deleted_stage_);
}
inline void VpaStateMsg::set_map_deleted_stage(::autodrive::workflow::proto::MapDeletingStage value) {
  
  map_deleted_stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.map_deleted_stage)
}

// .autodrive.workflow.proto.MappingStage map_stage = 10;
inline void VpaStateMsg::clear_map_stage() {
  map_stage_ = 0;
}
inline ::autodrive::workflow::proto::MappingStage VpaStateMsg::map_stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.map_stage)
  return static_cast< ::autodrive::workflow::proto::MappingStage >(map_stage_);
}
inline void VpaStateMsg::set_map_stage(::autodrive::workflow::proto::MappingStage value) {
  
  map_stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.map_stage)
}

// .autodrive.workflow.proto.MapOptimizeStage map_optimized_stage = 11;
inline void VpaStateMsg::clear_map_optimized_stage() {
  map_optimized_stage_ = 0;
}
inline ::autodrive::workflow::proto::MapOptimizeStage VpaStateMsg::map_optimized_stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.map_optimized_stage)
  return static_cast< ::autodrive::workflow::proto::MapOptimizeStage >(map_optimized_stage_);
}
inline void VpaStateMsg::set_map_optimized_stage(::autodrive::workflow::proto::MapOptimizeStage value) {
  
  map_optimized_stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.map_optimized_stage)
}

// .autodrive.workflow.proto.ErrorCode error_code = 12;
inline void VpaStateMsg::clear_error_code() {
  error_code_ = 0;
}
inline ::autodrive::workflow::proto::ErrorCode VpaStateMsg::error_code() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.error_code)
  return static_cast< ::autodrive::workflow::proto::ErrorCode >(error_code_);
}
inline void VpaStateMsg::set_error_code(::autodrive::workflow::proto::ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.error_code)
}

// int32 target_parking_slot_id = 13;
inline void VpaStateMsg::clear_target_parking_slot_id() {
  target_parking_slot_id_ = 0;
}
inline ::google::protobuf::int32 VpaStateMsg::target_parking_slot_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.target_parking_slot_id)
  return target_parking_slot_id_;
}
inline void VpaStateMsg::set_target_parking_slot_id(::google::protobuf::int32 value) {
  
  target_parking_slot_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.target_parking_slot_id)
}

// uint32 map_saving_progress = 14;
inline void VpaStateMsg::clear_map_saving_progress() {
  map_saving_progress_ = 0u;
}
inline ::google::protobuf::uint32 VpaStateMsg::map_saving_progress() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.map_saving_progress)
  return map_saving_progress_;
}
inline void VpaStateMsg::set_map_saving_progress(::google::protobuf::uint32 value) {
  
  map_saving_progress_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.map_saving_progress)
}

// uint32 avaliable_map_id = 15;
inline void VpaStateMsg::clear_avaliable_map_id() {
  avaliable_map_id_ = 0u;
}
inline ::google::protobuf::uint32 VpaStateMsg::avaliable_map_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VpaStateMsg.avaliable_map_id)
  return avaliable_map_id_;
}
inline void VpaStateMsg::set_avaliable_map_id(::google::protobuf::uint32 value) {
  
  avaliable_map_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VpaStateMsg.avaliable_map_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::MapDeletingStage> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::MapDeletingStage>() {
  return ::autodrive::workflow::proto::MapDeletingStage_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::MapSavingStage> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::MapSavingStage>() {
  return ::autodrive::workflow::proto::MapSavingStage_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::MappingOddType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::MappingOddType>() {
  return ::autodrive::workflow::proto::MappingOddType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::LocOddType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::LocOddType>() {
  return ::autodrive::workflow::proto::LocOddType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::LocalLocStage> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::LocalLocStage>() {
  return ::autodrive::workflow::proto::LocalLocStage_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ErrorCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ErrorCode>() {
  return ::autodrive::workflow::proto::ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::HPAState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::HPAState>() {
  return ::autodrive::workflow::proto::HPAState_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::VPAEventType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::VPAEventType>() {
  return ::autodrive::workflow::proto::VPAEventType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::MappingStage> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::MappingStage>() {
  return ::autodrive::workflow::proto::MappingStage_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::MapOptimizeStage> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::MapOptimizeStage>() {
  return ::autodrive::workflow::proto::MapOptimizeStage_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vpa_5fstate_2eproto__INCLUDED
