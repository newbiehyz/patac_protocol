// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: obstacle_raw.proto

#ifndef PROTOBUF_obstacle_5fraw_2eproto__INCLUDED
#define PROTOBUF_obstacle_5fraw_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
#include "perception_base.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_obstacle_5fraw_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPropertyPerceptionBBoxImpl();
void InitDefaultsPropertyPerceptionBBox();
void InitDefaultsObstacleRawKeyPointImpl();
void InitDefaultsObstacleRawKeyPoint();
void InitDefaultsTrackingFeatureRawImpl();
void InitDefaultsTrackingFeatureRaw();
void InitDefaultsPoseNetRawImpl();
void InitDefaultsPoseNetRaw();
void InitDefaultsKpsClsRawImpl();
void InitDefaultsKpsClsRaw();
void InitDefaultsKeyPointsRawImpl();
void InitDefaultsKeyPointsRaw();
void InitDefaultsPRFromGroundImpl();
void InitDefaultsPRFromGround();
void InitDefaultsKeyPointsRawDataImpl();
void InitDefaultsKeyPointsRawData();
void InitDefaultsObstacleRawImpl();
void InitDefaultsObstacleRaw();
void InitDefaultsObstacleRawsDataImpl();
void InitDefaultsObstacleRawsData();
inline void InitDefaults() {
  InitDefaultsPropertyPerceptionBBox();
  InitDefaultsObstacleRawKeyPoint();
  InitDefaultsTrackingFeatureRaw();
  InitDefaultsPoseNetRaw();
  InitDefaultsKpsClsRaw();
  InitDefaultsKeyPointsRaw();
  InitDefaultsPRFromGround();
  InitDefaultsKeyPointsRawData();
  InitDefaultsObstacleRaw();
  InitDefaultsObstacleRawsData();
}
}  // namespace protobuf_obstacle_5fraw_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
class KeyPointsRaw;
class KeyPointsRawDefaultTypeInternal;
extern KeyPointsRawDefaultTypeInternal _KeyPointsRaw_default_instance_;
class KeyPointsRawData;
class KeyPointsRawDataDefaultTypeInternal;
extern KeyPointsRawDataDefaultTypeInternal _KeyPointsRawData_default_instance_;
class KpsClsRaw;
class KpsClsRawDefaultTypeInternal;
extern KpsClsRawDefaultTypeInternal _KpsClsRaw_default_instance_;
class ObstacleRaw;
class ObstacleRawDefaultTypeInternal;
extern ObstacleRawDefaultTypeInternal _ObstacleRaw_default_instance_;
class ObstacleRawKeyPoint;
class ObstacleRawKeyPointDefaultTypeInternal;
extern ObstacleRawKeyPointDefaultTypeInternal _ObstacleRawKeyPoint_default_instance_;
class ObstacleRawsData;
class ObstacleRawsDataDefaultTypeInternal;
extern ObstacleRawsDataDefaultTypeInternal _ObstacleRawsData_default_instance_;
class PRFromGround;
class PRFromGroundDefaultTypeInternal;
extern PRFromGroundDefaultTypeInternal _PRFromGround_default_instance_;
class PoseNetRaw;
class PoseNetRawDefaultTypeInternal;
extern PoseNetRawDefaultTypeInternal _PoseNetRaw_default_instance_;
class PropertyPerceptionBBox;
class PropertyPerceptionBBoxDefaultTypeInternal;
extern PropertyPerceptionBBoxDefaultTypeInternal _PropertyPerceptionBBox_default_instance_;
class TrackingFeatureRaw;
class TrackingFeatureRawDefaultTypeInternal;
extern TrackingFeatureRawDefaultTypeInternal _TrackingFeatureRaw_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {

enum VehPropertyPerceptionType {
  kVehPerceptionTypeLicensePlate = 0,
  kVehPerceptionTypeWheel = 1,
  kVehPerceptionTypeCnt = 2,
  VehPropertyPerceptionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VehPropertyPerceptionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VehPropertyPerceptionType_IsValid(int value);
const VehPropertyPerceptionType VehPropertyPerceptionType_MIN = kVehPerceptionTypeLicensePlate;
const VehPropertyPerceptionType VehPropertyPerceptionType_MAX = kVehPerceptionTypeCnt;
const int VehPropertyPerceptionType_ARRAYSIZE = VehPropertyPerceptionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehPropertyPerceptionType_descriptor();
inline const ::std::string& VehPropertyPerceptionType_Name(VehPropertyPerceptionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehPropertyPerceptionType_descriptor(), value);
}
inline bool VehPropertyPerceptionType_Parse(
    const ::std::string& name, VehPropertyPerceptionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehPropertyPerceptionType>(
    VehPropertyPerceptionType_descriptor(), name, value);
}
enum ObstacleRawModelType {
  kObstacleRawModelCar = 0,
  kObstacleRawModelFullCar = 1,
  kObstacleRawModelPed = 2,
  kObstacleRawModelHead = 3,
  kObstacleRawModelRare = 4,
  kObstacleRawModelTrafficSign = 5,
  kObstacleRawModelTrafficLight = 6,
  kObstacleRawModelLane = 7,
  kObstacleRawModelRoadSign = 10,
  kObstacleRawModelTrafficArrow = 11,
  kObstacleRawModelYieldMark = 12,
  kObstacleRawModelTrafficCone = 13,
  kObstacleRawModelBarrel = 14,
  kObstacleRawModelSpeedMark = 15,
  kObstacleRawModelCyclist = 16,
  kObstacleRawModelParkingLock = 17,
  kObstacleRawModelSpeedCamera = 18,
  kObstacleRawModelTrafficLightLens = 19,
  kObstacleRawModelParkingSlot = 22,
  kObstacleRawModelFace = 34,
  kObstacleRawModelVehiclePlat = 35,
  kObstacleRawModelLaneCrossPoints = 37,
  kObstacleRawModelVerticalPolePoints = 38,
  kObstacleRawModelTollgate = 39,
  kObstacleRawModelParkingLockClose = 40,
  kObstacleRawModelParkingLockOpen = 41,
  kObstacleRawModelParkingColumn = 42,
  kObstacleRawModelParkingAFrameSign = 43,
  kObstacleRawModelTrafficBollard = 44,
  kObstacleRawModelParkingObstacles = 45,
  kObstacleRawModelHpp = 46,
  ObstacleRawModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObstacleRawModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObstacleRawModelType_IsValid(int value);
const ObstacleRawModelType ObstacleRawModelType_MIN = kObstacleRawModelCar;
const ObstacleRawModelType ObstacleRawModelType_MAX = kObstacleRawModelHpp;
const int ObstacleRawModelType_ARRAYSIZE = ObstacleRawModelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObstacleRawModelType_descriptor();
inline const ::std::string& ObstacleRawModelType_Name(ObstacleRawModelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObstacleRawModelType_descriptor(), value);
}
inline bool ObstacleRawModelType_Parse(
    const ::std::string& name, ObstacleRawModelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstacleRawModelType>(
    ObstacleRawModelType_descriptor(), name, value);
}
enum Global2peResultType {
  kGlobal2PeResultTypeWeather = 0,
  kGlobal2PeResultTypeLight = 1,
  kGlobal2PeResultTypeScene = 2,
  kGlobal2PeResultTypeTime = 3,
  kGlobal2PeResultTypeVanishPoint = 4,
  kGlobal2PeResultTypePosenet = 5,
  kGlobal2PeResultTypeBlockcls = 6,
  kGlobal2PeResultTypeBlurcls = 7,
  kGlobal2PeResultTypeGlarecls = 8,
  kGlobal2PeResultTypePrFromDepth = 9,
  Global2peResultType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Global2peResultType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Global2peResultType_IsValid(int value);
const Global2peResultType Global2peResultType_MIN = kGlobal2PeResultTypeWeather;
const Global2peResultType Global2peResultType_MAX = kGlobal2PeResultTypePrFromDepth;
const int Global2peResultType_ARRAYSIZE = Global2peResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Global2peResultType_descriptor();
inline const ::std::string& Global2peResultType_Name(Global2peResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Global2peResultType_descriptor(), value);
}
inline bool Global2peResultType_Parse(
    const ::std::string& name, Global2peResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Global2peResultType>(
    Global2peResultType_descriptor(), name, value);
}
enum KeyPointType {
  kColumnKps = 0,
  kSmallSodKps = 1,
  kWheelKps = 2,
  KeyPointType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  KeyPointType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool KeyPointType_IsValid(int value);
const KeyPointType KeyPointType_MIN = kColumnKps;
const KeyPointType KeyPointType_MAX = kWheelKps;
const int KeyPointType_ARRAYSIZE = KeyPointType_MAX + 1;

const ::google::protobuf::EnumDescriptor* KeyPointType_descriptor();
inline const ::std::string& KeyPointType_Name(KeyPointType value) {
  return ::google::protobuf::internal::NameOfEnum(
    KeyPointType_descriptor(), value);
}
inline bool KeyPointType_Parse(
    const ::std::string& name, KeyPointType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KeyPointType>(
    KeyPointType_descriptor(), name, value);
}
// ===================================================================

class PropertyPerceptionBBox : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.PropertyPerceptionBBox) */ {
 public:
  PropertyPerceptionBBox();
  virtual ~PropertyPerceptionBBox();

  PropertyPerceptionBBox(const PropertyPerceptionBBox& from);

  inline PropertyPerceptionBBox& operator=(const PropertyPerceptionBBox& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PropertyPerceptionBBox(PropertyPerceptionBBox&& from) noexcept
    : PropertyPerceptionBBox() {
    *this = ::std::move(from);
  }

  inline PropertyPerceptionBBox& operator=(PropertyPerceptionBBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PropertyPerceptionBBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropertyPerceptionBBox* internal_default_instance() {
    return reinterpret_cast<const PropertyPerceptionBBox*>(
               &_PropertyPerceptionBBox_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PropertyPerceptionBBox* other);
  friend void swap(PropertyPerceptionBBox& a, PropertyPerceptionBBox& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PropertyPerceptionBBox* New() const PROTOBUF_FINAL { return New(NULL); }

  PropertyPerceptionBBox* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PropertyPerceptionBBox& from);
  void MergeFrom(const PropertyPerceptionBBox& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PropertyPerceptionBBox* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.perception_base.Category category = 4;
  int category_size() const;
  void clear_category();
  static const int kCategoryFieldNumber = 4;
  const ::autodrive::workflow::proto::perception_base::Category& category(int index) const;
  ::autodrive::workflow::proto::perception_base::Category* mutable_category(int index);
  ::autodrive::workflow::proto::perception_base::Category* add_category();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >*
      mutable_category();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >&
      category() const;

  // .autodrive.workflow.proto.perception_base.Rect rect = 1;
  bool has_rect() const;
  void clear_rect();
  static const int kRectFieldNumber = 1;
  const ::autodrive::workflow::proto::perception_base::Rect& rect() const;
  ::autodrive::workflow::proto::perception_base::Rect* release_rect();
  ::autodrive::workflow::proto::perception_base::Rect* mutable_rect();
  void set_allocated_rect(::autodrive::workflow::proto::perception_base::Rect* rect);

  // float conf = 2;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // int32 type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.PropertyPerceptionBBox)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category > category_;
  ::autodrive::workflow::proto::perception_base::Rect* rect_;
  float conf_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  friend struct ::protobuf_obstacle_5fraw_2eproto::TableStruct;
  friend void ::protobuf_obstacle_5fraw_2eproto::InitDefaultsPropertyPerceptionBBoxImpl();
};
// -------------------------------------------------------------------

class ObstacleRawKeyPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ObstacleRawKeyPoint) */ {
 public:
  ObstacleRawKeyPoint();
  virtual ~ObstacleRawKeyPoint();

  ObstacleRawKeyPoint(const ObstacleRawKeyPoint& from);

  inline ObstacleRawKeyPoint& operator=(const ObstacleRawKeyPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleRawKeyPoint(ObstacleRawKeyPoint&& from) noexcept
    : ObstacleRawKeyPoint() {
    *this = ::std::move(from);
  }

  inline ObstacleRawKeyPoint& operator=(ObstacleRawKeyPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleRawKeyPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleRawKeyPoint* internal_default_instance() {
    return reinterpret_cast<const ObstacleRawKeyPoint*>(
               &_ObstacleRawKeyPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ObstacleRawKeyPoint* other);
  friend void swap(ObstacleRawKeyPoint& a, ObstacleRawKeyPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleRawKeyPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstacleRawKeyPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstacleRawKeyPoint& from);
  void MergeFrom(const ObstacleRawKeyPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstacleRawKeyPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.Vector3f pt = 1;
  bool has_pt() const;
  void clear_pt();
  static const int kPtFieldNumber = 1;
  const ::autodrive::workflow::proto::Vector3f& pt() const;
  ::autodrive::workflow::proto::Vector3f* release_pt();
  ::autodrive::workflow::proto::Vector3f* mutable_pt();
  void set_allocated_pt(::autodrive::workflow::proto::Vector3f* pt);

  // float type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  float type() const;
  void set_type(float value);

  // float conf = 3;
  void clear_conf();
  static const int kConfFieldNumber = 3;
  float conf() const;
  void set_conf(float value);

  // float boundary_conf_x = 4;
  void clear_boundary_conf_x();
  static const int kBoundaryConfXFieldNumber = 4;
  float boundary_conf_x() const;
  void set_boundary_conf_x(float value);

  // float boundary_conf_y = 5;
  void clear_boundary_conf_y();
  static const int kBoundaryConfYFieldNumber = 5;
  float boundary_conf_y() const;
  void set_boundary_conf_y(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ObstacleRawKeyPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::Vector3f* pt_;
  float type_;
  float conf_;
  float boundary_conf_x_;
  float boundary_conf_y_;
  mutable int _cached_size_;
  friend struct ::protobuf_obstacle_5fraw_2eproto::TableStruct;
  friend void ::protobuf_obstacle_5fraw_2eproto::InitDefaultsObstacleRawKeyPointImpl();
};
// -------------------------------------------------------------------

class TrackingFeatureRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.TrackingFeatureRaw) */ {
 public:
  TrackingFeatureRaw();
  virtual ~TrackingFeatureRaw();

  TrackingFeatureRaw(const TrackingFeatureRaw& from);

  inline TrackingFeatureRaw& operator=(const TrackingFeatureRaw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrackingFeatureRaw(TrackingFeatureRaw&& from) noexcept
    : TrackingFeatureRaw() {
    *this = ::std::move(from);
  }

  inline TrackingFeatureRaw& operator=(TrackingFeatureRaw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackingFeatureRaw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrackingFeatureRaw* internal_default_instance() {
    return reinterpret_cast<const TrackingFeatureRaw*>(
               &_TrackingFeatureRaw_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TrackingFeatureRaw* other);
  friend void swap(TrackingFeatureRaw& a, TrackingFeatureRaw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrackingFeatureRaw* New() const PROTOBUF_FINAL { return New(NULL); }

  TrackingFeatureRaw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrackingFeatureRaw& from);
  void MergeFrom(const TrackingFeatureRaw& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrackingFeatureRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  ::google::protobuf::int32 data(int index) const;
  void set_data(int index, ::google::protobuf::int32 value);
  void add_data(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      data() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_data();

  // int32 model_id = 1;
  void clear_model_id();
  static const int kModelIdFieldNumber = 1;
  ::google::protobuf::int32 model_id() const;
  void set_model_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.TrackingFeatureRaw)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::int32 model_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_obstacle_5fraw_2eproto::TableStruct;
  friend void ::protobuf_obstacle_5fraw_2eproto::InitDefaultsTrackingFeatureRawImpl();
};
// -------------------------------------------------------------------

class PoseNetRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.PoseNetRaw) */ {
 public:
  PoseNetRaw();
  virtual ~PoseNetRaw();

  PoseNetRaw(const PoseNetRaw& from);

  inline PoseNetRaw& operator=(const PoseNetRaw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoseNetRaw(PoseNetRaw&& from) noexcept
    : PoseNetRaw() {
    *this = ::std::move(from);
  }

  inline PoseNetRaw& operator=(PoseNetRaw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PoseNetRaw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoseNetRaw* internal_default_instance() {
    return reinterpret_cast<const PoseNetRaw*>(
               &_PoseNetRaw_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(PoseNetRaw* other);
  friend void swap(PoseNetRaw& a, PoseNetRaw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoseNetRaw* New() const PROTOBUF_FINAL { return New(NULL); }

  PoseNetRaw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PoseNetRaw& from);
  void MergeFrom(const PoseNetRaw& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PoseNetRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float roll_raw = 1;
  void clear_roll_raw();
  static const int kRollRawFieldNumber = 1;
  float roll_raw() const;
  void set_roll_raw(float value);

  // float roll_filter = 2;
  void clear_roll_filter();
  static const int kRollFilterFieldNumber = 2;
  float roll_filter() const;
  void set_roll_filter(float value);

  // float pitch_raw = 3;
  void clear_pitch_raw();
  static const int kPitchRawFieldNumber = 3;
  float pitch_raw() const;
  void set_pitch_raw(float value);

  // float pitch_filter = 4;
  void clear_pitch_filter();
  static const int kPitchFilterFieldNumber = 4;
  float pitch_filter() const;
  void set_pitch_filter(float value);

  // float yaw_raw = 5;
  void clear_yaw_raw();
  static const int kYawRawFieldNumber = 5;
  float yaw_raw() const;
  void set_yaw_raw(float value);

  // float yaw_filter = 6;
  void clear_yaw_filter();
  static const int kYawFilterFieldNumber = 6;
  float yaw_filter() const;
  void set_yaw_filter(float value);

  // int32 type = 7;
  void clear_type();
  static const int kTypeFieldNumber = 7;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // float conf = 8;
  void clear_conf();
  static const int kConfFieldNumber = 8;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.PoseNetRaw)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float roll_raw_;
  float roll_filter_;
  float pitch_raw_;
  float pitch_filter_;
  float yaw_raw_;
  float yaw_filter_;
  ::google::protobuf::int32 type_;
  float conf_;
  mutable int _cached_size_;
  friend struct ::protobuf_obstacle_5fraw_2eproto::TableStruct;
  friend void ::protobuf_obstacle_5fraw_2eproto::InitDefaultsPoseNetRawImpl();
};
// -------------------------------------------------------------------

class KpsClsRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.KpsClsRaw) */ {
 public:
  KpsClsRaw();
  virtual ~KpsClsRaw();

  KpsClsRaw(const KpsClsRaw& from);

  inline KpsClsRaw& operator=(const KpsClsRaw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KpsClsRaw(KpsClsRaw&& from) noexcept
    : KpsClsRaw() {
    *this = ::std::move(from);
  }

  inline KpsClsRaw& operator=(KpsClsRaw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KpsClsRaw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KpsClsRaw* internal_default_instance() {
    return reinterpret_cast<const KpsClsRaw*>(
               &_KpsClsRaw_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(KpsClsRaw* other);
  friend void swap(KpsClsRaw& a, KpsClsRaw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KpsClsRaw* New() const PROTOBUF_FINAL { return New(NULL); }

  KpsClsRaw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KpsClsRaw& from);
  void MergeFrom(const KpsClsRaw& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KpsClsRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id = 1;
  int id_size() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id(int index) const;
  void set_id(int index, ::google::protobuf::int32 value);
  void add_id(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id();

  // repeated float conf = 2;
  int conf_size() const;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf(int index) const;
  void set_conf(int index, float value);
  void add_conf(float value);
  const ::google::protobuf::RepeatedField< float >&
      conf() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_conf();

  // repeated string name = 3;
  int name_size() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name(int index) const;
  ::std::string* mutable_name(int index);
  void set_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_name(int index, ::std::string&& value);
  #endif
  void set_name(int index, const char* value);
  void set_name(int index, const char* value, size_t size);
  ::std::string* add_name();
  void add_name(const ::std::string& value);
  #if LANG_CXX11
  void add_name(::std::string&& value);
  #endif
  void add_name(const char* value);
  void add_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // int32 type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.KpsClsRaw)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_;
  mutable int _id_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > conf_;
  mutable int _conf_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  friend struct ::protobuf_obstacle_5fraw_2eproto::TableStruct;
  friend void ::protobuf_obstacle_5fraw_2eproto::InitDefaultsKpsClsRawImpl();
};
// -------------------------------------------------------------------

class KeyPointsRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.KeyPointsRaw) */ {
 public:
  KeyPointsRaw();
  virtual ~KeyPointsRaw();

  KeyPointsRaw(const KeyPointsRaw& from);

  inline KeyPointsRaw& operator=(const KeyPointsRaw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyPointsRaw(KeyPointsRaw&& from) noexcept
    : KeyPointsRaw() {
    *this = ::std::move(from);
  }

  inline KeyPointsRaw& operator=(KeyPointsRaw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyPointsRaw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyPointsRaw* internal_default_instance() {
    return reinterpret_cast<const KeyPointsRaw*>(
               &_KeyPointsRaw_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(KeyPointsRaw* other);
  friend void swap(KeyPointsRaw& a, KeyPointsRaw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyPointsRaw* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyPointsRaw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyPointsRaw& from);
  void MergeFrom(const KeyPointsRaw& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyPointsRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.ObstacleRawKeyPoint key_points = 2;
  int key_points_size() const;
  void clear_key_points();
  static const int kKeyPointsFieldNumber = 2;
  const ::autodrive::workflow::proto::ObstacleRawKeyPoint& key_points(int index) const;
  ::autodrive::workflow::proto::ObstacleRawKeyPoint* mutable_key_points(int index);
  ::autodrive::workflow::proto::ObstacleRawKeyPoint* add_key_points();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >*
      mutable_key_points();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >&
      key_points() const;

  // int32 task_type = 1;
  void clear_task_type();
  static const int kTaskTypeFieldNumber = 1;
  ::google::protobuf::int32 task_type() const;
  void set_task_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.KeyPointsRaw)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint > key_points_;
  ::google::protobuf::int32 task_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_obstacle_5fraw_2eproto::TableStruct;
  friend void ::protobuf_obstacle_5fraw_2eproto::InitDefaultsKeyPointsRawImpl();
};
// -------------------------------------------------------------------

class PRFromGround : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.PRFromGround) */ {
 public:
  PRFromGround();
  virtual ~PRFromGround();

  PRFromGround(const PRFromGround& from);

  inline PRFromGround& operator=(const PRFromGround& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PRFromGround(PRFromGround&& from) noexcept
    : PRFromGround() {
    *this = ::std::move(from);
  }

  inline PRFromGround& operator=(PRFromGround&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PRFromGround& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PRFromGround* internal_default_instance() {
    return reinterpret_cast<const PRFromGround*>(
               &_PRFromGround_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(PRFromGround* other);
  friend void swap(PRFromGround& a, PRFromGround& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PRFromGround* New() const PROTOBUF_FINAL { return New(NULL); }

  PRFromGround* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PRFromGround& from);
  void MergeFrom(const PRFromGround& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PRFromGround* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float roll = 1;
  void clear_roll();
  static const int kRollFieldNumber = 1;
  float roll() const;
  void set_roll(float value);

  // float pitch = 2;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  float pitch() const;
  void set_pitch(float value);

  // .autodrive.workflow.proto.Global2peResultType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::autodrive::workflow::proto::Global2peResultType type() const;
  void set_type(::autodrive::workflow::proto::Global2peResultType value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.PRFromGround)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float roll_;
  float pitch_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_obstacle_5fraw_2eproto::TableStruct;
  friend void ::protobuf_obstacle_5fraw_2eproto::InitDefaultsPRFromGroundImpl();
};
// -------------------------------------------------------------------

class KeyPointsRawData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.KeyPointsRawData) */ {
 public:
  KeyPointsRawData();
  virtual ~KeyPointsRawData();

  KeyPointsRawData(const KeyPointsRawData& from);

  inline KeyPointsRawData& operator=(const KeyPointsRawData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyPointsRawData(KeyPointsRawData&& from) noexcept
    : KeyPointsRawData() {
    *this = ::std::move(from);
  }

  inline KeyPointsRawData& operator=(KeyPointsRawData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyPointsRawData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyPointsRawData* internal_default_instance() {
    return reinterpret_cast<const KeyPointsRawData*>(
               &_KeyPointsRawData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(KeyPointsRawData* other);
  friend void swap(KeyPointsRawData& a, KeyPointsRawData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyPointsRawData* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyPointsRawData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyPointsRawData& from);
  void MergeFrom(const KeyPointsRawData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyPointsRawData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.ObstacleRawKeyPoint key_points = 2;
  int key_points_size() const;
  void clear_key_points();
  static const int kKeyPointsFieldNumber = 2;
  const ::autodrive::workflow::proto::ObstacleRawKeyPoint& key_points(int index) const;
  ::autodrive::workflow::proto::ObstacleRawKeyPoint* mutable_key_points(int index);
  ::autodrive::workflow::proto::ObstacleRawKeyPoint* add_key_points();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >*
      mutable_key_points();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >&
      key_points() const;

  // .autodrive.workflow.proto.KeyPointType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::autodrive::workflow::proto::KeyPointType type() const;
  void set_type(::autodrive::workflow::proto::KeyPointType value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.KeyPointsRawData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint > key_points_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_obstacle_5fraw_2eproto::TableStruct;
  friend void ::protobuf_obstacle_5fraw_2eproto::InitDefaultsKeyPointsRawDataImpl();
};
// -------------------------------------------------------------------

class ObstacleRaw : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ObstacleRaw) */ {
 public:
  ObstacleRaw();
  virtual ~ObstacleRaw();

  ObstacleRaw(const ObstacleRaw& from);

  inline ObstacleRaw& operator=(const ObstacleRaw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleRaw(ObstacleRaw&& from) noexcept
    : ObstacleRaw() {
    *this = ::std::move(from);
  }

  inline ObstacleRaw& operator=(ObstacleRaw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleRaw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleRaw* internal_default_instance() {
    return reinterpret_cast<const ObstacleRaw*>(
               &_ObstacleRaw_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ObstacleRaw* other);
  friend void swap(ObstacleRaw& a, ObstacleRaw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleRaw* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstacleRaw* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstacleRaw& from);
  void MergeFrom(const ObstacleRaw& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstacleRaw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.perception_base.Category category = 5;
  int category_size() const;
  void clear_category();
  static const int kCategoryFieldNumber = 5;
  const ::autodrive::workflow::proto::perception_base::Category& category(int index) const;
  ::autodrive::workflow::proto::perception_base::Category* mutable_category(int index);
  ::autodrive::workflow::proto::perception_base::Category* add_category();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >*
      mutable_category();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >&
      category() const;

  // repeated .autodrive.workflow.proto.PropertyPerceptionBBox property_bbox = 6;
  int property_bbox_size() const;
  void clear_property_bbox();
  static const int kPropertyBboxFieldNumber = 6;
  const ::autodrive::workflow::proto::PropertyPerceptionBBox& property_bbox(int index) const;
  ::autodrive::workflow::proto::PropertyPerceptionBBox* mutable_property_bbox(int index);
  ::autodrive::workflow::proto::PropertyPerceptionBBox* add_property_bbox();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::PropertyPerceptionBBox >*
      mutable_property_bbox();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::PropertyPerceptionBBox >&
      property_bbox() const;

  // repeated .autodrive.workflow.proto.ObstacleRawKeyPoint key_points = 7;
  int key_points_size() const;
  void clear_key_points();
  static const int kKeyPointsFieldNumber = 7;
  const ::autodrive::workflow::proto::ObstacleRawKeyPoint& key_points(int index) const;
  ::autodrive::workflow::proto::ObstacleRawKeyPoint* mutable_key_points(int index);
  ::autodrive::workflow::proto::ObstacleRawKeyPoint* add_key_points();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >*
      mutable_key_points();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >&
      key_points() const;

  // .autodrive.workflow.proto.perception_base.Rect rect = 1;
  bool has_rect() const;
  void clear_rect();
  static const int kRectFieldNumber = 1;
  const ::autodrive::workflow::proto::perception_base::Rect& rect() const;
  ::autodrive::workflow::proto::perception_base::Rect* release_rect();
  ::autodrive::workflow::proto::perception_base::Rect* mutable_rect();
  void set_allocated_rect(::autodrive::workflow::proto::perception_base::Rect* rect);

  // .autodrive.workflow.proto.perception_base.Rect input_roi = 10;
  bool has_input_roi() const;
  void clear_input_roi();
  static const int kInputRoiFieldNumber = 10;
  const ::autodrive::workflow::proto::perception_base::Rect& input_roi() const;
  ::autodrive::workflow::proto::perception_base::Rect* release_input_roi();
  ::autodrive::workflow::proto::perception_base::Rect* mutable_input_roi();
  void set_allocated_input_roi(::autodrive::workflow::proto::perception_base::Rect* input_roi);

  // float conf = 2;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // int32 model = 3;
  void clear_model();
  static const int kModelFieldNumber = 3;
  ::google::protobuf::int32 model() const;
  void set_model(::google::protobuf::int32 value);

  // int32 source = 4;
  void clear_source();
  static const int kSourceFieldNumber = 4;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // float depth = 8;
  void clear_depth();
  static const int kDepthFieldNumber = 8;
  float depth() const;
  void set_depth(float value);

  // int32 expand = 9;
  void clear_expand();
  static const int kExpandFieldNumber = 9;
  ::google::protobuf::int32 expand() const;
  void set_expand(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ObstacleRaw)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category > category_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::PropertyPerceptionBBox > property_bbox_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint > key_points_;
  ::autodrive::workflow::proto::perception_base::Rect* rect_;
  ::autodrive::workflow::proto::perception_base::Rect* input_roi_;
  float conf_;
  ::google::protobuf::int32 model_;
  ::google::protobuf::int32 source_;
  float depth_;
  ::google::protobuf::int32 expand_;
  mutable int _cached_size_;
  friend struct ::protobuf_obstacle_5fraw_2eproto::TableStruct;
  friend void ::protobuf_obstacle_5fraw_2eproto::InitDefaultsObstacleRawImpl();
};
// -------------------------------------------------------------------

class ObstacleRawsData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ObstacleRawsData) */ {
 public:
  ObstacleRawsData();
  virtual ~ObstacleRawsData();

  ObstacleRawsData(const ObstacleRawsData& from);

  inline ObstacleRawsData& operator=(const ObstacleRawsData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleRawsData(ObstacleRawsData&& from) noexcept
    : ObstacleRawsData() {
    *this = ::std::move(from);
  }

  inline ObstacleRawsData& operator=(ObstacleRawsData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleRawsData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleRawsData* internal_default_instance() {
    return reinterpret_cast<const ObstacleRawsData*>(
               &_ObstacleRawsData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ObstacleRawsData* other);
  friend void swap(ObstacleRawsData& a, ObstacleRawsData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleRawsData* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstacleRawsData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstacleRawsData& from);
  void MergeFrom(const ObstacleRawsData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstacleRawsData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.KeyPointsRawData key_points_raws = 4;
  int key_points_raws_size() const;
  void clear_key_points_raws();
  static const int kKeyPointsRawsFieldNumber = 4;
  const ::autodrive::workflow::proto::KeyPointsRawData& key_points_raws(int index) const;
  ::autodrive::workflow::proto::KeyPointsRawData* mutable_key_points_raws(int index);
  ::autodrive::workflow::proto::KeyPointsRawData* add_key_points_raws();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::KeyPointsRawData >*
      mutable_key_points_raws();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::KeyPointsRawData >&
      key_points_raws() const;

  // repeated .autodrive.workflow.proto.ObstacleRaw obstacle_raws = 5;
  int obstacle_raws_size() const;
  void clear_obstacle_raws();
  static const int kObstacleRawsFieldNumber = 5;
  const ::autodrive::workflow::proto::ObstacleRaw& obstacle_raws(int index) const;
  ::autodrive::workflow::proto::ObstacleRaw* mutable_obstacle_raws(int index);
  ::autodrive::workflow::proto::ObstacleRaw* add_obstacle_raws();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRaw >*
      mutable_obstacle_raws();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRaw >&
      obstacle_raws() const;

  // .autodrive.workflow.proto.perception_base.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::perception_base::Header& header() const;
  ::autodrive::workflow::proto::perception_base::Header* release_header();
  ::autodrive::workflow::proto::perception_base::Header* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::perception_base::Header* header);

  // .autodrive.workflow.proto.perception_base.Category category = 2;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 2;
  const ::autodrive::workflow::proto::perception_base::Category& category() const;
  ::autodrive::workflow::proto::perception_base::Category* release_category();
  ::autodrive::workflow::proto::perception_base::Category* mutable_category();
  void set_allocated_category(::autodrive::workflow::proto::perception_base::Category* category);

  // float conf_scale = 3;
  void clear_conf_scale();
  static const int kConfScaleFieldNumber = 3;
  float conf_scale() const;
  void set_conf_scale(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ObstacleRawsData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::KeyPointsRawData > key_points_raws_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRaw > obstacle_raws_;
  ::autodrive::workflow::proto::perception_base::Header* header_;
  ::autodrive::workflow::proto::perception_base::Category* category_;
  float conf_scale_;
  mutable int _cached_size_;
  friend struct ::protobuf_obstacle_5fraw_2eproto::TableStruct;
  friend void ::protobuf_obstacle_5fraw_2eproto::InitDefaultsObstacleRawsDataImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PropertyPerceptionBBox

// .autodrive.workflow.proto.perception_base.Rect rect = 1;
inline bool PropertyPerceptionBBox::has_rect() const {
  return this != internal_default_instance() && rect_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Rect& PropertyPerceptionBBox::rect() const {
  const ::autodrive::workflow::proto::perception_base::Rect* p = rect_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PropertyPerceptionBBox.rect)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Rect*>(
      &::autodrive::workflow::proto::perception_base::_Rect_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Rect* PropertyPerceptionBBox::release_rect() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.PropertyPerceptionBBox.rect)
  
  ::autodrive::workflow::proto::perception_base::Rect* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Rect* PropertyPerceptionBBox::mutable_rect() {
  
  if (rect_ == NULL) {
    rect_ = new ::autodrive::workflow::proto::perception_base::Rect;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.PropertyPerceptionBBox.rect)
  return rect_;
}
inline void PropertyPerceptionBBox::set_allocated_rect(::autodrive::workflow::proto::perception_base::Rect* rect) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rect_);
  }
  if (rect) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rect = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rect, submessage_arena);
    }
    
  } else {
    
  }
  rect_ = rect;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.PropertyPerceptionBBox.rect)
}

// float conf = 2;
inline void PropertyPerceptionBBox::clear_conf() {
  conf_ = 0;
}
inline float PropertyPerceptionBBox::conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PropertyPerceptionBBox.conf)
  return conf_;
}
inline void PropertyPerceptionBBox::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PropertyPerceptionBBox.conf)
}

// int32 type = 3;
inline void PropertyPerceptionBBox::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 PropertyPerceptionBBox::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PropertyPerceptionBBox.type)
  return type_;
}
inline void PropertyPerceptionBBox::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PropertyPerceptionBBox.type)
}

// repeated .autodrive.workflow.proto.perception_base.Category category = 4;
inline int PropertyPerceptionBBox::category_size() const {
  return category_.size();
}
inline const ::autodrive::workflow::proto::perception_base::Category& PropertyPerceptionBBox::category(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PropertyPerceptionBBox.category)
  return category_.Get(index);
}
inline ::autodrive::workflow::proto::perception_base::Category* PropertyPerceptionBBox::mutable_category(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.PropertyPerceptionBBox.category)
  return category_.Mutable(index);
}
inline ::autodrive::workflow::proto::perception_base::Category* PropertyPerceptionBBox::add_category() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.PropertyPerceptionBBox.category)
  return category_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >*
PropertyPerceptionBBox::mutable_category() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.PropertyPerceptionBBox.category)
  return &category_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >&
PropertyPerceptionBBox::category() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.PropertyPerceptionBBox.category)
  return category_;
}

// -------------------------------------------------------------------

// ObstacleRawKeyPoint

// .autodrive.workflow.proto.Vector3f pt = 1;
inline bool ObstacleRawKeyPoint::has_pt() const {
  return this != internal_default_instance() && pt_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& ObstacleRawKeyPoint::pt() const {
  const ::autodrive::workflow::proto::Vector3f* p = pt_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRawKeyPoint.pt)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* ObstacleRawKeyPoint::release_pt() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ObstacleRawKeyPoint.pt)
  
  ::autodrive::workflow::proto::Vector3f* temp = pt_;
  pt_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* ObstacleRawKeyPoint::mutable_pt() {
  
  if (pt_ == NULL) {
    pt_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ObstacleRawKeyPoint.pt)
  return pt_;
}
inline void ObstacleRawKeyPoint::set_allocated_pt(::autodrive::workflow::proto::Vector3f* pt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pt_);
  }
  if (pt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pt, submessage_arena);
    }
    
  } else {
    
  }
  pt_ = pt;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ObstacleRawKeyPoint.pt)
}

// float type = 2;
inline void ObstacleRawKeyPoint::clear_type() {
  type_ = 0;
}
inline float ObstacleRawKeyPoint::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRawKeyPoint.type)
  return type_;
}
inline void ObstacleRawKeyPoint::set_type(float value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleRawKeyPoint.type)
}

// float conf = 3;
inline void ObstacleRawKeyPoint::clear_conf() {
  conf_ = 0;
}
inline float ObstacleRawKeyPoint::conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRawKeyPoint.conf)
  return conf_;
}
inline void ObstacleRawKeyPoint::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleRawKeyPoint.conf)
}

// float boundary_conf_x = 4;
inline void ObstacleRawKeyPoint::clear_boundary_conf_x() {
  boundary_conf_x_ = 0;
}
inline float ObstacleRawKeyPoint::boundary_conf_x() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRawKeyPoint.boundary_conf_x)
  return boundary_conf_x_;
}
inline void ObstacleRawKeyPoint::set_boundary_conf_x(float value) {
  
  boundary_conf_x_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleRawKeyPoint.boundary_conf_x)
}

// float boundary_conf_y = 5;
inline void ObstacleRawKeyPoint::clear_boundary_conf_y() {
  boundary_conf_y_ = 0;
}
inline float ObstacleRawKeyPoint::boundary_conf_y() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRawKeyPoint.boundary_conf_y)
  return boundary_conf_y_;
}
inline void ObstacleRawKeyPoint::set_boundary_conf_y(float value) {
  
  boundary_conf_y_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleRawKeyPoint.boundary_conf_y)
}

// -------------------------------------------------------------------

// TrackingFeatureRaw

// int32 model_id = 1;
inline void TrackingFeatureRaw::clear_model_id() {
  model_id_ = 0;
}
inline ::google::protobuf::int32 TrackingFeatureRaw::model_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.TrackingFeatureRaw.model_id)
  return model_id_;
}
inline void TrackingFeatureRaw::set_model_id(::google::protobuf::int32 value) {
  
  model_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.TrackingFeatureRaw.model_id)
}

// repeated int32 data = 2;
inline int TrackingFeatureRaw::data_size() const {
  return data_.size();
}
inline void TrackingFeatureRaw::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::int32 TrackingFeatureRaw::data(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.TrackingFeatureRaw.data)
  return data_.Get(index);
}
inline void TrackingFeatureRaw::set_data(int index, ::google::protobuf::int32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.TrackingFeatureRaw.data)
}
inline void TrackingFeatureRaw::add_data(::google::protobuf::int32 value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.TrackingFeatureRaw.data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TrackingFeatureRaw::data() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.TrackingFeatureRaw.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TrackingFeatureRaw::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.TrackingFeatureRaw.data)
  return &data_;
}

// -------------------------------------------------------------------

// PoseNetRaw

// float roll_raw = 1;
inline void PoseNetRaw::clear_roll_raw() {
  roll_raw_ = 0;
}
inline float PoseNetRaw::roll_raw() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PoseNetRaw.roll_raw)
  return roll_raw_;
}
inline void PoseNetRaw::set_roll_raw(float value) {
  
  roll_raw_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PoseNetRaw.roll_raw)
}

// float roll_filter = 2;
inline void PoseNetRaw::clear_roll_filter() {
  roll_filter_ = 0;
}
inline float PoseNetRaw::roll_filter() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PoseNetRaw.roll_filter)
  return roll_filter_;
}
inline void PoseNetRaw::set_roll_filter(float value) {
  
  roll_filter_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PoseNetRaw.roll_filter)
}

// float pitch_raw = 3;
inline void PoseNetRaw::clear_pitch_raw() {
  pitch_raw_ = 0;
}
inline float PoseNetRaw::pitch_raw() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PoseNetRaw.pitch_raw)
  return pitch_raw_;
}
inline void PoseNetRaw::set_pitch_raw(float value) {
  
  pitch_raw_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PoseNetRaw.pitch_raw)
}

// float pitch_filter = 4;
inline void PoseNetRaw::clear_pitch_filter() {
  pitch_filter_ = 0;
}
inline float PoseNetRaw::pitch_filter() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PoseNetRaw.pitch_filter)
  return pitch_filter_;
}
inline void PoseNetRaw::set_pitch_filter(float value) {
  
  pitch_filter_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PoseNetRaw.pitch_filter)
}

// float yaw_raw = 5;
inline void PoseNetRaw::clear_yaw_raw() {
  yaw_raw_ = 0;
}
inline float PoseNetRaw::yaw_raw() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PoseNetRaw.yaw_raw)
  return yaw_raw_;
}
inline void PoseNetRaw::set_yaw_raw(float value) {
  
  yaw_raw_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PoseNetRaw.yaw_raw)
}

// float yaw_filter = 6;
inline void PoseNetRaw::clear_yaw_filter() {
  yaw_filter_ = 0;
}
inline float PoseNetRaw::yaw_filter() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PoseNetRaw.yaw_filter)
  return yaw_filter_;
}
inline void PoseNetRaw::set_yaw_filter(float value) {
  
  yaw_filter_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PoseNetRaw.yaw_filter)
}

// int32 type = 7;
inline void PoseNetRaw::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 PoseNetRaw::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PoseNetRaw.type)
  return type_;
}
inline void PoseNetRaw::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PoseNetRaw.type)
}

// float conf = 8;
inline void PoseNetRaw::clear_conf() {
  conf_ = 0;
}
inline float PoseNetRaw::conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PoseNetRaw.conf)
  return conf_;
}
inline void PoseNetRaw::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PoseNetRaw.conf)
}

// -------------------------------------------------------------------

// KpsClsRaw

// repeated int32 id = 1;
inline int KpsClsRaw::id_size() const {
  return id_.size();
}
inline void KpsClsRaw::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int32 KpsClsRaw::id(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.KpsClsRaw.id)
  return id_.Get(index);
}
inline void KpsClsRaw::set_id(int index, ::google::protobuf::int32 value) {
  id_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.KpsClsRaw.id)
}
inline void KpsClsRaw::add_id(::google::protobuf::int32 value) {
  id_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.KpsClsRaw.id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
KpsClsRaw::id() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.KpsClsRaw.id)
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
KpsClsRaw::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.KpsClsRaw.id)
  return &id_;
}

// repeated float conf = 2;
inline int KpsClsRaw::conf_size() const {
  return conf_.size();
}
inline void KpsClsRaw::clear_conf() {
  conf_.Clear();
}
inline float KpsClsRaw::conf(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.KpsClsRaw.conf)
  return conf_.Get(index);
}
inline void KpsClsRaw::set_conf(int index, float value) {
  conf_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.KpsClsRaw.conf)
}
inline void KpsClsRaw::add_conf(float value) {
  conf_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.KpsClsRaw.conf)
}
inline const ::google::protobuf::RepeatedField< float >&
KpsClsRaw::conf() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.KpsClsRaw.conf)
  return conf_;
}
inline ::google::protobuf::RepeatedField< float >*
KpsClsRaw::mutable_conf() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.KpsClsRaw.conf)
  return &conf_;
}

// repeated string name = 3;
inline int KpsClsRaw::name_size() const {
  return name_.size();
}
inline void KpsClsRaw::clear_name() {
  name_.Clear();
}
inline const ::std::string& KpsClsRaw::name(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.KpsClsRaw.name)
  return name_.Get(index);
}
inline ::std::string* KpsClsRaw::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.KpsClsRaw.name)
  return name_.Mutable(index);
}
inline void KpsClsRaw::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.KpsClsRaw.name)
  name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void KpsClsRaw::set_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.KpsClsRaw.name)
  name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void KpsClsRaw::set_name(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.KpsClsRaw.name)
}
inline void KpsClsRaw::set_name(int index, const char* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.KpsClsRaw.name)
}
inline ::std::string* KpsClsRaw::add_name() {
  // @@protoc_insertion_point(field_add_mutable:autodrive.workflow.proto.KpsClsRaw.name)
  return name_.Add();
}
inline void KpsClsRaw::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.KpsClsRaw.name)
}
#if LANG_CXX11
inline void KpsClsRaw::add_name(::std::string&& value) {
  name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.KpsClsRaw.name)
}
#endif
inline void KpsClsRaw::add_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:autodrive.workflow.proto.KpsClsRaw.name)
}
inline void KpsClsRaw::add_name(const char* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:autodrive.workflow.proto.KpsClsRaw.name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KpsClsRaw::name() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.KpsClsRaw.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KpsClsRaw::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.KpsClsRaw.name)
  return &name_;
}

// int32 type = 4;
inline void KpsClsRaw::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 KpsClsRaw::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.KpsClsRaw.type)
  return type_;
}
inline void KpsClsRaw::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.KpsClsRaw.type)
}

// -------------------------------------------------------------------

// KeyPointsRaw

// int32 task_type = 1;
inline void KeyPointsRaw::clear_task_type() {
  task_type_ = 0;
}
inline ::google::protobuf::int32 KeyPointsRaw::task_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.KeyPointsRaw.task_type)
  return task_type_;
}
inline void KeyPointsRaw::set_task_type(::google::protobuf::int32 value) {
  
  task_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.KeyPointsRaw.task_type)
}

// repeated .autodrive.workflow.proto.ObstacleRawKeyPoint key_points = 2;
inline int KeyPointsRaw::key_points_size() const {
  return key_points_.size();
}
inline void KeyPointsRaw::clear_key_points() {
  key_points_.Clear();
}
inline const ::autodrive::workflow::proto::ObstacleRawKeyPoint& KeyPointsRaw::key_points(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.KeyPointsRaw.key_points)
  return key_points_.Get(index);
}
inline ::autodrive::workflow::proto::ObstacleRawKeyPoint* KeyPointsRaw::mutable_key_points(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.KeyPointsRaw.key_points)
  return key_points_.Mutable(index);
}
inline ::autodrive::workflow::proto::ObstacleRawKeyPoint* KeyPointsRaw::add_key_points() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.KeyPointsRaw.key_points)
  return key_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >*
KeyPointsRaw::mutable_key_points() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.KeyPointsRaw.key_points)
  return &key_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >&
KeyPointsRaw::key_points() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.KeyPointsRaw.key_points)
  return key_points_;
}

// -------------------------------------------------------------------

// PRFromGround

// float roll = 1;
inline void PRFromGround::clear_roll() {
  roll_ = 0;
}
inline float PRFromGround::roll() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PRFromGround.roll)
  return roll_;
}
inline void PRFromGround::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PRFromGround.roll)
}

// float pitch = 2;
inline void PRFromGround::clear_pitch() {
  pitch_ = 0;
}
inline float PRFromGround::pitch() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PRFromGround.pitch)
  return pitch_;
}
inline void PRFromGround::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PRFromGround.pitch)
}

// .autodrive.workflow.proto.Global2peResultType type = 3;
inline void PRFromGround::clear_type() {
  type_ = 0;
}
inline ::autodrive::workflow::proto::Global2peResultType PRFromGround::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.PRFromGround.type)
  return static_cast< ::autodrive::workflow::proto::Global2peResultType >(type_);
}
inline void PRFromGround::set_type(::autodrive::workflow::proto::Global2peResultType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.PRFromGround.type)
}

// -------------------------------------------------------------------

// KeyPointsRawData

// .autodrive.workflow.proto.KeyPointType type = 1;
inline void KeyPointsRawData::clear_type() {
  type_ = 0;
}
inline ::autodrive::workflow::proto::KeyPointType KeyPointsRawData::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.KeyPointsRawData.type)
  return static_cast< ::autodrive::workflow::proto::KeyPointType >(type_);
}
inline void KeyPointsRawData::set_type(::autodrive::workflow::proto::KeyPointType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.KeyPointsRawData.type)
}

// repeated .autodrive.workflow.proto.ObstacleRawKeyPoint key_points = 2;
inline int KeyPointsRawData::key_points_size() const {
  return key_points_.size();
}
inline void KeyPointsRawData::clear_key_points() {
  key_points_.Clear();
}
inline const ::autodrive::workflow::proto::ObstacleRawKeyPoint& KeyPointsRawData::key_points(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.KeyPointsRawData.key_points)
  return key_points_.Get(index);
}
inline ::autodrive::workflow::proto::ObstacleRawKeyPoint* KeyPointsRawData::mutable_key_points(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.KeyPointsRawData.key_points)
  return key_points_.Mutable(index);
}
inline ::autodrive::workflow::proto::ObstacleRawKeyPoint* KeyPointsRawData::add_key_points() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.KeyPointsRawData.key_points)
  return key_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >*
KeyPointsRawData::mutable_key_points() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.KeyPointsRawData.key_points)
  return &key_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >&
KeyPointsRawData::key_points() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.KeyPointsRawData.key_points)
  return key_points_;
}

// -------------------------------------------------------------------

// ObstacleRaw

// .autodrive.workflow.proto.perception_base.Rect rect = 1;
inline bool ObstacleRaw::has_rect() const {
  return this != internal_default_instance() && rect_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Rect& ObstacleRaw::rect() const {
  const ::autodrive::workflow::proto::perception_base::Rect* p = rect_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRaw.rect)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Rect*>(
      &::autodrive::workflow::proto::perception_base::_Rect_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Rect* ObstacleRaw::release_rect() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ObstacleRaw.rect)
  
  ::autodrive::workflow::proto::perception_base::Rect* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Rect* ObstacleRaw::mutable_rect() {
  
  if (rect_ == NULL) {
    rect_ = new ::autodrive::workflow::proto::perception_base::Rect;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ObstacleRaw.rect)
  return rect_;
}
inline void ObstacleRaw::set_allocated_rect(::autodrive::workflow::proto::perception_base::Rect* rect) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rect_);
  }
  if (rect) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rect = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rect, submessage_arena);
    }
    
  } else {
    
  }
  rect_ = rect;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ObstacleRaw.rect)
}

// float conf = 2;
inline void ObstacleRaw::clear_conf() {
  conf_ = 0;
}
inline float ObstacleRaw::conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRaw.conf)
  return conf_;
}
inline void ObstacleRaw::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleRaw.conf)
}

// int32 model = 3;
inline void ObstacleRaw::clear_model() {
  model_ = 0;
}
inline ::google::protobuf::int32 ObstacleRaw::model() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRaw.model)
  return model_;
}
inline void ObstacleRaw::set_model(::google::protobuf::int32 value) {
  
  model_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleRaw.model)
}

// int32 source = 4;
inline void ObstacleRaw::clear_source() {
  source_ = 0;
}
inline ::google::protobuf::int32 ObstacleRaw::source() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRaw.source)
  return source_;
}
inline void ObstacleRaw::set_source(::google::protobuf::int32 value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleRaw.source)
}

// repeated .autodrive.workflow.proto.perception_base.Category category = 5;
inline int ObstacleRaw::category_size() const {
  return category_.size();
}
inline const ::autodrive::workflow::proto::perception_base::Category& ObstacleRaw::category(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRaw.category)
  return category_.Get(index);
}
inline ::autodrive::workflow::proto::perception_base::Category* ObstacleRaw::mutable_category(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ObstacleRaw.category)
  return category_.Mutable(index);
}
inline ::autodrive::workflow::proto::perception_base::Category* ObstacleRaw::add_category() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ObstacleRaw.category)
  return category_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >*
ObstacleRaw::mutable_category() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ObstacleRaw.category)
  return &category_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >&
ObstacleRaw::category() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ObstacleRaw.category)
  return category_;
}

// repeated .autodrive.workflow.proto.PropertyPerceptionBBox property_bbox = 6;
inline int ObstacleRaw::property_bbox_size() const {
  return property_bbox_.size();
}
inline void ObstacleRaw::clear_property_bbox() {
  property_bbox_.Clear();
}
inline const ::autodrive::workflow::proto::PropertyPerceptionBBox& ObstacleRaw::property_bbox(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRaw.property_bbox)
  return property_bbox_.Get(index);
}
inline ::autodrive::workflow::proto::PropertyPerceptionBBox* ObstacleRaw::mutable_property_bbox(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ObstacleRaw.property_bbox)
  return property_bbox_.Mutable(index);
}
inline ::autodrive::workflow::proto::PropertyPerceptionBBox* ObstacleRaw::add_property_bbox() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ObstacleRaw.property_bbox)
  return property_bbox_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::PropertyPerceptionBBox >*
ObstacleRaw::mutable_property_bbox() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ObstacleRaw.property_bbox)
  return &property_bbox_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::PropertyPerceptionBBox >&
ObstacleRaw::property_bbox() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ObstacleRaw.property_bbox)
  return property_bbox_;
}

// repeated .autodrive.workflow.proto.ObstacleRawKeyPoint key_points = 7;
inline int ObstacleRaw::key_points_size() const {
  return key_points_.size();
}
inline void ObstacleRaw::clear_key_points() {
  key_points_.Clear();
}
inline const ::autodrive::workflow::proto::ObstacleRawKeyPoint& ObstacleRaw::key_points(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRaw.key_points)
  return key_points_.Get(index);
}
inline ::autodrive::workflow::proto::ObstacleRawKeyPoint* ObstacleRaw::mutable_key_points(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ObstacleRaw.key_points)
  return key_points_.Mutable(index);
}
inline ::autodrive::workflow::proto::ObstacleRawKeyPoint* ObstacleRaw::add_key_points() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ObstacleRaw.key_points)
  return key_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >*
ObstacleRaw::mutable_key_points() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ObstacleRaw.key_points)
  return &key_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRawKeyPoint >&
ObstacleRaw::key_points() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ObstacleRaw.key_points)
  return key_points_;
}

// float depth = 8;
inline void ObstacleRaw::clear_depth() {
  depth_ = 0;
}
inline float ObstacleRaw::depth() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRaw.depth)
  return depth_;
}
inline void ObstacleRaw::set_depth(float value) {
  
  depth_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleRaw.depth)
}

// int32 expand = 9;
inline void ObstacleRaw::clear_expand() {
  expand_ = 0;
}
inline ::google::protobuf::int32 ObstacleRaw::expand() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRaw.expand)
  return expand_;
}
inline void ObstacleRaw::set_expand(::google::protobuf::int32 value) {
  
  expand_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleRaw.expand)
}

// .autodrive.workflow.proto.perception_base.Rect input_roi = 10;
inline bool ObstacleRaw::has_input_roi() const {
  return this != internal_default_instance() && input_roi_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Rect& ObstacleRaw::input_roi() const {
  const ::autodrive::workflow::proto::perception_base::Rect* p = input_roi_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRaw.input_roi)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Rect*>(
      &::autodrive::workflow::proto::perception_base::_Rect_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Rect* ObstacleRaw::release_input_roi() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ObstacleRaw.input_roi)
  
  ::autodrive::workflow::proto::perception_base::Rect* temp = input_roi_;
  input_roi_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Rect* ObstacleRaw::mutable_input_roi() {
  
  if (input_roi_ == NULL) {
    input_roi_ = new ::autodrive::workflow::proto::perception_base::Rect;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ObstacleRaw.input_roi)
  return input_roi_;
}
inline void ObstacleRaw::set_allocated_input_roi(::autodrive::workflow::proto::perception_base::Rect* input_roi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(input_roi_);
  }
  if (input_roi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input_roi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input_roi, submessage_arena);
    }
    
  } else {
    
  }
  input_roi_ = input_roi;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ObstacleRaw.input_roi)
}

// -------------------------------------------------------------------

// ObstacleRawsData

// .autodrive.workflow.proto.perception_base.Header header = 1;
inline bool ObstacleRawsData::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Header& ObstacleRawsData::header() const {
  const ::autodrive::workflow::proto::perception_base::Header* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRawsData.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Header*>(
      &::autodrive::workflow::proto::perception_base::_Header_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Header* ObstacleRawsData::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ObstacleRawsData.header)
  
  ::autodrive::workflow::proto::perception_base::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Header* ObstacleRawsData::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::perception_base::Header;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ObstacleRawsData.header)
  return header_;
}
inline void ObstacleRawsData::set_allocated_header(::autodrive::workflow::proto::perception_base::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ObstacleRawsData.header)
}

// .autodrive.workflow.proto.perception_base.Category category = 2;
inline bool ObstacleRawsData::has_category() const {
  return this != internal_default_instance() && category_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Category& ObstacleRawsData::category() const {
  const ::autodrive::workflow::proto::perception_base::Category* p = category_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRawsData.category)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Category*>(
      &::autodrive::workflow::proto::perception_base::_Category_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Category* ObstacleRawsData::release_category() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ObstacleRawsData.category)
  
  ::autodrive::workflow::proto::perception_base::Category* temp = category_;
  category_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Category* ObstacleRawsData::mutable_category() {
  
  if (category_ == NULL) {
    category_ = new ::autodrive::workflow::proto::perception_base::Category;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ObstacleRawsData.category)
  return category_;
}
inline void ObstacleRawsData::set_allocated_category(::autodrive::workflow::proto::perception_base::Category* category) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(category_);
  }
  if (category) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      category = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, category, submessage_arena);
    }
    
  } else {
    
  }
  category_ = category;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ObstacleRawsData.category)
}

// float conf_scale = 3;
inline void ObstacleRawsData::clear_conf_scale() {
  conf_scale_ = 0;
}
inline float ObstacleRawsData::conf_scale() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRawsData.conf_scale)
  return conf_scale_;
}
inline void ObstacleRawsData::set_conf_scale(float value) {
  
  conf_scale_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ObstacleRawsData.conf_scale)
}

// repeated .autodrive.workflow.proto.KeyPointsRawData key_points_raws = 4;
inline int ObstacleRawsData::key_points_raws_size() const {
  return key_points_raws_.size();
}
inline void ObstacleRawsData::clear_key_points_raws() {
  key_points_raws_.Clear();
}
inline const ::autodrive::workflow::proto::KeyPointsRawData& ObstacleRawsData::key_points_raws(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRawsData.key_points_raws)
  return key_points_raws_.Get(index);
}
inline ::autodrive::workflow::proto::KeyPointsRawData* ObstacleRawsData::mutable_key_points_raws(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ObstacleRawsData.key_points_raws)
  return key_points_raws_.Mutable(index);
}
inline ::autodrive::workflow::proto::KeyPointsRawData* ObstacleRawsData::add_key_points_raws() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ObstacleRawsData.key_points_raws)
  return key_points_raws_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::KeyPointsRawData >*
ObstacleRawsData::mutable_key_points_raws() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ObstacleRawsData.key_points_raws)
  return &key_points_raws_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::KeyPointsRawData >&
ObstacleRawsData::key_points_raws() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ObstacleRawsData.key_points_raws)
  return key_points_raws_;
}

// repeated .autodrive.workflow.proto.ObstacleRaw obstacle_raws = 5;
inline int ObstacleRawsData::obstacle_raws_size() const {
  return obstacle_raws_.size();
}
inline void ObstacleRawsData::clear_obstacle_raws() {
  obstacle_raws_.Clear();
}
inline const ::autodrive::workflow::proto::ObstacleRaw& ObstacleRawsData::obstacle_raws(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ObstacleRawsData.obstacle_raws)
  return obstacle_raws_.Get(index);
}
inline ::autodrive::workflow::proto::ObstacleRaw* ObstacleRawsData::mutable_obstacle_raws(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ObstacleRawsData.obstacle_raws)
  return obstacle_raws_.Mutable(index);
}
inline ::autodrive::workflow::proto::ObstacleRaw* ObstacleRawsData::add_obstacle_raws() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ObstacleRawsData.obstacle_raws)
  return obstacle_raws_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRaw >*
ObstacleRawsData::mutable_obstacle_raws() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ObstacleRawsData.obstacle_raws)
  return &obstacle_raws_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ObstacleRaw >&
ObstacleRawsData::obstacle_raws() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ObstacleRawsData.obstacle_raws)
  return obstacle_raws_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::VehPropertyPerceptionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::VehPropertyPerceptionType>() {
  return ::autodrive::workflow::proto::VehPropertyPerceptionType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ObstacleRawModelType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ObstacleRawModelType>() {
  return ::autodrive::workflow::proto::ObstacleRawModelType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::Global2peResultType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::Global2peResultType>() {
  return ::autodrive::workflow::proto::Global2peResultType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::KeyPointType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::KeyPointType>() {
  return ::autodrive::workflow::proto::KeyPointType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_obstacle_5fraw_2eproto__INCLUDED
