// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hmi_hpa_render.proto

#ifndef PROTOBUF_hmi_5fhpa_5frender_2eproto__INCLUDED
#define PROTOBUF_hmi_5fhpa_5frender_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "fusion_obstacle.pb.h"
#include "localization.pb.h"
#include "map_display.pb.h"
#include "vpa_state.pb.h"
#include "ndm_base.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_hmi_5fhpa_5frender_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHmiFusionObstacleImpl();
void InitDefaultsHmiFusionObstacle();
void InitDefaultsHmiLocalizationImpl();
void InitDefaultsHmiLocalization();
void InitDefaultsHmiGlbPrcpPrkgSlotsImpl();
void InitDefaultsHmiGlbPrcpPrkgSlots();
void InitDefaultsHmiGlbPrcpObstacleImpl();
void InitDefaultsHmiGlbPrcpObstacle();
void InitDefaultsHmiMapInfoImpl();
void InitDefaultsHmiMapInfo();
void InitDefaultsHmiMapDisplayImpl();
void InitDefaultsHmiMapDisplay();
void InitDefaultsHmiVpaStateImpl();
void InitDefaultsHmiVpaState();
void InitDefaultsHmiHpaRenderImpl();
void InitDefaultsHmiHpaRender();
void InitDefaultsHmiHpaRenderMsgImpl();
void InitDefaultsHmiHpaRenderMsg();
inline void InitDefaults() {
  InitDefaultsHmiFusionObstacle();
  InitDefaultsHmiLocalization();
  InitDefaultsHmiGlbPrcpPrkgSlots();
  InitDefaultsHmiGlbPrcpObstacle();
  InitDefaultsHmiMapInfo();
  InitDefaultsHmiMapDisplay();
  InitDefaultsHmiVpaState();
  InitDefaultsHmiHpaRender();
  InitDefaultsHmiHpaRenderMsg();
}
}  // namespace protobuf_hmi_5fhpa_5frender_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
class HmiFusionObstacle;
class HmiFusionObstacleDefaultTypeInternal;
extern HmiFusionObstacleDefaultTypeInternal _HmiFusionObstacle_default_instance_;
class HmiGlbPrcpObstacle;
class HmiGlbPrcpObstacleDefaultTypeInternal;
extern HmiGlbPrcpObstacleDefaultTypeInternal _HmiGlbPrcpObstacle_default_instance_;
class HmiGlbPrcpPrkgSlots;
class HmiGlbPrcpPrkgSlotsDefaultTypeInternal;
extern HmiGlbPrcpPrkgSlotsDefaultTypeInternal _HmiGlbPrcpPrkgSlots_default_instance_;
class HmiHpaRender;
class HmiHpaRenderDefaultTypeInternal;
extern HmiHpaRenderDefaultTypeInternal _HmiHpaRender_default_instance_;
class HmiHpaRenderMsg;
class HmiHpaRenderMsgDefaultTypeInternal;
extern HmiHpaRenderMsgDefaultTypeInternal _HmiHpaRenderMsg_default_instance_;
class HmiLocalization;
class HmiLocalizationDefaultTypeInternal;
extern HmiLocalizationDefaultTypeInternal _HmiLocalization_default_instance_;
class HmiMapDisplay;
class HmiMapDisplayDefaultTypeInternal;
extern HmiMapDisplayDefaultTypeInternal _HmiMapDisplay_default_instance_;
class HmiMapInfo;
class HmiMapInfoDefaultTypeInternal;
extern HmiMapInfoDefaultTypeInternal _HmiMapInfo_default_instance_;
class HmiVpaState;
class HmiVpaStateDefaultTypeInternal;
extern HmiVpaStateDefaultTypeInternal _HmiVpaState_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {

// ===================================================================

class HmiFusionObstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmiFusionObstacle) */ {
 public:
  HmiFusionObstacle();
  virtual ~HmiFusionObstacle();

  HmiFusionObstacle(const HmiFusionObstacle& from);

  inline HmiFusionObstacle& operator=(const HmiFusionObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmiFusionObstacle(HmiFusionObstacle&& from) noexcept
    : HmiFusionObstacle() {
    *this = ::std::move(from);
  }

  inline HmiFusionObstacle& operator=(HmiFusionObstacle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmiFusionObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmiFusionObstacle* internal_default_instance() {
    return reinterpret_cast<const HmiFusionObstacle*>(
               &_HmiFusionObstacle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HmiFusionObstacle* other);
  friend void swap(HmiFusionObstacle& a, HmiFusionObstacle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmiFusionObstacle* New() const PROTOBUF_FINAL { return New(NULL); }

  HmiFusionObstacle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmiFusionObstacle& from);
  void MergeFrom(const HmiFusionObstacle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmiFusionObstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.FusionObstacleOutPut obstacle_list = 2;
  int obstacle_list_size() const;
  void clear_obstacle_list();
  static const int kObstacleListFieldNumber = 2;
  const ::autodrive::workflow::proto::FusionObstacleOutPut& obstacle_list(int index) const;
  ::autodrive::workflow::proto::FusionObstacleOutPut* mutable_obstacle_list(int index);
  ::autodrive::workflow::proto::FusionObstacleOutPut* add_obstacle_list();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::FusionObstacleOutPut >*
      mutable_obstacle_list();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::FusionObstacleOutPut >&
      obstacle_list() const;

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmiFusionObstacle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::FusionObstacleOutPut > obstacle_list_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fhpa_5frender_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fhpa_5frender_2eproto::InitDefaultsHmiFusionObstacleImpl();
};
// -------------------------------------------------------------------

class HmiLocalization : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmiLocalization) */ {
 public:
  HmiLocalization();
  virtual ~HmiLocalization();

  HmiLocalization(const HmiLocalization& from);

  inline HmiLocalization& operator=(const HmiLocalization& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmiLocalization(HmiLocalization&& from) noexcept
    : HmiLocalization() {
    *this = ::std::move(from);
  }

  inline HmiLocalization& operator=(HmiLocalization&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmiLocalization& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmiLocalization* internal_default_instance() {
    return reinterpret_cast<const HmiLocalization*>(
               &_HmiLocalization_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HmiLocalization* other);
  friend void swap(HmiLocalization& a, HmiLocalization& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmiLocalization* New() const PROTOBUF_FINAL { return New(NULL); }

  HmiLocalization* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmiLocalization& from);
  void MergeFrom(const HmiLocalization& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmiLocalization* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.ndm_base.NdmSpec ndm_header = 1;
  bool has_ndm_header() const;
  void clear_ndm_header();
  static const int kNdmHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::ndm_base::NdmSpec& ndm_header() const;
  ::autodrive::workflow::proto::ndm_base::NdmSpec* release_ndm_header();
  ::autodrive::workflow::proto::ndm_base::NdmSpec* mutable_ndm_header();
  void set_allocated_ndm_header(::autodrive::workflow::proto::ndm_base::NdmSpec* ndm_header);

  // .autodrive.workflow.proto.SpLocation location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::autodrive::workflow::proto::SpLocation& location() const;
  ::autodrive::workflow::proto::SpLocation* release_location();
  ::autodrive::workflow::proto::SpLocation* mutable_location();
  void set_allocated_location(::autodrive::workflow::proto::SpLocation* location);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmiLocalization)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::ndm_base::NdmSpec* ndm_header_;
  ::autodrive::workflow::proto::SpLocation* location_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fhpa_5frender_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fhpa_5frender_2eproto::InitDefaultsHmiLocalizationImpl();
};
// -------------------------------------------------------------------

class HmiGlbPrcpPrkgSlots : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmiGlbPrcpPrkgSlots) */ {
 public:
  HmiGlbPrcpPrkgSlots();
  virtual ~HmiGlbPrcpPrkgSlots();

  HmiGlbPrcpPrkgSlots(const HmiGlbPrcpPrkgSlots& from);

  inline HmiGlbPrcpPrkgSlots& operator=(const HmiGlbPrcpPrkgSlots& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmiGlbPrcpPrkgSlots(HmiGlbPrcpPrkgSlots&& from) noexcept
    : HmiGlbPrcpPrkgSlots() {
    *this = ::std::move(from);
  }

  inline HmiGlbPrcpPrkgSlots& operator=(HmiGlbPrcpPrkgSlots&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmiGlbPrcpPrkgSlots& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmiGlbPrcpPrkgSlots* internal_default_instance() {
    return reinterpret_cast<const HmiGlbPrcpPrkgSlots*>(
               &_HmiGlbPrcpPrkgSlots_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(HmiGlbPrcpPrkgSlots* other);
  friend void swap(HmiGlbPrcpPrkgSlots& a, HmiGlbPrcpPrkgSlots& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmiGlbPrcpPrkgSlots* New() const PROTOBUF_FINAL { return New(NULL); }

  HmiGlbPrcpPrkgSlots* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmiGlbPrcpPrkgSlots& from);
  void MergeFrom(const HmiGlbPrcpPrkgSlots& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmiGlbPrcpPrkgSlots* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.GlbPrkgSlot glb_prkg_slots = 1;
  int glb_prkg_slots_size() const;
  void clear_glb_prkg_slots();
  static const int kGlbPrkgSlotsFieldNumber = 1;
  const ::autodrive::workflow::proto::GlbPrkgSlot& glb_prkg_slots(int index) const;
  ::autodrive::workflow::proto::GlbPrkgSlot* mutable_glb_prkg_slots(int index);
  ::autodrive::workflow::proto::GlbPrkgSlot* add_glb_prkg_slots();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbPrkgSlot >*
      mutable_glb_prkg_slots();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbPrkgSlot >&
      glb_prkg_slots() const;

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmiGlbPrcpPrkgSlots)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbPrkgSlot > glb_prkg_slots_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fhpa_5frender_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fhpa_5frender_2eproto::InitDefaultsHmiGlbPrcpPrkgSlotsImpl();
};
// -------------------------------------------------------------------

class HmiGlbPrcpObstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmiGlbPrcpObstacle) */ {
 public:
  HmiGlbPrcpObstacle();
  virtual ~HmiGlbPrcpObstacle();

  HmiGlbPrcpObstacle(const HmiGlbPrcpObstacle& from);

  inline HmiGlbPrcpObstacle& operator=(const HmiGlbPrcpObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmiGlbPrcpObstacle(HmiGlbPrcpObstacle&& from) noexcept
    : HmiGlbPrcpObstacle() {
    *this = ::std::move(from);
  }

  inline HmiGlbPrcpObstacle& operator=(HmiGlbPrcpObstacle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmiGlbPrcpObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmiGlbPrcpObstacle* internal_default_instance() {
    return reinterpret_cast<const HmiGlbPrcpObstacle*>(
               &_HmiGlbPrcpObstacle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(HmiGlbPrcpObstacle* other);
  friend void swap(HmiGlbPrcpObstacle& a, HmiGlbPrcpObstacle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmiGlbPrcpObstacle* New() const PROTOBUF_FINAL { return New(NULL); }

  HmiGlbPrcpObstacle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmiGlbPrcpObstacle& from);
  void MergeFrom(const HmiGlbPrcpObstacle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmiGlbPrcpObstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.GlbObstacle glb_prcp_obstacle = 1;
  int glb_prcp_obstacle_size() const;
  void clear_glb_prcp_obstacle();
  static const int kGlbPrcpObstacleFieldNumber = 1;
  const ::autodrive::workflow::proto::GlbObstacle& glb_prcp_obstacle(int index) const;
  ::autodrive::workflow::proto::GlbObstacle* mutable_glb_prcp_obstacle(int index);
  ::autodrive::workflow::proto::GlbObstacle* add_glb_prcp_obstacle();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbObstacle >*
      mutable_glb_prcp_obstacle();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbObstacle >&
      glb_prcp_obstacle() const;

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmiGlbPrcpObstacle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbObstacle > glb_prcp_obstacle_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fhpa_5frender_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fhpa_5frender_2eproto::InitDefaultsHmiGlbPrcpObstacleImpl();
};
// -------------------------------------------------------------------

class HmiMapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmiMapInfo) */ {
 public:
  HmiMapInfo();
  virtual ~HmiMapInfo();

  HmiMapInfo(const HmiMapInfo& from);

  inline HmiMapInfo& operator=(const HmiMapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmiMapInfo(HmiMapInfo&& from) noexcept
    : HmiMapInfo() {
    *this = ::std::move(from);
  }

  inline HmiMapInfo& operator=(HmiMapInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmiMapInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmiMapInfo* internal_default_instance() {
    return reinterpret_cast<const HmiMapInfo*>(
               &_HmiMapInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(HmiMapInfo* other);
  friend void swap(HmiMapInfo& a, HmiMapInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmiMapInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  HmiMapInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmiMapInfo& from);
  void MergeFrom(const HmiMapInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmiMapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.MapCommonHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::MapCommonHeader& header() const;
  ::autodrive::workflow::proto::MapCommonHeader* release_header();
  ::autodrive::workflow::proto::MapCommonHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::MapCommonHeader* header);

  // .autodrive.workflow.proto.GlbTrajectory global_trajectory = 2;
  bool has_global_trajectory() const;
  void clear_global_trajectory();
  static const int kGlobalTrajectoryFieldNumber = 2;
  const ::autodrive::workflow::proto::GlbTrajectory& global_trajectory() const;
  ::autodrive::workflow::proto::GlbTrajectory* release_global_trajectory();
  ::autodrive::workflow::proto::GlbTrajectory* mutable_global_trajectory();
  void set_allocated_global_trajectory(::autodrive::workflow::proto::GlbTrajectory* global_trajectory);

  // .autodrive.workflow.proto.HmiGlbPrcpPrkgSlots global_percep_parking_slots = 3;
  bool has_global_percep_parking_slots() const;
  void clear_global_percep_parking_slots();
  static const int kGlobalPercepParkingSlotsFieldNumber = 3;
  const ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots& global_percep_parking_slots() const;
  ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots* release_global_percep_parking_slots();
  ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots* mutable_global_percep_parking_slots();
  void set_allocated_global_percep_parking_slots(::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots* global_percep_parking_slots);

  // .autodrive.workflow.proto.HmiGlbPrcpObstacle global_perception_obstacle = 4;
  bool has_global_perception_obstacle() const;
  void clear_global_perception_obstacle();
  static const int kGlobalPerceptionObstacleFieldNumber = 4;
  const ::autodrive::workflow::proto::HmiGlbPrcpObstacle& global_perception_obstacle() const;
  ::autodrive::workflow::proto::HmiGlbPrcpObstacle* release_global_perception_obstacle();
  ::autodrive::workflow::proto::HmiGlbPrcpObstacle* mutable_global_perception_obstacle();
  void set_allocated_global_perception_obstacle(::autodrive::workflow::proto::HmiGlbPrcpObstacle* global_perception_obstacle);

  // float map_distance = 5;
  void clear_map_distance();
  static const int kMapDistanceFieldNumber = 5;
  float map_distance() const;
  void set_map_distance(float value);

  // float rest_map_distance = 6;
  void clear_rest_map_distance();
  static const int kRestMapDistanceFieldNumber = 6;
  float rest_map_distance() const;
  void set_rest_map_distance(float value);

  // int32 num_speed_bumps = 7;
  void clear_num_speed_bumps();
  static const int kNumSpeedBumpsFieldNumber = 7;
  ::google::protobuf::int32 num_speed_bumps() const;
  void set_num_speed_bumps(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmiMapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::MapCommonHeader* header_;
  ::autodrive::workflow::proto::GlbTrajectory* global_trajectory_;
  ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots* global_percep_parking_slots_;
  ::autodrive::workflow::proto::HmiGlbPrcpObstacle* global_perception_obstacle_;
  float map_distance_;
  float rest_map_distance_;
  ::google::protobuf::int32 num_speed_bumps_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fhpa_5frender_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fhpa_5frender_2eproto::InitDefaultsHmiMapInfoImpl();
};
// -------------------------------------------------------------------

class HmiMapDisplay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmiMapDisplay) */ {
 public:
  HmiMapDisplay();
  virtual ~HmiMapDisplay();

  HmiMapDisplay(const HmiMapDisplay& from);

  inline HmiMapDisplay& operator=(const HmiMapDisplay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmiMapDisplay(HmiMapDisplay&& from) noexcept
    : HmiMapDisplay() {
    *this = ::std::move(from);
  }

  inline HmiMapDisplay& operator=(HmiMapDisplay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmiMapDisplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmiMapDisplay* internal_default_instance() {
    return reinterpret_cast<const HmiMapDisplay*>(
               &_HmiMapDisplay_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(HmiMapDisplay* other);
  friend void swap(HmiMapDisplay& a, HmiMapDisplay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmiMapDisplay* New() const PROTOBUF_FINAL { return New(NULL); }

  HmiMapDisplay* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmiMapDisplay& from);
  void MergeFrom(const HmiMapDisplay& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmiMapDisplay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.HmiMapInfo map_info = 1;
  bool has_map_info() const;
  void clear_map_info();
  static const int kMapInfoFieldNumber = 1;
  const ::autodrive::workflow::proto::HmiMapInfo& map_info() const;
  ::autodrive::workflow::proto::HmiMapInfo* release_map_info();
  ::autodrive::workflow::proto::HmiMapInfo* mutable_map_info();
  void set_allocated_map_info(::autodrive::workflow::proto::HmiMapInfo* map_info);

  // .autodrive.workflow.proto.MapCommonHeader header = 6;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 6;
  const ::autodrive::workflow::proto::MapCommonHeader& header() const;
  ::autodrive::workflow::proto::MapCommonHeader* release_header();
  ::autodrive::workflow::proto::MapCommonHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::MapCommonHeader* header);

  // int32 num_maps = 3;
  void clear_num_maps();
  static const int kNumMapsFieldNumber = 3;
  ::google::protobuf::int32 num_maps() const;
  void set_num_maps(::google::protobuf::int32 value);

  // bool update_map_info = 2;
  void clear_update_map_info();
  static const int kUpdateMapInfoFieldNumber = 2;
  bool update_map_info() const;
  void set_update_map_info(bool value);

  // bool is_match = 5;
  void clear_is_match();
  static const int kIsMatchFieldNumber = 5;
  bool is_match() const;
  void set_is_match(bool value);

  // int32 new_id = 4;
  void clear_new_id();
  static const int kNewIdFieldNumber = 4;
  ::google::protobuf::int32 new_id() const;
  void set_new_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmiMapDisplay)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::HmiMapInfo* map_info_;
  ::autodrive::workflow::proto::MapCommonHeader* header_;
  ::google::protobuf::int32 num_maps_;
  bool update_map_info_;
  bool is_match_;
  ::google::protobuf::int32 new_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fhpa_5frender_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fhpa_5frender_2eproto::InitDefaultsHmiMapDisplayImpl();
};
// -------------------------------------------------------------------

class HmiVpaState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmiVpaState) */ {
 public:
  HmiVpaState();
  virtual ~HmiVpaState();

  HmiVpaState(const HmiVpaState& from);

  inline HmiVpaState& operator=(const HmiVpaState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmiVpaState(HmiVpaState&& from) noexcept
    : HmiVpaState() {
    *this = ::std::move(from);
  }

  inline HmiVpaState& operator=(HmiVpaState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmiVpaState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmiVpaState* internal_default_instance() {
    return reinterpret_cast<const HmiVpaState*>(
               &_HmiVpaState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(HmiVpaState* other);
  friend void swap(HmiVpaState& a, HmiVpaState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmiVpaState* New() const PROTOBUF_FINAL { return New(NULL); }

  HmiVpaState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmiVpaState& from);
  void MergeFrom(const HmiVpaState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmiVpaState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.VPAEventType vpa_event = 1;
  void clear_vpa_event();
  static const int kVpaEventFieldNumber = 1;
  ::autodrive::workflow::proto::VPAEventType vpa_event() const;
  void set_vpa_event(::autodrive::workflow::proto::VPAEventType value);

  // .autodrive.workflow.proto.HPAState hpa_state = 2;
  void clear_hpa_state();
  static const int kHpaStateFieldNumber = 2;
  ::autodrive::workflow::proto::HPAState hpa_state() const;
  void set_hpa_state(::autodrive::workflow::proto::HPAState value);

  // .autodrive.workflow.proto.MappingOddType mapping_odd_type = 3;
  void clear_mapping_odd_type();
  static const int kMappingOddTypeFieldNumber = 3;
  ::autodrive::workflow::proto::MappingOddType mapping_odd_type() const;
  void set_mapping_odd_type(::autodrive::workflow::proto::MappingOddType value);

  // .autodrive.workflow.proto.LocOddType loc_odd_type = 4;
  void clear_loc_odd_type();
  static const int kLocOddTypeFieldNumber = 4;
  ::autodrive::workflow::proto::LocOddType loc_odd_type() const;
  void set_loc_odd_type(::autodrive::workflow::proto::LocOddType value);

  // .autodrive.workflow.proto.MapSavingStage map_saving_stage = 5;
  void clear_map_saving_stage();
  static const int kMapSavingStageFieldNumber = 5;
  ::autodrive::workflow::proto::MapSavingStage map_saving_stage() const;
  void set_map_saving_stage(::autodrive::workflow::proto::MapSavingStage value);

  // .autodrive.workflow.proto.LocalLocStage local_loc_stage = 6;
  void clear_local_loc_stage();
  static const int kLocalLocStageFieldNumber = 6;
  ::autodrive::workflow::proto::LocalLocStage local_loc_stage() const;
  void set_local_loc_stage(::autodrive::workflow::proto::LocalLocStage value);

  // .autodrive.workflow.proto.MapDeletingStage map_deleted_stage = 7;
  void clear_map_deleted_stage();
  static const int kMapDeletedStageFieldNumber = 7;
  ::autodrive::workflow::proto::MapDeletingStage map_deleted_stage() const;
  void set_map_deleted_stage(::autodrive::workflow::proto::MapDeletingStage value);

  // .autodrive.workflow.proto.MappingStage map_stage = 8;
  void clear_map_stage();
  static const int kMapStageFieldNumber = 8;
  ::autodrive::workflow::proto::MappingStage map_stage() const;
  void set_map_stage(::autodrive::workflow::proto::MappingStage value);

  // .autodrive.workflow.proto.MapOptimizeStage map_optimized_stage = 9;
  void clear_map_optimized_stage();
  static const int kMapOptimizedStageFieldNumber = 9;
  ::autodrive::workflow::proto::MapOptimizeStage map_optimized_stage() const;
  void set_map_optimized_stage(::autodrive::workflow::proto::MapOptimizeStage value);

  // .autodrive.workflow.proto.ErrorCode error_code = 10;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 10;
  ::autodrive::workflow::proto::ErrorCode error_code() const;
  void set_error_code(::autodrive::workflow::proto::ErrorCode value);

  // int32 target_parking_slot_id = 11;
  void clear_target_parking_slot_id();
  static const int kTargetParkingSlotIdFieldNumber = 11;
  ::google::protobuf::int32 target_parking_slot_id() const;
  void set_target_parking_slot_id(::google::protobuf::int32 value);

  // uint32 map_saving_progress = 12;
  void clear_map_saving_progress();
  static const int kMapSavingProgressFieldNumber = 12;
  ::google::protobuf::uint32 map_saving_progress() const;
  void set_map_saving_progress(::google::protobuf::uint32 value);

  // uint32 avaliable_map_id = 13;
  void clear_avaliable_map_id();
  static const int kAvaliableMapIdFieldNumber = 13;
  ::google::protobuf::uint32 avaliable_map_id() const;
  void set_avaliable_map_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmiVpaState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int vpa_event_;
  int hpa_state_;
  int mapping_odd_type_;
  int loc_odd_type_;
  int map_saving_stage_;
  int local_loc_stage_;
  int map_deleted_stage_;
  int map_stage_;
  int map_optimized_stage_;
  int error_code_;
  ::google::protobuf::int32 target_parking_slot_id_;
  ::google::protobuf::uint32 map_saving_progress_;
  ::google::protobuf::uint32 avaliable_map_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fhpa_5frender_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fhpa_5frender_2eproto::InitDefaultsHmiVpaStateImpl();
};
// -------------------------------------------------------------------

class HmiHpaRender : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmiHpaRender) */ {
 public:
  HmiHpaRender();
  virtual ~HmiHpaRender();

  HmiHpaRender(const HmiHpaRender& from);

  inline HmiHpaRender& operator=(const HmiHpaRender& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmiHpaRender(HmiHpaRender&& from) noexcept
    : HmiHpaRender() {
    *this = ::std::move(from);
  }

  inline HmiHpaRender& operator=(HmiHpaRender&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmiHpaRender& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmiHpaRender* internal_default_instance() {
    return reinterpret_cast<const HmiHpaRender*>(
               &_HmiHpaRender_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(HmiHpaRender* other);
  friend void swap(HmiHpaRender& a, HmiHpaRender& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmiHpaRender* New() const PROTOBUF_FINAL { return New(NULL); }

  HmiHpaRender* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmiHpaRender& from);
  void MergeFrom(const HmiHpaRender& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmiHpaRender* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.HmiFusionObstacle obstacles = 1;
  bool has_obstacles() const;
  void clear_obstacles();
  static const int kObstaclesFieldNumber = 1;
  const ::autodrive::workflow::proto::HmiFusionObstacle& obstacles() const;
  ::autodrive::workflow::proto::HmiFusionObstacle* release_obstacles();
  ::autodrive::workflow::proto::HmiFusionObstacle* mutable_obstacles();
  void set_allocated_obstacles(::autodrive::workflow::proto::HmiFusionObstacle* obstacles);

  // .autodrive.workflow.proto.HmiLocalization localization = 2;
  bool has_localization() const;
  void clear_localization();
  static const int kLocalizationFieldNumber = 2;
  const ::autodrive::workflow::proto::HmiLocalization& localization() const;
  ::autodrive::workflow::proto::HmiLocalization* release_localization();
  ::autodrive::workflow::proto::HmiLocalization* mutable_localization();
  void set_allocated_localization(::autodrive::workflow::proto::HmiLocalization* localization);

  // .autodrive.workflow.proto.HmiMapDisplay map_display = 3;
  bool has_map_display() const;
  void clear_map_display();
  static const int kMapDisplayFieldNumber = 3;
  const ::autodrive::workflow::proto::HmiMapDisplay& map_display() const;
  ::autodrive::workflow::proto::HmiMapDisplay* release_map_display();
  ::autodrive::workflow::proto::HmiMapDisplay* mutable_map_display();
  void set_allocated_map_display(::autodrive::workflow::proto::HmiMapDisplay* map_display);

  // .autodrive.workflow.proto.HmiVpaState vpa_state = 4;
  bool has_vpa_state() const;
  void clear_vpa_state();
  static const int kVpaStateFieldNumber = 4;
  const ::autodrive::workflow::proto::HmiVpaState& vpa_state() const;
  ::autodrive::workflow::proto::HmiVpaState* release_vpa_state();
  ::autodrive::workflow::proto::HmiVpaState* mutable_vpa_state();
  void set_allocated_vpa_state(::autodrive::workflow::proto::HmiVpaState* vpa_state);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmiHpaRender)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::HmiFusionObstacle* obstacles_;
  ::autodrive::workflow::proto::HmiLocalization* localization_;
  ::autodrive::workflow::proto::HmiMapDisplay* map_display_;
  ::autodrive::workflow::proto::HmiVpaState* vpa_state_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fhpa_5frender_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fhpa_5frender_2eproto::InitDefaultsHmiHpaRenderImpl();
};
// -------------------------------------------------------------------

class HmiHpaRenderMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HmiHpaRenderMsg) */ {
 public:
  HmiHpaRenderMsg();
  virtual ~HmiHpaRenderMsg();

  HmiHpaRenderMsg(const HmiHpaRenderMsg& from);

  inline HmiHpaRenderMsg& operator=(const HmiHpaRenderMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HmiHpaRenderMsg(HmiHpaRenderMsg&& from) noexcept
    : HmiHpaRenderMsg() {
    *this = ::std::move(from);
  }

  inline HmiHpaRenderMsg& operator=(HmiHpaRenderMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HmiHpaRenderMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HmiHpaRenderMsg* internal_default_instance() {
    return reinterpret_cast<const HmiHpaRenderMsg*>(
               &_HmiHpaRenderMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(HmiHpaRenderMsg* other);
  friend void swap(HmiHpaRenderMsg& a, HmiHpaRenderMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HmiHpaRenderMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  HmiHpaRenderMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HmiHpaRenderMsg& from);
  void MergeFrom(const HmiHpaRenderMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HmiHpaRenderMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.MsgHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::MsgHeader& header() const;
  ::autodrive::workflow::proto::MsgHeader* release_header();
  ::autodrive::workflow::proto::MsgHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::MsgHeader* header);

  // .autodrive.workflow.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::autodrive::workflow::proto::Error& error() const;
  ::autodrive::workflow::proto::Error* release_error();
  ::autodrive::workflow::proto::Error* mutable_error();
  void set_allocated_error(::autodrive::workflow::proto::Error* error);

  // .autodrive.workflow.proto.HmiHpaRender hmi_hpa_render = 3;
  bool has_hmi_hpa_render() const;
  void clear_hmi_hpa_render();
  static const int kHmiHpaRenderFieldNumber = 3;
  const ::autodrive::workflow::proto::HmiHpaRender& hmi_hpa_render() const;
  ::autodrive::workflow::proto::HmiHpaRender* release_hmi_hpa_render();
  ::autodrive::workflow::proto::HmiHpaRender* mutable_hmi_hpa_render();
  void set_allocated_hmi_hpa_render(::autodrive::workflow::proto::HmiHpaRender* hmi_hpa_render);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HmiHpaRenderMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::MsgHeader* header_;
  ::autodrive::workflow::proto::Error* error_;
  ::autodrive::workflow::proto::HmiHpaRender* hmi_hpa_render_;
  mutable int _cached_size_;
  friend struct ::protobuf_hmi_5fhpa_5frender_2eproto::TableStruct;
  friend void ::protobuf_hmi_5fhpa_5frender_2eproto::InitDefaultsHmiHpaRenderMsgImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HmiFusionObstacle

// int64 timestamp = 1;
inline void HmiFusionObstacle::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 HmiFusionObstacle::timestamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiFusionObstacle.timestamp)
  return timestamp_;
}
inline void HmiFusionObstacle::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiFusionObstacle.timestamp)
}

// repeated .autodrive.workflow.proto.FusionObstacleOutPut obstacle_list = 2;
inline int HmiFusionObstacle::obstacle_list_size() const {
  return obstacle_list_.size();
}
inline const ::autodrive::workflow::proto::FusionObstacleOutPut& HmiFusionObstacle::obstacle_list(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiFusionObstacle.obstacle_list)
  return obstacle_list_.Get(index);
}
inline ::autodrive::workflow::proto::FusionObstacleOutPut* HmiFusionObstacle::mutable_obstacle_list(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiFusionObstacle.obstacle_list)
  return obstacle_list_.Mutable(index);
}
inline ::autodrive::workflow::proto::FusionObstacleOutPut* HmiFusionObstacle::add_obstacle_list() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.HmiFusionObstacle.obstacle_list)
  return obstacle_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::FusionObstacleOutPut >*
HmiFusionObstacle::mutable_obstacle_list() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.HmiFusionObstacle.obstacle_list)
  return &obstacle_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::FusionObstacleOutPut >&
HmiFusionObstacle::obstacle_list() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.HmiFusionObstacle.obstacle_list)
  return obstacle_list_;
}

// -------------------------------------------------------------------

// HmiLocalization

// .autodrive.workflow.proto.ndm_base.NdmSpec ndm_header = 1;
inline bool HmiLocalization::has_ndm_header() const {
  return this != internal_default_instance() && ndm_header_ != NULL;
}
inline const ::autodrive::workflow::proto::ndm_base::NdmSpec& HmiLocalization::ndm_header() const {
  const ::autodrive::workflow::proto::ndm_base::NdmSpec* p = ndm_header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiLocalization.ndm_header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::ndm_base::NdmSpec*>(
      &::autodrive::workflow::proto::ndm_base::_NdmSpec_default_instance_);
}
inline ::autodrive::workflow::proto::ndm_base::NdmSpec* HmiLocalization::release_ndm_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiLocalization.ndm_header)
  
  ::autodrive::workflow::proto::ndm_base::NdmSpec* temp = ndm_header_;
  ndm_header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::ndm_base::NdmSpec* HmiLocalization::mutable_ndm_header() {
  
  if (ndm_header_ == NULL) {
    ndm_header_ = new ::autodrive::workflow::proto::ndm_base::NdmSpec;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiLocalization.ndm_header)
  return ndm_header_;
}
inline void HmiLocalization::set_allocated_ndm_header(::autodrive::workflow::proto::ndm_base::NdmSpec* ndm_header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ndm_header_);
  }
  if (ndm_header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ndm_header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ndm_header, submessage_arena);
    }
    
  } else {
    
  }
  ndm_header_ = ndm_header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiLocalization.ndm_header)
}

// .autodrive.workflow.proto.SpLocation location = 2;
inline bool HmiLocalization::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline const ::autodrive::workflow::proto::SpLocation& HmiLocalization::location() const {
  const ::autodrive::workflow::proto::SpLocation* p = location_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiLocalization.location)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::SpLocation*>(
      &::autodrive::workflow::proto::_SpLocation_default_instance_);
}
inline ::autodrive::workflow::proto::SpLocation* HmiLocalization::release_location() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiLocalization.location)
  
  ::autodrive::workflow::proto::SpLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::SpLocation* HmiLocalization::mutable_location() {
  
  if (location_ == NULL) {
    location_ = new ::autodrive::workflow::proto::SpLocation;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiLocalization.location)
  return location_;
}
inline void HmiLocalization::set_allocated_location(::autodrive::workflow::proto::SpLocation* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(location_);
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiLocalization.location)
}

// -------------------------------------------------------------------

// HmiGlbPrcpPrkgSlots

// repeated .autodrive.workflow.proto.GlbPrkgSlot glb_prkg_slots = 1;
inline int HmiGlbPrcpPrkgSlots::glb_prkg_slots_size() const {
  return glb_prkg_slots_.size();
}
inline const ::autodrive::workflow::proto::GlbPrkgSlot& HmiGlbPrcpPrkgSlots::glb_prkg_slots(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiGlbPrcpPrkgSlots.glb_prkg_slots)
  return glb_prkg_slots_.Get(index);
}
inline ::autodrive::workflow::proto::GlbPrkgSlot* HmiGlbPrcpPrkgSlots::mutable_glb_prkg_slots(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiGlbPrcpPrkgSlots.glb_prkg_slots)
  return glb_prkg_slots_.Mutable(index);
}
inline ::autodrive::workflow::proto::GlbPrkgSlot* HmiGlbPrcpPrkgSlots::add_glb_prkg_slots() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.HmiGlbPrcpPrkgSlots.glb_prkg_slots)
  return glb_prkg_slots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbPrkgSlot >*
HmiGlbPrcpPrkgSlots::mutable_glb_prkg_slots() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.HmiGlbPrcpPrkgSlots.glb_prkg_slots)
  return &glb_prkg_slots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbPrkgSlot >&
HmiGlbPrcpPrkgSlots::glb_prkg_slots() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.HmiGlbPrcpPrkgSlots.glb_prkg_slots)
  return glb_prkg_slots_;
}

// -------------------------------------------------------------------

// HmiGlbPrcpObstacle

// repeated .autodrive.workflow.proto.GlbObstacle glb_prcp_obstacle = 1;
inline int HmiGlbPrcpObstacle::glb_prcp_obstacle_size() const {
  return glb_prcp_obstacle_.size();
}
inline const ::autodrive::workflow::proto::GlbObstacle& HmiGlbPrcpObstacle::glb_prcp_obstacle(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiGlbPrcpObstacle.glb_prcp_obstacle)
  return glb_prcp_obstacle_.Get(index);
}
inline ::autodrive::workflow::proto::GlbObstacle* HmiGlbPrcpObstacle::mutable_glb_prcp_obstacle(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiGlbPrcpObstacle.glb_prcp_obstacle)
  return glb_prcp_obstacle_.Mutable(index);
}
inline ::autodrive::workflow::proto::GlbObstacle* HmiGlbPrcpObstacle::add_glb_prcp_obstacle() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.HmiGlbPrcpObstacle.glb_prcp_obstacle)
  return glb_prcp_obstacle_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbObstacle >*
HmiGlbPrcpObstacle::mutable_glb_prcp_obstacle() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.HmiGlbPrcpObstacle.glb_prcp_obstacle)
  return &glb_prcp_obstacle_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::GlbObstacle >&
HmiGlbPrcpObstacle::glb_prcp_obstacle() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.HmiGlbPrcpObstacle.glb_prcp_obstacle)
  return glb_prcp_obstacle_;
}

// -------------------------------------------------------------------

// HmiMapInfo

// .autodrive.workflow.proto.MapCommonHeader header = 1;
inline bool HmiMapInfo::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::MapCommonHeader& HmiMapInfo::header() const {
  const ::autodrive::workflow::proto::MapCommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapInfo.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::MapCommonHeader*>(
      &::autodrive::workflow::proto::_MapCommonHeader_default_instance_);
}
inline ::autodrive::workflow::proto::MapCommonHeader* HmiMapInfo::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiMapInfo.header)
  
  ::autodrive::workflow::proto::MapCommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::MapCommonHeader* HmiMapInfo::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::MapCommonHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiMapInfo.header)
  return header_;
}
inline void HmiMapInfo::set_allocated_header(::autodrive::workflow::proto::MapCommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiMapInfo.header)
}

// .autodrive.workflow.proto.GlbTrajectory global_trajectory = 2;
inline bool HmiMapInfo::has_global_trajectory() const {
  return this != internal_default_instance() && global_trajectory_ != NULL;
}
inline const ::autodrive::workflow::proto::GlbTrajectory& HmiMapInfo::global_trajectory() const {
  const ::autodrive::workflow::proto::GlbTrajectory* p = global_trajectory_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapInfo.global_trajectory)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::GlbTrajectory*>(
      &::autodrive::workflow::proto::_GlbTrajectory_default_instance_);
}
inline ::autodrive::workflow::proto::GlbTrajectory* HmiMapInfo::release_global_trajectory() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiMapInfo.global_trajectory)
  
  ::autodrive::workflow::proto::GlbTrajectory* temp = global_trajectory_;
  global_trajectory_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::GlbTrajectory* HmiMapInfo::mutable_global_trajectory() {
  
  if (global_trajectory_ == NULL) {
    global_trajectory_ = new ::autodrive::workflow::proto::GlbTrajectory;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiMapInfo.global_trajectory)
  return global_trajectory_;
}
inline void HmiMapInfo::set_allocated_global_trajectory(::autodrive::workflow::proto::GlbTrajectory* global_trajectory) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(global_trajectory_);
  }
  if (global_trajectory) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      global_trajectory = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, global_trajectory, submessage_arena);
    }
    
  } else {
    
  }
  global_trajectory_ = global_trajectory;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiMapInfo.global_trajectory)
}

// .autodrive.workflow.proto.HmiGlbPrcpPrkgSlots global_percep_parking_slots = 3;
inline bool HmiMapInfo::has_global_percep_parking_slots() const {
  return this != internal_default_instance() && global_percep_parking_slots_ != NULL;
}
inline void HmiMapInfo::clear_global_percep_parking_slots() {
  if (GetArenaNoVirtual() == NULL && global_percep_parking_slots_ != NULL) {
    delete global_percep_parking_slots_;
  }
  global_percep_parking_slots_ = NULL;
}
inline const ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots& HmiMapInfo::global_percep_parking_slots() const {
  const ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots* p = global_percep_parking_slots_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapInfo.global_percep_parking_slots)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots*>(
      &::autodrive::workflow::proto::_HmiGlbPrcpPrkgSlots_default_instance_);
}
inline ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots* HmiMapInfo::release_global_percep_parking_slots() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiMapInfo.global_percep_parking_slots)
  
  ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots* temp = global_percep_parking_slots_;
  global_percep_parking_slots_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots* HmiMapInfo::mutable_global_percep_parking_slots() {
  
  if (global_percep_parking_slots_ == NULL) {
    global_percep_parking_slots_ = new ::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiMapInfo.global_percep_parking_slots)
  return global_percep_parking_slots_;
}
inline void HmiMapInfo::set_allocated_global_percep_parking_slots(::autodrive::workflow::proto::HmiGlbPrcpPrkgSlots* global_percep_parking_slots) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete global_percep_parking_slots_;
  }
  if (global_percep_parking_slots) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      global_percep_parking_slots = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, global_percep_parking_slots, submessage_arena);
    }
    
  } else {
    
  }
  global_percep_parking_slots_ = global_percep_parking_slots;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiMapInfo.global_percep_parking_slots)
}

// .autodrive.workflow.proto.HmiGlbPrcpObstacle global_perception_obstacle = 4;
inline bool HmiMapInfo::has_global_perception_obstacle() const {
  return this != internal_default_instance() && global_perception_obstacle_ != NULL;
}
inline void HmiMapInfo::clear_global_perception_obstacle() {
  if (GetArenaNoVirtual() == NULL && global_perception_obstacle_ != NULL) {
    delete global_perception_obstacle_;
  }
  global_perception_obstacle_ = NULL;
}
inline const ::autodrive::workflow::proto::HmiGlbPrcpObstacle& HmiMapInfo::global_perception_obstacle() const {
  const ::autodrive::workflow::proto::HmiGlbPrcpObstacle* p = global_perception_obstacle_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapInfo.global_perception_obstacle)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmiGlbPrcpObstacle*>(
      &::autodrive::workflow::proto::_HmiGlbPrcpObstacle_default_instance_);
}
inline ::autodrive::workflow::proto::HmiGlbPrcpObstacle* HmiMapInfo::release_global_perception_obstacle() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiMapInfo.global_perception_obstacle)
  
  ::autodrive::workflow::proto::HmiGlbPrcpObstacle* temp = global_perception_obstacle_;
  global_perception_obstacle_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmiGlbPrcpObstacle* HmiMapInfo::mutable_global_perception_obstacle() {
  
  if (global_perception_obstacle_ == NULL) {
    global_perception_obstacle_ = new ::autodrive::workflow::proto::HmiGlbPrcpObstacle;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiMapInfo.global_perception_obstacle)
  return global_perception_obstacle_;
}
inline void HmiMapInfo::set_allocated_global_perception_obstacle(::autodrive::workflow::proto::HmiGlbPrcpObstacle* global_perception_obstacle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete global_perception_obstacle_;
  }
  if (global_perception_obstacle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      global_perception_obstacle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, global_perception_obstacle, submessage_arena);
    }
    
  } else {
    
  }
  global_perception_obstacle_ = global_perception_obstacle;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiMapInfo.global_perception_obstacle)
}

// float map_distance = 5;
inline void HmiMapInfo::clear_map_distance() {
  map_distance_ = 0;
}
inline float HmiMapInfo::map_distance() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapInfo.map_distance)
  return map_distance_;
}
inline void HmiMapInfo::set_map_distance(float value) {
  
  map_distance_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiMapInfo.map_distance)
}

// float rest_map_distance = 6;
inline void HmiMapInfo::clear_rest_map_distance() {
  rest_map_distance_ = 0;
}
inline float HmiMapInfo::rest_map_distance() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapInfo.rest_map_distance)
  return rest_map_distance_;
}
inline void HmiMapInfo::set_rest_map_distance(float value) {
  
  rest_map_distance_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiMapInfo.rest_map_distance)
}

// int32 num_speed_bumps = 7;
inline void HmiMapInfo::clear_num_speed_bumps() {
  num_speed_bumps_ = 0;
}
inline ::google::protobuf::int32 HmiMapInfo::num_speed_bumps() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapInfo.num_speed_bumps)
  return num_speed_bumps_;
}
inline void HmiMapInfo::set_num_speed_bumps(::google::protobuf::int32 value) {
  
  num_speed_bumps_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiMapInfo.num_speed_bumps)
}

// -------------------------------------------------------------------

// HmiMapDisplay

// .autodrive.workflow.proto.HmiMapInfo map_info = 1;
inline bool HmiMapDisplay::has_map_info() const {
  return this != internal_default_instance() && map_info_ != NULL;
}
inline void HmiMapDisplay::clear_map_info() {
  if (GetArenaNoVirtual() == NULL && map_info_ != NULL) {
    delete map_info_;
  }
  map_info_ = NULL;
}
inline const ::autodrive::workflow::proto::HmiMapInfo& HmiMapDisplay::map_info() const {
  const ::autodrive::workflow::proto::HmiMapInfo* p = map_info_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapDisplay.map_info)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmiMapInfo*>(
      &::autodrive::workflow::proto::_HmiMapInfo_default_instance_);
}
inline ::autodrive::workflow::proto::HmiMapInfo* HmiMapDisplay::release_map_info() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiMapDisplay.map_info)
  
  ::autodrive::workflow::proto::HmiMapInfo* temp = map_info_;
  map_info_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmiMapInfo* HmiMapDisplay::mutable_map_info() {
  
  if (map_info_ == NULL) {
    map_info_ = new ::autodrive::workflow::proto::HmiMapInfo;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiMapDisplay.map_info)
  return map_info_;
}
inline void HmiMapDisplay::set_allocated_map_info(::autodrive::workflow::proto::HmiMapInfo* map_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_info_;
  }
  if (map_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_info, submessage_arena);
    }
    
  } else {
    
  }
  map_info_ = map_info;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiMapDisplay.map_info)
}

// bool update_map_info = 2;
inline void HmiMapDisplay::clear_update_map_info() {
  update_map_info_ = false;
}
inline bool HmiMapDisplay::update_map_info() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapDisplay.update_map_info)
  return update_map_info_;
}
inline void HmiMapDisplay::set_update_map_info(bool value) {
  
  update_map_info_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiMapDisplay.update_map_info)
}

// int32 num_maps = 3;
inline void HmiMapDisplay::clear_num_maps() {
  num_maps_ = 0;
}
inline ::google::protobuf::int32 HmiMapDisplay::num_maps() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapDisplay.num_maps)
  return num_maps_;
}
inline void HmiMapDisplay::set_num_maps(::google::protobuf::int32 value) {
  
  num_maps_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiMapDisplay.num_maps)
}

// int32 new_id = 4;
inline void HmiMapDisplay::clear_new_id() {
  new_id_ = 0;
}
inline ::google::protobuf::int32 HmiMapDisplay::new_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapDisplay.new_id)
  return new_id_;
}
inline void HmiMapDisplay::set_new_id(::google::protobuf::int32 value) {
  
  new_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiMapDisplay.new_id)
}

// bool is_match = 5;
inline void HmiMapDisplay::clear_is_match() {
  is_match_ = false;
}
inline bool HmiMapDisplay::is_match() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapDisplay.is_match)
  return is_match_;
}
inline void HmiMapDisplay::set_is_match(bool value) {
  
  is_match_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiMapDisplay.is_match)
}

// .autodrive.workflow.proto.MapCommonHeader header = 6;
inline bool HmiMapDisplay::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::MapCommonHeader& HmiMapDisplay::header() const {
  const ::autodrive::workflow::proto::MapCommonHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiMapDisplay.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::MapCommonHeader*>(
      &::autodrive::workflow::proto::_MapCommonHeader_default_instance_);
}
inline ::autodrive::workflow::proto::MapCommonHeader* HmiMapDisplay::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiMapDisplay.header)
  
  ::autodrive::workflow::proto::MapCommonHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::MapCommonHeader* HmiMapDisplay::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::MapCommonHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiMapDisplay.header)
  return header_;
}
inline void HmiMapDisplay::set_allocated_header(::autodrive::workflow::proto::MapCommonHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiMapDisplay.header)
}

// -------------------------------------------------------------------

// HmiVpaState

// .autodrive.workflow.proto.VPAEventType vpa_event = 1;
inline void HmiVpaState::clear_vpa_event() {
  vpa_event_ = 0;
}
inline ::autodrive::workflow::proto::VPAEventType HmiVpaState::vpa_event() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.vpa_event)
  return static_cast< ::autodrive::workflow::proto::VPAEventType >(vpa_event_);
}
inline void HmiVpaState::set_vpa_event(::autodrive::workflow::proto::VPAEventType value) {
  
  vpa_event_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.vpa_event)
}

// .autodrive.workflow.proto.HPAState hpa_state = 2;
inline void HmiVpaState::clear_hpa_state() {
  hpa_state_ = 0;
}
inline ::autodrive::workflow::proto::HPAState HmiVpaState::hpa_state() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.hpa_state)
  return static_cast< ::autodrive::workflow::proto::HPAState >(hpa_state_);
}
inline void HmiVpaState::set_hpa_state(::autodrive::workflow::proto::HPAState value) {
  
  hpa_state_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.hpa_state)
}

// .autodrive.workflow.proto.MappingOddType mapping_odd_type = 3;
inline void HmiVpaState::clear_mapping_odd_type() {
  mapping_odd_type_ = 0;
}
inline ::autodrive::workflow::proto::MappingOddType HmiVpaState::mapping_odd_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.mapping_odd_type)
  return static_cast< ::autodrive::workflow::proto::MappingOddType >(mapping_odd_type_);
}
inline void HmiVpaState::set_mapping_odd_type(::autodrive::workflow::proto::MappingOddType value) {
  
  mapping_odd_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.mapping_odd_type)
}

// .autodrive.workflow.proto.LocOddType loc_odd_type = 4;
inline void HmiVpaState::clear_loc_odd_type() {
  loc_odd_type_ = 0;
}
inline ::autodrive::workflow::proto::LocOddType HmiVpaState::loc_odd_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.loc_odd_type)
  return static_cast< ::autodrive::workflow::proto::LocOddType >(loc_odd_type_);
}
inline void HmiVpaState::set_loc_odd_type(::autodrive::workflow::proto::LocOddType value) {
  
  loc_odd_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.loc_odd_type)
}

// .autodrive.workflow.proto.MapSavingStage map_saving_stage = 5;
inline void HmiVpaState::clear_map_saving_stage() {
  map_saving_stage_ = 0;
}
inline ::autodrive::workflow::proto::MapSavingStage HmiVpaState::map_saving_stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.map_saving_stage)
  return static_cast< ::autodrive::workflow::proto::MapSavingStage >(map_saving_stage_);
}
inline void HmiVpaState::set_map_saving_stage(::autodrive::workflow::proto::MapSavingStage value) {
  
  map_saving_stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.map_saving_stage)
}

// .autodrive.workflow.proto.LocalLocStage local_loc_stage = 6;
inline void HmiVpaState::clear_local_loc_stage() {
  local_loc_stage_ = 0;
}
inline ::autodrive::workflow::proto::LocalLocStage HmiVpaState::local_loc_stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.local_loc_stage)
  return static_cast< ::autodrive::workflow::proto::LocalLocStage >(local_loc_stage_);
}
inline void HmiVpaState::set_local_loc_stage(::autodrive::workflow::proto::LocalLocStage value) {
  
  local_loc_stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.local_loc_stage)
}

// .autodrive.workflow.proto.MapDeletingStage map_deleted_stage = 7;
inline void HmiVpaState::clear_map_deleted_stage() {
  map_deleted_stage_ = 0;
}
inline ::autodrive::workflow::proto::MapDeletingStage HmiVpaState::map_deleted_stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.map_deleted_stage)
  return static_cast< ::autodrive::workflow::proto::MapDeletingStage >(map_deleted_stage_);
}
inline void HmiVpaState::set_map_deleted_stage(::autodrive::workflow::proto::MapDeletingStage value) {
  
  map_deleted_stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.map_deleted_stage)
}

// .autodrive.workflow.proto.MappingStage map_stage = 8;
inline void HmiVpaState::clear_map_stage() {
  map_stage_ = 0;
}
inline ::autodrive::workflow::proto::MappingStage HmiVpaState::map_stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.map_stage)
  return static_cast< ::autodrive::workflow::proto::MappingStage >(map_stage_);
}
inline void HmiVpaState::set_map_stage(::autodrive::workflow::proto::MappingStage value) {
  
  map_stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.map_stage)
}

// .autodrive.workflow.proto.MapOptimizeStage map_optimized_stage = 9;
inline void HmiVpaState::clear_map_optimized_stage() {
  map_optimized_stage_ = 0;
}
inline ::autodrive::workflow::proto::MapOptimizeStage HmiVpaState::map_optimized_stage() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.map_optimized_stage)
  return static_cast< ::autodrive::workflow::proto::MapOptimizeStage >(map_optimized_stage_);
}
inline void HmiVpaState::set_map_optimized_stage(::autodrive::workflow::proto::MapOptimizeStage value) {
  
  map_optimized_stage_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.map_optimized_stage)
}

// .autodrive.workflow.proto.ErrorCode error_code = 10;
inline void HmiVpaState::clear_error_code() {
  error_code_ = 0;
}
inline ::autodrive::workflow::proto::ErrorCode HmiVpaState::error_code() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.error_code)
  return static_cast< ::autodrive::workflow::proto::ErrorCode >(error_code_);
}
inline void HmiVpaState::set_error_code(::autodrive::workflow::proto::ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.error_code)
}

// int32 target_parking_slot_id = 11;
inline void HmiVpaState::clear_target_parking_slot_id() {
  target_parking_slot_id_ = 0;
}
inline ::google::protobuf::int32 HmiVpaState::target_parking_slot_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.target_parking_slot_id)
  return target_parking_slot_id_;
}
inline void HmiVpaState::set_target_parking_slot_id(::google::protobuf::int32 value) {
  
  target_parking_slot_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.target_parking_slot_id)
}

// uint32 map_saving_progress = 12;
inline void HmiVpaState::clear_map_saving_progress() {
  map_saving_progress_ = 0u;
}
inline ::google::protobuf::uint32 HmiVpaState::map_saving_progress() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.map_saving_progress)
  return map_saving_progress_;
}
inline void HmiVpaState::set_map_saving_progress(::google::protobuf::uint32 value) {
  
  map_saving_progress_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.map_saving_progress)
}

// uint32 avaliable_map_id = 13;
inline void HmiVpaState::clear_avaliable_map_id() {
  avaliable_map_id_ = 0u;
}
inline ::google::protobuf::uint32 HmiVpaState::avaliable_map_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiVpaState.avaliable_map_id)
  return avaliable_map_id_;
}
inline void HmiVpaState::set_avaliable_map_id(::google::protobuf::uint32 value) {
  
  avaliable_map_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HmiVpaState.avaliable_map_id)
}

// -------------------------------------------------------------------

// HmiHpaRender

// .autodrive.workflow.proto.HmiFusionObstacle obstacles = 1;
inline bool HmiHpaRender::has_obstacles() const {
  return this != internal_default_instance() && obstacles_ != NULL;
}
inline void HmiHpaRender::clear_obstacles() {
  if (GetArenaNoVirtual() == NULL && obstacles_ != NULL) {
    delete obstacles_;
  }
  obstacles_ = NULL;
}
inline const ::autodrive::workflow::proto::HmiFusionObstacle& HmiHpaRender::obstacles() const {
  const ::autodrive::workflow::proto::HmiFusionObstacle* p = obstacles_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiHpaRender.obstacles)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmiFusionObstacle*>(
      &::autodrive::workflow::proto::_HmiFusionObstacle_default_instance_);
}
inline ::autodrive::workflow::proto::HmiFusionObstacle* HmiHpaRender::release_obstacles() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiHpaRender.obstacles)
  
  ::autodrive::workflow::proto::HmiFusionObstacle* temp = obstacles_;
  obstacles_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmiFusionObstacle* HmiHpaRender::mutable_obstacles() {
  
  if (obstacles_ == NULL) {
    obstacles_ = new ::autodrive::workflow::proto::HmiFusionObstacle;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiHpaRender.obstacles)
  return obstacles_;
}
inline void HmiHpaRender::set_allocated_obstacles(::autodrive::workflow::proto::HmiFusionObstacle* obstacles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete obstacles_;
  }
  if (obstacles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      obstacles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, obstacles, submessage_arena);
    }
    
  } else {
    
  }
  obstacles_ = obstacles;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiHpaRender.obstacles)
}

// .autodrive.workflow.proto.HmiLocalization localization = 2;
inline bool HmiHpaRender::has_localization() const {
  return this != internal_default_instance() && localization_ != NULL;
}
inline void HmiHpaRender::clear_localization() {
  if (GetArenaNoVirtual() == NULL && localization_ != NULL) {
    delete localization_;
  }
  localization_ = NULL;
}
inline const ::autodrive::workflow::proto::HmiLocalization& HmiHpaRender::localization() const {
  const ::autodrive::workflow::proto::HmiLocalization* p = localization_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiHpaRender.localization)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmiLocalization*>(
      &::autodrive::workflow::proto::_HmiLocalization_default_instance_);
}
inline ::autodrive::workflow::proto::HmiLocalization* HmiHpaRender::release_localization() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiHpaRender.localization)
  
  ::autodrive::workflow::proto::HmiLocalization* temp = localization_;
  localization_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmiLocalization* HmiHpaRender::mutable_localization() {
  
  if (localization_ == NULL) {
    localization_ = new ::autodrive::workflow::proto::HmiLocalization;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiHpaRender.localization)
  return localization_;
}
inline void HmiHpaRender::set_allocated_localization(::autodrive::workflow::proto::HmiLocalization* localization) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete localization_;
  }
  if (localization) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      localization = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, localization, submessage_arena);
    }
    
  } else {
    
  }
  localization_ = localization;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiHpaRender.localization)
}

// .autodrive.workflow.proto.HmiMapDisplay map_display = 3;
inline bool HmiHpaRender::has_map_display() const {
  return this != internal_default_instance() && map_display_ != NULL;
}
inline void HmiHpaRender::clear_map_display() {
  if (GetArenaNoVirtual() == NULL && map_display_ != NULL) {
    delete map_display_;
  }
  map_display_ = NULL;
}
inline const ::autodrive::workflow::proto::HmiMapDisplay& HmiHpaRender::map_display() const {
  const ::autodrive::workflow::proto::HmiMapDisplay* p = map_display_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiHpaRender.map_display)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmiMapDisplay*>(
      &::autodrive::workflow::proto::_HmiMapDisplay_default_instance_);
}
inline ::autodrive::workflow::proto::HmiMapDisplay* HmiHpaRender::release_map_display() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiHpaRender.map_display)
  
  ::autodrive::workflow::proto::HmiMapDisplay* temp = map_display_;
  map_display_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmiMapDisplay* HmiHpaRender::mutable_map_display() {
  
  if (map_display_ == NULL) {
    map_display_ = new ::autodrive::workflow::proto::HmiMapDisplay;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiHpaRender.map_display)
  return map_display_;
}
inline void HmiHpaRender::set_allocated_map_display(::autodrive::workflow::proto::HmiMapDisplay* map_display) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_display_;
  }
  if (map_display) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_display = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_display, submessage_arena);
    }
    
  } else {
    
  }
  map_display_ = map_display;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiHpaRender.map_display)
}

// .autodrive.workflow.proto.HmiVpaState vpa_state = 4;
inline bool HmiHpaRender::has_vpa_state() const {
  return this != internal_default_instance() && vpa_state_ != NULL;
}
inline void HmiHpaRender::clear_vpa_state() {
  if (GetArenaNoVirtual() == NULL && vpa_state_ != NULL) {
    delete vpa_state_;
  }
  vpa_state_ = NULL;
}
inline const ::autodrive::workflow::proto::HmiVpaState& HmiHpaRender::vpa_state() const {
  const ::autodrive::workflow::proto::HmiVpaState* p = vpa_state_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiHpaRender.vpa_state)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmiVpaState*>(
      &::autodrive::workflow::proto::_HmiVpaState_default_instance_);
}
inline ::autodrive::workflow::proto::HmiVpaState* HmiHpaRender::release_vpa_state() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiHpaRender.vpa_state)
  
  ::autodrive::workflow::proto::HmiVpaState* temp = vpa_state_;
  vpa_state_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmiVpaState* HmiHpaRender::mutable_vpa_state() {
  
  if (vpa_state_ == NULL) {
    vpa_state_ = new ::autodrive::workflow::proto::HmiVpaState;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiHpaRender.vpa_state)
  return vpa_state_;
}
inline void HmiHpaRender::set_allocated_vpa_state(::autodrive::workflow::proto::HmiVpaState* vpa_state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vpa_state_;
  }
  if (vpa_state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vpa_state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vpa_state, submessage_arena);
    }
    
  } else {
    
  }
  vpa_state_ = vpa_state;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiHpaRender.vpa_state)
}

// -------------------------------------------------------------------

// HmiHpaRenderMsg

// .autodrive.workflow.proto.MsgHeader header = 1;
inline bool HmiHpaRenderMsg::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::MsgHeader& HmiHpaRenderMsg::header() const {
  const ::autodrive::workflow::proto::MsgHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiHpaRenderMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::MsgHeader*>(
      &::autodrive::workflow::proto::_MsgHeader_default_instance_);
}
inline ::autodrive::workflow::proto::MsgHeader* HmiHpaRenderMsg::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiHpaRenderMsg.header)
  
  ::autodrive::workflow::proto::MsgHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::MsgHeader* HmiHpaRenderMsg::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::MsgHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiHpaRenderMsg.header)
  return header_;
}
inline void HmiHpaRenderMsg::set_allocated_header(::autodrive::workflow::proto::MsgHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiHpaRenderMsg.header)
}

// .autodrive.workflow.proto.Error error = 2;
inline bool HmiHpaRenderMsg::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::autodrive::workflow::proto::Error& HmiHpaRenderMsg::error() const {
  const ::autodrive::workflow::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiHpaRenderMsg.error)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Error*>(
      &::autodrive::workflow::proto::_Error_default_instance_);
}
inline ::autodrive::workflow::proto::Error* HmiHpaRenderMsg::release_error() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiHpaRenderMsg.error)
  
  ::autodrive::workflow::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Error* HmiHpaRenderMsg::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::autodrive::workflow::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiHpaRenderMsg.error)
  return error_;
}
inline void HmiHpaRenderMsg::set_allocated_error(::autodrive::workflow::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiHpaRenderMsg.error)
}

// .autodrive.workflow.proto.HmiHpaRender hmi_hpa_render = 3;
inline bool HmiHpaRenderMsg::has_hmi_hpa_render() const {
  return this != internal_default_instance() && hmi_hpa_render_ != NULL;
}
inline void HmiHpaRenderMsg::clear_hmi_hpa_render() {
  if (GetArenaNoVirtual() == NULL && hmi_hpa_render_ != NULL) {
    delete hmi_hpa_render_;
  }
  hmi_hpa_render_ = NULL;
}
inline const ::autodrive::workflow::proto::HmiHpaRender& HmiHpaRenderMsg::hmi_hpa_render() const {
  const ::autodrive::workflow::proto::HmiHpaRender* p = hmi_hpa_render_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HmiHpaRenderMsg.hmi_hpa_render)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HmiHpaRender*>(
      &::autodrive::workflow::proto::_HmiHpaRender_default_instance_);
}
inline ::autodrive::workflow::proto::HmiHpaRender* HmiHpaRenderMsg::release_hmi_hpa_render() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.HmiHpaRenderMsg.hmi_hpa_render)
  
  ::autodrive::workflow::proto::HmiHpaRender* temp = hmi_hpa_render_;
  hmi_hpa_render_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HmiHpaRender* HmiHpaRenderMsg::mutable_hmi_hpa_render() {
  
  if (hmi_hpa_render_ == NULL) {
    hmi_hpa_render_ = new ::autodrive::workflow::proto::HmiHpaRender;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.HmiHpaRenderMsg.hmi_hpa_render)
  return hmi_hpa_render_;
}
inline void HmiHpaRenderMsg::set_allocated_hmi_hpa_render(::autodrive::workflow::proto::HmiHpaRender* hmi_hpa_render) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hmi_hpa_render_;
  }
  if (hmi_hpa_render) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hmi_hpa_render = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hmi_hpa_render, submessage_arena);
    }
    
  } else {
    
  }
  hmi_hpa_render_ = hmi_hpa_render;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.HmiHpaRenderMsg.hmi_hpa_render)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hmi_5fhpa_5frender_2eproto__INCLUDED
