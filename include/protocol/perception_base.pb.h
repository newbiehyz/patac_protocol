// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perception_base.proto

#ifndef PROTOBUF_perception_5fbase_2eproto__INCLUDED
#define PROTOBUF_perception_5fbase_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_perception_5fbase_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRectImpl();
void InitDefaultsRect();
void InitDefaultsRectIntImpl();
void InitDefaultsRectInt();
void InitDefaultsImageSpaceImpl();
void InitDefaultsImageSpace();
void InitDefaultsPolygonImpl();
void InitDefaultsPolygon();
void InitDefaultsCameraMatrixImpl();
void InitDefaultsCameraMatrix();
void InitDefaultsRoiMapImpl();
void InitDefaultsRoiMap();
void InitDefaultsHeaderImpl();
void InitDefaultsHeader();
void InitDefaultsCategoryImpl();
void InitDefaultsCategory();
void InitDefaultsBox3DImpl();
void InitDefaultsBox3D();
void InitDefaultsSceneParsingImpl();
void InitDefaultsSceneParsing();
inline void InitDefaults() {
  InitDefaultsRect();
  InitDefaultsRectInt();
  InitDefaultsImageSpace();
  InitDefaultsPolygon();
  InitDefaultsCameraMatrix();
  InitDefaultsRoiMap();
  InitDefaultsHeader();
  InitDefaultsCategory();
  InitDefaultsBox3D();
  InitDefaultsSceneParsing();
}
}  // namespace protobuf_perception_5fbase_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
namespace perception_base {
class Box3D;
class Box3DDefaultTypeInternal;
extern Box3DDefaultTypeInternal _Box3D_default_instance_;
class CameraMatrix;
class CameraMatrixDefaultTypeInternal;
extern CameraMatrixDefaultTypeInternal _CameraMatrix_default_instance_;
class Category;
class CategoryDefaultTypeInternal;
extern CategoryDefaultTypeInternal _Category_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class ImageSpace;
class ImageSpaceDefaultTypeInternal;
extern ImageSpaceDefaultTypeInternal _ImageSpace_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Rect;
class RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class RectInt;
class RectIntDefaultTypeInternal;
extern RectIntDefaultTypeInternal _RectInt_default_instance_;
class RoiMap;
class RoiMapDefaultTypeInternal;
extern RoiMapDefaultTypeInternal _RoiMap_default_instance_;
class SceneParsing;
class SceneParsingDefaultTypeInternal;
extern SceneParsingDefaultTypeInternal _SceneParsing_default_instance_;
}  // namespace perception_base
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {
namespace perception_base {

enum ImageId {
  kImageIdCylinderRear = 0,
  kImageIdCylinderFront = 1,
  kImageIdCylinderLeft = 2,
  kImageIdCylinderRight = 3,
  kImageIdIpm = 4,
  kImageIdRear = 5,
  kImageIdFront = 6,
  kImageIdCount = 7,
  ImageId_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ImageId_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ImageId_IsValid(int value);
const ImageId ImageId_MIN = kImageIdCylinderRear;
const ImageId ImageId_MAX = kImageIdCount;
const int ImageId_ARRAYSIZE = ImageId_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageId_descriptor();
inline const ::std::string& ImageId_Name(ImageId value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageId_descriptor(), value);
}
inline bool ImageId_Parse(
    const ::std::string& name, ImageId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageId>(
    ImageId_descriptor(), name, value);
}
enum RoiId {
  kRoiIdNone = 0,
  kRoiIdObstacle1 = 1,
  kRoiIdObstacle2 = 2,
  kRoiIdLane3 = 3,
  kRoiIdLane4 = 4,
  RoiId_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoiId_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoiId_IsValid(int value);
const RoiId RoiId_MIN = kRoiIdNone;
const RoiId RoiId_MAX = kRoiIdLane4;
const int RoiId_ARRAYSIZE = RoiId_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoiId_descriptor();
inline const ::std::string& RoiId_Name(RoiId value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoiId_descriptor(), value);
}
inline bool RoiId_Parse(
    const ::std::string& name, RoiId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoiId>(
    RoiId_descriptor(), name, value);
}
enum VehProperty {
  kVehPropertyType = 0,
  kVehPropertyClassification = 1,
  kVehPropertyLight = 2,
  kVehProperty3DBox = 3,
  kVehPropertyKeyPoints = 4,
  kVehPropertyVehBBox = 5,
  kVehPropertyKeyPointsConf = 6,
  kVehPropertyBigSmallCls = 7,
  kVehPropertyPoliceLight = 8,
  kVehPropertyOcclusion = 9,
  kVehPropertyPose = 10,
  kVehPropertyVehFull = 11,
  kVehPropertyOritationCls = 12,
  kVehPropertyOritationRe = 13,
  kVehProperty12KeyPoints = 14,
  kVehProperty12KeyPointsConf = 15,
  kVehproperty12KeyPointsCls = 16,
  kVehPropertyTruncation = 17,
  kVehPropertyCnt = 18,
  VehProperty_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VehProperty_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VehProperty_IsValid(int value);
const VehProperty VehProperty_MIN = kVehPropertyType;
const VehProperty VehProperty_MAX = kVehPropertyCnt;
const int VehProperty_ARRAYSIZE = VehProperty_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehProperty_descriptor();
inline const ::std::string& VehProperty_Name(VehProperty value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehProperty_descriptor(), value);
}
inline bool VehProperty_Parse(
    const ::std::string& name, VehProperty* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehProperty>(
    VehProperty_descriptor(), name, value);
}
enum PedProperty {
  kPedPropertyOrientation = 0,
  kPedPropertyCyclist = 1,
  kPedPropertyAge = 2,
  kPedPropertyPose = 3,
  kPedPropertyPosNeg = 4,
  kPedPropertyBBox = 5,
  kPedPropertyOcclusion = 6,
  kPedPropertyPosNegOcc = 7,
  kPedProperty2PEDet = 8,
  kPedPropertyCnt = 9,
  PedProperty_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PedProperty_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PedProperty_IsValid(int value);
const PedProperty PedProperty_MIN = kPedPropertyOrientation;
const PedProperty PedProperty_MAX = kPedPropertyCnt;
const int PedProperty_ARRAYSIZE = PedProperty_MAX + 1;

const ::google::protobuf::EnumDescriptor* PedProperty_descriptor();
inline const ::std::string& PedProperty_Name(PedProperty value) {
  return ::google::protobuf::internal::NameOfEnum(
    PedProperty_descriptor(), value);
}
inline bool PedProperty_Parse(
    const ::std::string& name, PedProperty* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PedProperty>(
    PedProperty_descriptor(), name, value);
}
enum VehRearProperty {
  kVehRearPropertyOcclusion = 0,
  kVehRearPropertyPart = 1,
  kVehRearPropertyBBox = 2,
  kVehRearPropertyLmks3 = 3,
  kVehRearPropertyScaleRe = 4,
  kVehRearPropertyPlate = 5,
  kVehRearPropertyCnt = 6,
  VehRearProperty_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VehRearProperty_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VehRearProperty_IsValid(int value);
const VehRearProperty VehRearProperty_MIN = kVehRearPropertyOcclusion;
const VehRearProperty VehRearProperty_MAX = kVehRearPropertyCnt;
const int VehRearProperty_ARRAYSIZE = VehRearProperty_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehRearProperty_descriptor();
inline const ::std::string& VehRearProperty_Name(VehRearProperty value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehRearProperty_descriptor(), value);
}
inline bool VehRearProperty_Parse(
    const ::std::string& name, VehRearProperty* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehRearProperty>(
    VehRearProperty_descriptor(), name, value);
}
enum SceneRegionType {
  kSceneRegionTypeUnknown = 0,
  kIndoor = 1,
  kOutdoor = 2,
  SceneRegionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SceneRegionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SceneRegionType_IsValid(int value);
const SceneRegionType SceneRegionType_MIN = kSceneRegionTypeUnknown;
const SceneRegionType SceneRegionType_MAX = kOutdoor;
const int SceneRegionType_ARRAYSIZE = SceneRegionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SceneRegionType_descriptor();
inline const ::std::string& SceneRegionType_Name(SceneRegionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SceneRegionType_descriptor(), value);
}
inline bool SceneRegionType_Parse(
    const ::std::string& name, SceneRegionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneRegionType>(
    SceneRegionType_descriptor(), name, value);
}
enum SceneIlluminationType {
  kSceneIlluminationTypeUnknown = 0,
  kDark = 1,
  kBright = 2,
  SceneIlluminationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SceneIlluminationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SceneIlluminationType_IsValid(int value);
const SceneIlluminationType SceneIlluminationType_MIN = kSceneIlluminationTypeUnknown;
const SceneIlluminationType SceneIlluminationType_MAX = kBright;
const int SceneIlluminationType_ARRAYSIZE = SceneIlluminationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SceneIlluminationType_descriptor();
inline const ::std::string& SceneIlluminationType_Name(SceneIlluminationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SceneIlluminationType_descriptor(), value);
}
inline bool SceneIlluminationType_Parse(
    const ::std::string& name, SceneIlluminationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneIlluminationType>(
    SceneIlluminationType_descriptor(), name, value);
}
enum SceneParkingType {
  kSceneParkingTypeUnknown = 0,
  kSlot = 1,
  kMechanicalSlot = 2,
  SceneParkingType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SceneParkingType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SceneParkingType_IsValid(int value);
const SceneParkingType SceneParkingType_MIN = kSceneParkingTypeUnknown;
const SceneParkingType SceneParkingType_MAX = kMechanicalSlot;
const int SceneParkingType_ARRAYSIZE = SceneParkingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SceneParkingType_descriptor();
inline const ::std::string& SceneParkingType_Name(SceneParkingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SceneParkingType_descriptor(), value);
}
inline bool SceneParkingType_Parse(
    const ::std::string& name, SceneParkingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneParkingType>(
    SceneParkingType_descriptor(), name, value);
}
// ===================================================================

class Rect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.perception_base.Rect) */ {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(Rect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Rect* other);
  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rect* New() const PROTOBUF_FINAL { return New(NULL); }

  Rect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Rect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float left = 1;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  float left() const;
  void set_left(float value);

  // float top = 2;
  void clear_top();
  static const int kTopFieldNumber = 2;
  float top() const;
  void set_top(float value);

  // float right = 3;
  void clear_right();
  static const int kRightFieldNumber = 3;
  float right() const;
  void set_right(float value);

  // float bottom = 4;
  void clear_bottom();
  static const int kBottomFieldNumber = 4;
  float bottom() const;
  void set_bottom(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.perception_base.Rect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float left_;
  float top_;
  float right_;
  float bottom_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5fbase_2eproto::TableStruct;
  friend void ::protobuf_perception_5fbase_2eproto::InitDefaultsRectImpl();
};
// -------------------------------------------------------------------

class RectInt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.perception_base.RectInt) */ {
 public:
  RectInt();
  virtual ~RectInt();

  RectInt(const RectInt& from);

  inline RectInt& operator=(const RectInt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RectInt(RectInt&& from) noexcept
    : RectInt() {
    *this = ::std::move(from);
  }

  inline RectInt& operator=(RectInt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RectInt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RectInt* internal_default_instance() {
    return reinterpret_cast<const RectInt*>(
               &_RectInt_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RectInt* other);
  friend void swap(RectInt& a, RectInt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RectInt* New() const PROTOBUF_FINAL { return New(NULL); }

  RectInt* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RectInt& from);
  void MergeFrom(const RectInt& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RectInt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 left = 1;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  ::google::protobuf::int32 left() const;
  void set_left(::google::protobuf::int32 value);

  // int32 top = 2;
  void clear_top();
  static const int kTopFieldNumber = 2;
  ::google::protobuf::int32 top() const;
  void set_top(::google::protobuf::int32 value);

  // int32 right = 3;
  void clear_right();
  static const int kRightFieldNumber = 3;
  ::google::protobuf::int32 right() const;
  void set_right(::google::protobuf::int32 value);

  // int32 bottom = 4;
  void clear_bottom();
  static const int kBottomFieldNumber = 4;
  ::google::protobuf::int32 bottom() const;
  void set_bottom(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.perception_base.RectInt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 bottom_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5fbase_2eproto::TableStruct;
  friend void ::protobuf_perception_5fbase_2eproto::InitDefaultsRectIntImpl();
};
// -------------------------------------------------------------------

class ImageSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.perception_base.ImageSpace) */ {
 public:
  ImageSpace();
  virtual ~ImageSpace();

  ImageSpace(const ImageSpace& from);

  inline ImageSpace& operator=(const ImageSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageSpace(ImageSpace&& from) noexcept
    : ImageSpace() {
    *this = ::std::move(from);
  }

  inline ImageSpace& operator=(ImageSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageSpace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImageSpace* internal_default_instance() {
    return reinterpret_cast<const ImageSpace*>(
               &_ImageSpace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ImageSpace* other);
  friend void swap(ImageSpace& a, ImageSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageSpace* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageSpace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageSpace& from);
  void MergeFrom(const ImageSpace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.perception_base.RectInt rect = 1;
  bool has_rect() const;
  void clear_rect();
  static const int kRectFieldNumber = 1;
  const ::autodrive::workflow::proto::perception_base::RectInt& rect() const;
  ::autodrive::workflow::proto::perception_base::RectInt* release_rect();
  ::autodrive::workflow::proto::perception_base::RectInt* mutable_rect();
  void set_allocated_rect(::autodrive::workflow::proto::perception_base::RectInt* rect);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.perception_base.ImageSpace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::perception_base::RectInt* rect_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5fbase_2eproto::TableStruct;
  friend void ::protobuf_perception_5fbase_2eproto::InitDefaultsImageSpaceImpl();
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.perception_base.Polygon) */ {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Polygon* other);
  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const PROTOBUF_FINAL { return New(NULL); }

  Polygon* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Polygon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.Vector3f polygon_points = 1;
  int polygon_points_size() const;
  void clear_polygon_points();
  static const int kPolygonPointsFieldNumber = 1;
  const ::autodrive::workflow::proto::Vector3f& polygon_points(int index) const;
  ::autodrive::workflow::proto::Vector3f* mutable_polygon_points(int index);
  ::autodrive::workflow::proto::Vector3f* add_polygon_points();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
      mutable_polygon_points();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
      polygon_points() const;

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.perception_base.Polygon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f > polygon_points_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5fbase_2eproto::TableStruct;
  friend void ::protobuf_perception_5fbase_2eproto::InitDefaultsPolygonImpl();
};
// -------------------------------------------------------------------

class CameraMatrix : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.perception_base.CameraMatrix) */ {
 public:
  CameraMatrix();
  virtual ~CameraMatrix();

  CameraMatrix(const CameraMatrix& from);

  inline CameraMatrix& operator=(const CameraMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraMatrix(CameraMatrix&& from) noexcept
    : CameraMatrix() {
    *this = ::std::move(from);
  }

  inline CameraMatrix& operator=(CameraMatrix&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraMatrix& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraMatrix* internal_default_instance() {
    return reinterpret_cast<const CameraMatrix*>(
               &_CameraMatrix_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CameraMatrix* other);
  friend void swap(CameraMatrix& a, CameraMatrix& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraMatrix* New() const PROTOBUF_FINAL { return New(NULL); }

  CameraMatrix* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CameraMatrix& from);
  void MergeFrom(const CameraMatrix& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CameraMatrix* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float mat_gnd2img = 1;
  int mat_gnd2img_size() const;
  void clear_mat_gnd2img();
  static const int kMatGnd2ImgFieldNumber = 1;
  float mat_gnd2img(int index) const;
  void set_mat_gnd2img(int index, float value);
  void add_mat_gnd2img(float value);
  const ::google::protobuf::RepeatedField< float >&
      mat_gnd2img() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_mat_gnd2img();

  // repeated float mat_img2gnd = 2;
  int mat_img2gnd_size() const;
  void clear_mat_img2gnd();
  static const int kMatImg2GndFieldNumber = 2;
  float mat_img2gnd(int index) const;
  void set_mat_img2gnd(int index, float value);
  void add_mat_img2gnd(float value);
  const ::google::protobuf::RepeatedField< float >&
      mat_img2gnd() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_mat_img2gnd();

  // repeated float mat_vcsgnd2img = 3;
  int mat_vcsgnd2img_size() const;
  void clear_mat_vcsgnd2img();
  static const int kMatVcsgnd2ImgFieldNumber = 3;
  float mat_vcsgnd2img(int index) const;
  void set_mat_vcsgnd2img(int index, float value);
  void add_mat_vcsgnd2img(float value);
  const ::google::protobuf::RepeatedField< float >&
      mat_vcsgnd2img() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_mat_vcsgnd2img();

  // repeated float mat_img2vcsgnd = 4;
  int mat_img2vcsgnd_size() const;
  void clear_mat_img2vcsgnd();
  static const int kMatImg2VcsgndFieldNumber = 4;
  float mat_img2vcsgnd(int index) const;
  void set_mat_img2vcsgnd(int index, float value);
  void add_mat_img2vcsgnd(float value);
  const ::google::protobuf::RepeatedField< float >&
      mat_img2vcsgnd() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_mat_img2vcsgnd();

  // repeated float mat_local2img = 5;
  int mat_local2img_size() const;
  void clear_mat_local2img();
  static const int kMatLocal2ImgFieldNumber = 5;
  float mat_local2img(int index) const;
  void set_mat_local2img(int index, float value);
  void add_mat_local2img(float value);
  const ::google::protobuf::RepeatedField< float >&
      mat_local2img() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_mat_local2img();

  // repeated float mat_img2local = 6;
  int mat_img2local_size() const;
  void clear_mat_img2local();
  static const int kMatImg2LocalFieldNumber = 6;
  float mat_img2local(int index) const;
  void set_mat_img2local(int index, float value);
  void add_mat_img2local(float value);
  const ::google::protobuf::RepeatedField< float >&
      mat_img2local() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_mat_img2local();

  // repeated float mat_vcs2img = 7;
  int mat_vcs2img_size() const;
  void clear_mat_vcs2img();
  static const int kMatVcs2ImgFieldNumber = 7;
  float mat_vcs2img(int index) const;
  void set_mat_vcs2img(int index, float value);
  void add_mat_vcs2img(float value);
  const ::google::protobuf::RepeatedField< float >&
      mat_vcs2img() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_mat_vcs2img();

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.perception_base.CameraMatrix)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > mat_gnd2img_;
  mutable int _mat_gnd2img_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > mat_img2gnd_;
  mutable int _mat_img2gnd_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > mat_vcsgnd2img_;
  mutable int _mat_vcsgnd2img_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > mat_img2vcsgnd_;
  mutable int _mat_img2vcsgnd_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > mat_local2img_;
  mutable int _mat_local2img_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > mat_img2local_;
  mutable int _mat_img2local_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > mat_vcs2img_;
  mutable int _mat_vcs2img_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5fbase_2eproto::TableStruct;
  friend void ::protobuf_perception_5fbase_2eproto::InitDefaultsCameraMatrixImpl();
};
// -------------------------------------------------------------------

class RoiMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.perception_base.RoiMap) */ {
 public:
  RoiMap();
  virtual ~RoiMap();

  RoiMap(const RoiMap& from);

  inline RoiMap& operator=(const RoiMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoiMap(RoiMap&& from) noexcept
    : RoiMap() {
    *this = ::std::move(from);
  }

  inline RoiMap& operator=(RoiMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoiMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoiMap* internal_default_instance() {
    return reinterpret_cast<const RoiMap*>(
               &_RoiMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RoiMap* other);
  friend void swap(RoiMap& a, RoiMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoiMap* New() const PROTOBUF_FINAL { return New(NULL); }

  RoiMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoiMap& from);
  void MergeFrom(const RoiMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoiMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.perception_base.Rect model_roi = 1;
  bool has_model_roi() const;
  void clear_model_roi();
  static const int kModelRoiFieldNumber = 1;
  const ::autodrive::workflow::proto::perception_base::Rect& model_roi() const;
  ::autodrive::workflow::proto::perception_base::Rect* release_model_roi();
  ::autodrive::workflow::proto::perception_base::Rect* mutable_model_roi();
  void set_allocated_model_roi(::autodrive::workflow::proto::perception_base::Rect* model_roi);

  // int32 model_id = 2;
  void clear_model_id();
  static const int kModelIdFieldNumber = 2;
  ::google::protobuf::int32 model_id() const;
  void set_model_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.perception_base.RoiMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::perception_base::Rect* model_roi_;
  ::google::protobuf::int32 model_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5fbase_2eproto::TableStruct;
  friend void ::protobuf_perception_5fbase_2eproto::InitDefaultsRoiMapImpl();
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.perception_base.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 frame_id = 2;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 2;
  ::google::protobuf::int64 frame_id() const;
  void set_frame_id(::google::protobuf::int64 value);

  // int64 time_stamp = 3;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  ::google::protobuf::int64 time_stamp() const;
  void set_time_stamp(::google::protobuf::int64 value);

  // int32 cam_idx = 1;
  void clear_cam_idx();
  static const int kCamIdxFieldNumber = 1;
  ::google::protobuf::int32 cam_idx() const;
  void set_cam_idx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.perception_base.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 frame_id_;
  ::google::protobuf::int64 time_stamp_;
  ::google::protobuf::int32 cam_idx_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5fbase_2eproto::TableStruct;
  friend void ::protobuf_perception_5fbase_2eproto::InitDefaultsHeaderImpl();
};
// -------------------------------------------------------------------

class Category : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.perception_base.Category) */ {
 public:
  Category();
  virtual ~Category();

  Category(const Category& from);

  inline Category& operator=(const Category& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Category(Category&& from) noexcept
    : Category() {
    *this = ::std::move(from);
  }

  inline Category& operator=(Category&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Category& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Category* internal_default_instance() {
    return reinterpret_cast<const Category*>(
               &_Category_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Category* other);
  friend void swap(Category& a, Category& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Category* New() const PROTOBUF_FINAL { return New(NULL); }

  Category* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Category& from);
  void MergeFrom(const Category& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Category* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string property_name = 4;
  void clear_property_name();
  static const int kPropertyNameFieldNumber = 4;
  const ::std::string& property_name() const;
  void set_property_name(const ::std::string& value);
  #if LANG_CXX11
  void set_property_name(::std::string&& value);
  #endif
  void set_property_name(const char* value);
  void set_property_name(const char* value, size_t size);
  ::std::string* mutable_property_name();
  ::std::string* release_property_name();
  void set_allocated_property_name(::std::string* property_name);

  // int32 property_type = 1;
  void clear_property_type();
  static const int kPropertyTypeFieldNumber = 1;
  ::google::protobuf::int32 property_type() const;
  void set_property_type(::google::protobuf::int32 value);

  // int32 property = 2;
  void clear_property();
  static const int kPropertyFieldNumber = 2;
  ::google::protobuf::int32 property() const;
  void set_property(::google::protobuf::int32 value);

  // float property_conf = 3;
  void clear_property_conf();
  static const int kPropertyConfFieldNumber = 3;
  float property_conf() const;
  void set_property_conf(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.perception_base.Category)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr property_name_;
  ::google::protobuf::int32 property_type_;
  ::google::protobuf::int32 property_;
  float property_conf_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5fbase_2eproto::TableStruct;
  friend void ::protobuf_perception_5fbase_2eproto::InitDefaultsCategoryImpl();
};
// -------------------------------------------------------------------

class Box3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.perception_base.Box3D) */ {
 public:
  Box3D();
  virtual ~Box3D();

  Box3D(const Box3D& from);

  inline Box3D& operator=(const Box3D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Box3D(Box3D&& from) noexcept
    : Box3D() {
    *this = ::std::move(from);
  }

  inline Box3D& operator=(Box3D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Box3D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Box3D* internal_default_instance() {
    return reinterpret_cast<const Box3D*>(
               &_Box3D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Box3D* other);
  friend void swap(Box3D& a, Box3D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Box3D* New() const PROTOBUF_FINAL { return New(NULL); }

  Box3D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Box3D& from);
  void MergeFrom(const Box3D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Box3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.Vector3f lower_lt = 1;
  bool has_lower_lt() const;
  void clear_lower_lt();
  static const int kLowerLtFieldNumber = 1;
  const ::autodrive::workflow::proto::Vector3f& lower_lt() const;
  ::autodrive::workflow::proto::Vector3f* release_lower_lt();
  ::autodrive::workflow::proto::Vector3f* mutable_lower_lt();
  void set_allocated_lower_lt(::autodrive::workflow::proto::Vector3f* lower_lt);

  // .autodrive.workflow.proto.Vector3f lower_lb = 2;
  bool has_lower_lb() const;
  void clear_lower_lb();
  static const int kLowerLbFieldNumber = 2;
  const ::autodrive::workflow::proto::Vector3f& lower_lb() const;
  ::autodrive::workflow::proto::Vector3f* release_lower_lb();
  ::autodrive::workflow::proto::Vector3f* mutable_lower_lb();
  void set_allocated_lower_lb(::autodrive::workflow::proto::Vector3f* lower_lb);

  // .autodrive.workflow.proto.Vector3f lower_rb = 3;
  bool has_lower_rb() const;
  void clear_lower_rb();
  static const int kLowerRbFieldNumber = 3;
  const ::autodrive::workflow::proto::Vector3f& lower_rb() const;
  ::autodrive::workflow::proto::Vector3f* release_lower_rb();
  ::autodrive::workflow::proto::Vector3f* mutable_lower_rb();
  void set_allocated_lower_rb(::autodrive::workflow::proto::Vector3f* lower_rb);

  // .autodrive.workflow.proto.Vector3f lower_rt = 4;
  bool has_lower_rt() const;
  void clear_lower_rt();
  static const int kLowerRtFieldNumber = 4;
  const ::autodrive::workflow::proto::Vector3f& lower_rt() const;
  ::autodrive::workflow::proto::Vector3f* release_lower_rt();
  ::autodrive::workflow::proto::Vector3f* mutable_lower_rt();
  void set_allocated_lower_rt(::autodrive::workflow::proto::Vector3f* lower_rt);

  // .autodrive.workflow.proto.Vector3f upper_lt = 5;
  bool has_upper_lt() const;
  void clear_upper_lt();
  static const int kUpperLtFieldNumber = 5;
  const ::autodrive::workflow::proto::Vector3f& upper_lt() const;
  ::autodrive::workflow::proto::Vector3f* release_upper_lt();
  ::autodrive::workflow::proto::Vector3f* mutable_upper_lt();
  void set_allocated_upper_lt(::autodrive::workflow::proto::Vector3f* upper_lt);

  // .autodrive.workflow.proto.Vector3f upper_lb = 6;
  bool has_upper_lb() const;
  void clear_upper_lb();
  static const int kUpperLbFieldNumber = 6;
  const ::autodrive::workflow::proto::Vector3f& upper_lb() const;
  ::autodrive::workflow::proto::Vector3f* release_upper_lb();
  ::autodrive::workflow::proto::Vector3f* mutable_upper_lb();
  void set_allocated_upper_lb(::autodrive::workflow::proto::Vector3f* upper_lb);

  // .autodrive.workflow.proto.Vector3f upper_rb = 7;
  bool has_upper_rb() const;
  void clear_upper_rb();
  static const int kUpperRbFieldNumber = 7;
  const ::autodrive::workflow::proto::Vector3f& upper_rb() const;
  ::autodrive::workflow::proto::Vector3f* release_upper_rb();
  ::autodrive::workflow::proto::Vector3f* mutable_upper_rb();
  void set_allocated_upper_rb(::autodrive::workflow::proto::Vector3f* upper_rb);

  // .autodrive.workflow.proto.Vector3f upper_rt = 8;
  bool has_upper_rt() const;
  void clear_upper_rt();
  static const int kUpperRtFieldNumber = 8;
  const ::autodrive::workflow::proto::Vector3f& upper_rt() const;
  ::autodrive::workflow::proto::Vector3f* release_upper_rt();
  ::autodrive::workflow::proto::Vector3f* mutable_upper_rt();
  void set_allocated_upper_rt(::autodrive::workflow::proto::Vector3f* upper_rt);

  // float conf = 9;
  void clear_conf();
  static const int kConfFieldNumber = 9;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.perception_base.Box3D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::Vector3f* lower_lt_;
  ::autodrive::workflow::proto::Vector3f* lower_lb_;
  ::autodrive::workflow::proto::Vector3f* lower_rb_;
  ::autodrive::workflow::proto::Vector3f* lower_rt_;
  ::autodrive::workflow::proto::Vector3f* upper_lt_;
  ::autodrive::workflow::proto::Vector3f* upper_lb_;
  ::autodrive::workflow::proto::Vector3f* upper_rb_;
  ::autodrive::workflow::proto::Vector3f* upper_rt_;
  float conf_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5fbase_2eproto::TableStruct;
  friend void ::protobuf_perception_5fbase_2eproto::InitDefaultsBox3DImpl();
};
// -------------------------------------------------------------------

class SceneParsing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.perception_base.SceneParsing) */ {
 public:
  SceneParsing();
  virtual ~SceneParsing();

  SceneParsing(const SceneParsing& from);

  inline SceneParsing& operator=(const SceneParsing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SceneParsing(SceneParsing&& from) noexcept
    : SceneParsing() {
    *this = ::std::move(from);
  }

  inline SceneParsing& operator=(SceneParsing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneParsing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SceneParsing* internal_default_instance() {
    return reinterpret_cast<const SceneParsing*>(
               &_SceneParsing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(SceneParsing* other);
  friend void swap(SceneParsing& a, SceneParsing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SceneParsing* New() const PROTOBUF_FINAL { return New(NULL); }

  SceneParsing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SceneParsing& from);
  void MergeFrom(const SceneParsing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SceneParsing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.perception_base.ImageId image_id = 1;
  void clear_image_id();
  static const int kImageIdFieldNumber = 1;
  ::autodrive::workflow::proto::perception_base::ImageId image_id() const;
  void set_image_id(::autodrive::workflow::proto::perception_base::ImageId value);

  // .autodrive.workflow.proto.perception_base.SceneRegionType region_type = 2;
  void clear_region_type();
  static const int kRegionTypeFieldNumber = 2;
  ::autodrive::workflow::proto::perception_base::SceneRegionType region_type() const;
  void set_region_type(::autodrive::workflow::proto::perception_base::SceneRegionType value);

  // .autodrive.workflow.proto.perception_base.SceneIlluminationType illu_type = 3;
  void clear_illu_type();
  static const int kIlluTypeFieldNumber = 3;
  ::autodrive::workflow::proto::perception_base::SceneIlluminationType illu_type() const;
  void set_illu_type(::autodrive::workflow::proto::perception_base::SceneIlluminationType value);

  // .autodrive.workflow.proto.perception_base.SceneParkingType parking_type = 4;
  void clear_parking_type();
  static const int kParkingTypeFieldNumber = 4;
  ::autodrive::workflow::proto::perception_base::SceneParkingType parking_type() const;
  void set_parking_type(::autodrive::workflow::proto::perception_base::SceneParkingType value);

  // float region_conf = 5;
  void clear_region_conf();
  static const int kRegionConfFieldNumber = 5;
  float region_conf() const;
  void set_region_conf(float value);

  // float illu_conf = 6;
  void clear_illu_conf();
  static const int kIlluConfFieldNumber = 6;
  float illu_conf() const;
  void set_illu_conf(float value);

  // float parking_conf = 7;
  void clear_parking_conf();
  static const int kParkingConfFieldNumber = 7;
  float parking_conf() const;
  void set_parking_conf(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.perception_base.SceneParsing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int image_id_;
  int region_type_;
  int illu_type_;
  int parking_type_;
  float region_conf_;
  float illu_conf_;
  float parking_conf_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_5fbase_2eproto::TableStruct;
  friend void ::protobuf_perception_5fbase_2eproto::InitDefaultsSceneParsingImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Rect

// float left = 1;
inline void Rect::clear_left() {
  left_ = 0;
}
inline float Rect::left() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Rect.left)
  return left_;
}
inline void Rect::set_left(float value) {
  
  left_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Rect.left)
}

// float top = 2;
inline void Rect::clear_top() {
  top_ = 0;
}
inline float Rect::top() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Rect.top)
  return top_;
}
inline void Rect::set_top(float value) {
  
  top_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Rect.top)
}

// float right = 3;
inline void Rect::clear_right() {
  right_ = 0;
}
inline float Rect::right() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Rect.right)
  return right_;
}
inline void Rect::set_right(float value) {
  
  right_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Rect.right)
}

// float bottom = 4;
inline void Rect::clear_bottom() {
  bottom_ = 0;
}
inline float Rect::bottom() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Rect.bottom)
  return bottom_;
}
inline void Rect::set_bottom(float value) {
  
  bottom_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Rect.bottom)
}

// -------------------------------------------------------------------

// RectInt

// int32 left = 1;
inline void RectInt::clear_left() {
  left_ = 0;
}
inline ::google::protobuf::int32 RectInt::left() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.RectInt.left)
  return left_;
}
inline void RectInt::set_left(::google::protobuf::int32 value) {
  
  left_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.RectInt.left)
}

// int32 top = 2;
inline void RectInt::clear_top() {
  top_ = 0;
}
inline ::google::protobuf::int32 RectInt::top() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.RectInt.top)
  return top_;
}
inline void RectInt::set_top(::google::protobuf::int32 value) {
  
  top_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.RectInt.top)
}

// int32 right = 3;
inline void RectInt::clear_right() {
  right_ = 0;
}
inline ::google::protobuf::int32 RectInt::right() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.RectInt.right)
  return right_;
}
inline void RectInt::set_right(::google::protobuf::int32 value) {
  
  right_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.RectInt.right)
}

// int32 bottom = 4;
inline void RectInt::clear_bottom() {
  bottom_ = 0;
}
inline ::google::protobuf::int32 RectInt::bottom() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.RectInt.bottom)
  return bottom_;
}
inline void RectInt::set_bottom(::google::protobuf::int32 value) {
  
  bottom_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.RectInt.bottom)
}

// -------------------------------------------------------------------

// ImageSpace

// .autodrive.workflow.proto.perception_base.RectInt rect = 1;
inline bool ImageSpace::has_rect() const {
  return this != internal_default_instance() && rect_ != NULL;
}
inline void ImageSpace::clear_rect() {
  if (GetArenaNoVirtual() == NULL && rect_ != NULL) {
    delete rect_;
  }
  rect_ = NULL;
}
inline const ::autodrive::workflow::proto::perception_base::RectInt& ImageSpace::rect() const {
  const ::autodrive::workflow::proto::perception_base::RectInt* p = rect_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.ImageSpace.rect)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::RectInt*>(
      &::autodrive::workflow::proto::perception_base::_RectInt_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::RectInt* ImageSpace::release_rect() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.ImageSpace.rect)
  
  ::autodrive::workflow::proto::perception_base::RectInt* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::RectInt* ImageSpace::mutable_rect() {
  
  if (rect_ == NULL) {
    rect_ = new ::autodrive::workflow::proto::perception_base::RectInt;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.ImageSpace.rect)
  return rect_;
}
inline void ImageSpace::set_allocated_rect(::autodrive::workflow::proto::perception_base::RectInt* rect) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rect_;
  }
  if (rect) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rect = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rect, submessage_arena);
    }
    
  } else {
    
  }
  rect_ = rect;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.ImageSpace.rect)
}

// -------------------------------------------------------------------

// Polygon

// repeated .autodrive.workflow.proto.Vector3f polygon_points = 1;
inline int Polygon::polygon_points_size() const {
  return polygon_points_.size();
}
inline const ::autodrive::workflow::proto::Vector3f& Polygon::polygon_points(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Polygon.polygon_points)
  return polygon_points_.Get(index);
}
inline ::autodrive::workflow::proto::Vector3f* Polygon::mutable_polygon_points(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.Polygon.polygon_points)
  return polygon_points_.Mutable(index);
}
inline ::autodrive::workflow::proto::Vector3f* Polygon::add_polygon_points() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.perception_base.Polygon.polygon_points)
  return polygon_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >*
Polygon::mutable_polygon_points() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.perception_base.Polygon.polygon_points)
  return &polygon_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3f >&
Polygon::polygon_points() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.perception_base.Polygon.polygon_points)
  return polygon_points_;
}

// -------------------------------------------------------------------

// CameraMatrix

// repeated float mat_gnd2img = 1;
inline int CameraMatrix::mat_gnd2img_size() const {
  return mat_gnd2img_.size();
}
inline void CameraMatrix::clear_mat_gnd2img() {
  mat_gnd2img_.Clear();
}
inline float CameraMatrix::mat_gnd2img(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.CameraMatrix.mat_gnd2img)
  return mat_gnd2img_.Get(index);
}
inline void CameraMatrix::set_mat_gnd2img(int index, float value) {
  mat_gnd2img_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.CameraMatrix.mat_gnd2img)
}
inline void CameraMatrix::add_mat_gnd2img(float value) {
  mat_gnd2img_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.perception_base.CameraMatrix.mat_gnd2img)
}
inline const ::google::protobuf::RepeatedField< float >&
CameraMatrix::mat_gnd2img() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_gnd2img)
  return mat_gnd2img_;
}
inline ::google::protobuf::RepeatedField< float >*
CameraMatrix::mutable_mat_gnd2img() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_gnd2img)
  return &mat_gnd2img_;
}

// repeated float mat_img2gnd = 2;
inline int CameraMatrix::mat_img2gnd_size() const {
  return mat_img2gnd_.size();
}
inline void CameraMatrix::clear_mat_img2gnd() {
  mat_img2gnd_.Clear();
}
inline float CameraMatrix::mat_img2gnd(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2gnd)
  return mat_img2gnd_.Get(index);
}
inline void CameraMatrix::set_mat_img2gnd(int index, float value) {
  mat_img2gnd_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2gnd)
}
inline void CameraMatrix::add_mat_img2gnd(float value) {
  mat_img2gnd_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2gnd)
}
inline const ::google::protobuf::RepeatedField< float >&
CameraMatrix::mat_img2gnd() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2gnd)
  return mat_img2gnd_;
}
inline ::google::protobuf::RepeatedField< float >*
CameraMatrix::mutable_mat_img2gnd() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2gnd)
  return &mat_img2gnd_;
}

// repeated float mat_vcsgnd2img = 3;
inline int CameraMatrix::mat_vcsgnd2img_size() const {
  return mat_vcsgnd2img_.size();
}
inline void CameraMatrix::clear_mat_vcsgnd2img() {
  mat_vcsgnd2img_.Clear();
}
inline float CameraMatrix::mat_vcsgnd2img(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.CameraMatrix.mat_vcsgnd2img)
  return mat_vcsgnd2img_.Get(index);
}
inline void CameraMatrix::set_mat_vcsgnd2img(int index, float value) {
  mat_vcsgnd2img_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.CameraMatrix.mat_vcsgnd2img)
}
inline void CameraMatrix::add_mat_vcsgnd2img(float value) {
  mat_vcsgnd2img_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.perception_base.CameraMatrix.mat_vcsgnd2img)
}
inline const ::google::protobuf::RepeatedField< float >&
CameraMatrix::mat_vcsgnd2img() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_vcsgnd2img)
  return mat_vcsgnd2img_;
}
inline ::google::protobuf::RepeatedField< float >*
CameraMatrix::mutable_mat_vcsgnd2img() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_vcsgnd2img)
  return &mat_vcsgnd2img_;
}

// repeated float mat_img2vcsgnd = 4;
inline int CameraMatrix::mat_img2vcsgnd_size() const {
  return mat_img2vcsgnd_.size();
}
inline void CameraMatrix::clear_mat_img2vcsgnd() {
  mat_img2vcsgnd_.Clear();
}
inline float CameraMatrix::mat_img2vcsgnd(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2vcsgnd)
  return mat_img2vcsgnd_.Get(index);
}
inline void CameraMatrix::set_mat_img2vcsgnd(int index, float value) {
  mat_img2vcsgnd_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2vcsgnd)
}
inline void CameraMatrix::add_mat_img2vcsgnd(float value) {
  mat_img2vcsgnd_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2vcsgnd)
}
inline const ::google::protobuf::RepeatedField< float >&
CameraMatrix::mat_img2vcsgnd() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2vcsgnd)
  return mat_img2vcsgnd_;
}
inline ::google::protobuf::RepeatedField< float >*
CameraMatrix::mutable_mat_img2vcsgnd() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2vcsgnd)
  return &mat_img2vcsgnd_;
}

// repeated float mat_local2img = 5;
inline int CameraMatrix::mat_local2img_size() const {
  return mat_local2img_.size();
}
inline void CameraMatrix::clear_mat_local2img() {
  mat_local2img_.Clear();
}
inline float CameraMatrix::mat_local2img(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.CameraMatrix.mat_local2img)
  return mat_local2img_.Get(index);
}
inline void CameraMatrix::set_mat_local2img(int index, float value) {
  mat_local2img_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.CameraMatrix.mat_local2img)
}
inline void CameraMatrix::add_mat_local2img(float value) {
  mat_local2img_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.perception_base.CameraMatrix.mat_local2img)
}
inline const ::google::protobuf::RepeatedField< float >&
CameraMatrix::mat_local2img() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_local2img)
  return mat_local2img_;
}
inline ::google::protobuf::RepeatedField< float >*
CameraMatrix::mutable_mat_local2img() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_local2img)
  return &mat_local2img_;
}

// repeated float mat_img2local = 6;
inline int CameraMatrix::mat_img2local_size() const {
  return mat_img2local_.size();
}
inline void CameraMatrix::clear_mat_img2local() {
  mat_img2local_.Clear();
}
inline float CameraMatrix::mat_img2local(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2local)
  return mat_img2local_.Get(index);
}
inline void CameraMatrix::set_mat_img2local(int index, float value) {
  mat_img2local_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2local)
}
inline void CameraMatrix::add_mat_img2local(float value) {
  mat_img2local_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2local)
}
inline const ::google::protobuf::RepeatedField< float >&
CameraMatrix::mat_img2local() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2local)
  return mat_img2local_;
}
inline ::google::protobuf::RepeatedField< float >*
CameraMatrix::mutable_mat_img2local() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_img2local)
  return &mat_img2local_;
}

// repeated float mat_vcs2img = 7;
inline int CameraMatrix::mat_vcs2img_size() const {
  return mat_vcs2img_.size();
}
inline void CameraMatrix::clear_mat_vcs2img() {
  mat_vcs2img_.Clear();
}
inline float CameraMatrix::mat_vcs2img(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.CameraMatrix.mat_vcs2img)
  return mat_vcs2img_.Get(index);
}
inline void CameraMatrix::set_mat_vcs2img(int index, float value) {
  mat_vcs2img_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.CameraMatrix.mat_vcs2img)
}
inline void CameraMatrix::add_mat_vcs2img(float value) {
  mat_vcs2img_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.perception_base.CameraMatrix.mat_vcs2img)
}
inline const ::google::protobuf::RepeatedField< float >&
CameraMatrix::mat_vcs2img() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_vcs2img)
  return mat_vcs2img_;
}
inline ::google::protobuf::RepeatedField< float >*
CameraMatrix::mutable_mat_vcs2img() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.perception_base.CameraMatrix.mat_vcs2img)
  return &mat_vcs2img_;
}

// -------------------------------------------------------------------

// RoiMap

// .autodrive.workflow.proto.perception_base.Rect model_roi = 1;
inline bool RoiMap::has_model_roi() const {
  return this != internal_default_instance() && model_roi_ != NULL;
}
inline void RoiMap::clear_model_roi() {
  if (GetArenaNoVirtual() == NULL && model_roi_ != NULL) {
    delete model_roi_;
  }
  model_roi_ = NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Rect& RoiMap::model_roi() const {
  const ::autodrive::workflow::proto::perception_base::Rect* p = model_roi_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.RoiMap.model_roi)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Rect*>(
      &::autodrive::workflow::proto::perception_base::_Rect_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Rect* RoiMap::release_model_roi() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.RoiMap.model_roi)
  
  ::autodrive::workflow::proto::perception_base::Rect* temp = model_roi_;
  model_roi_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Rect* RoiMap::mutable_model_roi() {
  
  if (model_roi_ == NULL) {
    model_roi_ = new ::autodrive::workflow::proto::perception_base::Rect;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.RoiMap.model_roi)
  return model_roi_;
}
inline void RoiMap::set_allocated_model_roi(::autodrive::workflow::proto::perception_base::Rect* model_roi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete model_roi_;
  }
  if (model_roi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      model_roi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, model_roi, submessage_arena);
    }
    
  } else {
    
  }
  model_roi_ = model_roi;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.RoiMap.model_roi)
}

// int32 model_id = 2;
inline void RoiMap::clear_model_id() {
  model_id_ = 0;
}
inline ::google::protobuf::int32 RoiMap::model_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.RoiMap.model_id)
  return model_id_;
}
inline void RoiMap::set_model_id(::google::protobuf::int32 value) {
  
  model_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.RoiMap.model_id)
}

// -------------------------------------------------------------------

// Header

// int32 cam_idx = 1;
inline void Header::clear_cam_idx() {
  cam_idx_ = 0;
}
inline ::google::protobuf::int32 Header::cam_idx() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Header.cam_idx)
  return cam_idx_;
}
inline void Header::set_cam_idx(::google::protobuf::int32 value) {
  
  cam_idx_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Header.cam_idx)
}

// int64 frame_id = 2;
inline void Header::clear_frame_id() {
  frame_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::frame_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Header.frame_id)
  return frame_id_;
}
inline void Header::set_frame_id(::google::protobuf::int64 value) {
  
  frame_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Header.frame_id)
}

// int64 time_stamp = 3;
inline void Header::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::time_stamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Header.time_stamp)
  return time_stamp_;
}
inline void Header::set_time_stamp(::google::protobuf::int64 value) {
  
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Header.time_stamp)
}

// -------------------------------------------------------------------

// Category

// int32 property_type = 1;
inline void Category::clear_property_type() {
  property_type_ = 0;
}
inline ::google::protobuf::int32 Category::property_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Category.property_type)
  return property_type_;
}
inline void Category::set_property_type(::google::protobuf::int32 value) {
  
  property_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Category.property_type)
}

// int32 property = 2;
inline void Category::clear_property() {
  property_ = 0;
}
inline ::google::protobuf::int32 Category::property() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Category.property)
  return property_;
}
inline void Category::set_property(::google::protobuf::int32 value) {
  
  property_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Category.property)
}

// float property_conf = 3;
inline void Category::clear_property_conf() {
  property_conf_ = 0;
}
inline float Category::property_conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Category.property_conf)
  return property_conf_;
}
inline void Category::set_property_conf(float value) {
  
  property_conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Category.property_conf)
}

// string property_name = 4;
inline void Category::clear_property_name() {
  property_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Category::property_name() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Category.property_name)
  return property_name_.GetNoArena();
}
inline void Category::set_property_name(const ::std::string& value) {
  
  property_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Category.property_name)
}
#if LANG_CXX11
inline void Category::set_property_name(::std::string&& value) {
  
  property_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.perception_base.Category.property_name)
}
#endif
inline void Category::set_property_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  property_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.perception_base.Category.property_name)
}
inline void Category::set_property_name(const char* value, size_t size) {
  
  property_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.perception_base.Category.property_name)
}
inline ::std::string* Category::mutable_property_name() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.Category.property_name)
  return property_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Category::release_property_name() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.Category.property_name)
  
  return property_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Category::set_allocated_property_name(::std::string* property_name) {
  if (property_name != NULL) {
    
  } else {
    
  }
  property_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), property_name);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.Category.property_name)
}

// -------------------------------------------------------------------

// Box3D

// .autodrive.workflow.proto.Vector3f lower_lt = 1;
inline bool Box3D::has_lower_lt() const {
  return this != internal_default_instance() && lower_lt_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& Box3D::lower_lt() const {
  const ::autodrive::workflow::proto::Vector3f* p = lower_lt_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Box3D.lower_lt)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::release_lower_lt() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.Box3D.lower_lt)
  
  ::autodrive::workflow::proto::Vector3f* temp = lower_lt_;
  lower_lt_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::mutable_lower_lt() {
  
  if (lower_lt_ == NULL) {
    lower_lt_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.Box3D.lower_lt)
  return lower_lt_;
}
inline void Box3D::set_allocated_lower_lt(::autodrive::workflow::proto::Vector3f* lower_lt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lower_lt_);
  }
  if (lower_lt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lower_lt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lower_lt, submessage_arena);
    }
    
  } else {
    
  }
  lower_lt_ = lower_lt;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.Box3D.lower_lt)
}

// .autodrive.workflow.proto.Vector3f lower_lb = 2;
inline bool Box3D::has_lower_lb() const {
  return this != internal_default_instance() && lower_lb_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& Box3D::lower_lb() const {
  const ::autodrive::workflow::proto::Vector3f* p = lower_lb_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Box3D.lower_lb)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::release_lower_lb() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.Box3D.lower_lb)
  
  ::autodrive::workflow::proto::Vector3f* temp = lower_lb_;
  lower_lb_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::mutable_lower_lb() {
  
  if (lower_lb_ == NULL) {
    lower_lb_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.Box3D.lower_lb)
  return lower_lb_;
}
inline void Box3D::set_allocated_lower_lb(::autodrive::workflow::proto::Vector3f* lower_lb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lower_lb_);
  }
  if (lower_lb) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lower_lb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lower_lb, submessage_arena);
    }
    
  } else {
    
  }
  lower_lb_ = lower_lb;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.Box3D.lower_lb)
}

// .autodrive.workflow.proto.Vector3f lower_rb = 3;
inline bool Box3D::has_lower_rb() const {
  return this != internal_default_instance() && lower_rb_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& Box3D::lower_rb() const {
  const ::autodrive::workflow::proto::Vector3f* p = lower_rb_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Box3D.lower_rb)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::release_lower_rb() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.Box3D.lower_rb)
  
  ::autodrive::workflow::proto::Vector3f* temp = lower_rb_;
  lower_rb_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::mutable_lower_rb() {
  
  if (lower_rb_ == NULL) {
    lower_rb_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.Box3D.lower_rb)
  return lower_rb_;
}
inline void Box3D::set_allocated_lower_rb(::autodrive::workflow::proto::Vector3f* lower_rb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lower_rb_);
  }
  if (lower_rb) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lower_rb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lower_rb, submessage_arena);
    }
    
  } else {
    
  }
  lower_rb_ = lower_rb;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.Box3D.lower_rb)
}

// .autodrive.workflow.proto.Vector3f lower_rt = 4;
inline bool Box3D::has_lower_rt() const {
  return this != internal_default_instance() && lower_rt_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& Box3D::lower_rt() const {
  const ::autodrive::workflow::proto::Vector3f* p = lower_rt_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Box3D.lower_rt)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::release_lower_rt() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.Box3D.lower_rt)
  
  ::autodrive::workflow::proto::Vector3f* temp = lower_rt_;
  lower_rt_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::mutable_lower_rt() {
  
  if (lower_rt_ == NULL) {
    lower_rt_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.Box3D.lower_rt)
  return lower_rt_;
}
inline void Box3D::set_allocated_lower_rt(::autodrive::workflow::proto::Vector3f* lower_rt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lower_rt_);
  }
  if (lower_rt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lower_rt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lower_rt, submessage_arena);
    }
    
  } else {
    
  }
  lower_rt_ = lower_rt;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.Box3D.lower_rt)
}

// .autodrive.workflow.proto.Vector3f upper_lt = 5;
inline bool Box3D::has_upper_lt() const {
  return this != internal_default_instance() && upper_lt_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& Box3D::upper_lt() const {
  const ::autodrive::workflow::proto::Vector3f* p = upper_lt_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Box3D.upper_lt)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::release_upper_lt() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.Box3D.upper_lt)
  
  ::autodrive::workflow::proto::Vector3f* temp = upper_lt_;
  upper_lt_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::mutable_upper_lt() {
  
  if (upper_lt_ == NULL) {
    upper_lt_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.Box3D.upper_lt)
  return upper_lt_;
}
inline void Box3D::set_allocated_upper_lt(::autodrive::workflow::proto::Vector3f* upper_lt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(upper_lt_);
  }
  if (upper_lt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      upper_lt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, upper_lt, submessage_arena);
    }
    
  } else {
    
  }
  upper_lt_ = upper_lt;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.Box3D.upper_lt)
}

// .autodrive.workflow.proto.Vector3f upper_lb = 6;
inline bool Box3D::has_upper_lb() const {
  return this != internal_default_instance() && upper_lb_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& Box3D::upper_lb() const {
  const ::autodrive::workflow::proto::Vector3f* p = upper_lb_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Box3D.upper_lb)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::release_upper_lb() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.Box3D.upper_lb)
  
  ::autodrive::workflow::proto::Vector3f* temp = upper_lb_;
  upper_lb_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::mutable_upper_lb() {
  
  if (upper_lb_ == NULL) {
    upper_lb_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.Box3D.upper_lb)
  return upper_lb_;
}
inline void Box3D::set_allocated_upper_lb(::autodrive::workflow::proto::Vector3f* upper_lb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(upper_lb_);
  }
  if (upper_lb) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      upper_lb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, upper_lb, submessage_arena);
    }
    
  } else {
    
  }
  upper_lb_ = upper_lb;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.Box3D.upper_lb)
}

// .autodrive.workflow.proto.Vector3f upper_rb = 7;
inline bool Box3D::has_upper_rb() const {
  return this != internal_default_instance() && upper_rb_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& Box3D::upper_rb() const {
  const ::autodrive::workflow::proto::Vector3f* p = upper_rb_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Box3D.upper_rb)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::release_upper_rb() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.Box3D.upper_rb)
  
  ::autodrive::workflow::proto::Vector3f* temp = upper_rb_;
  upper_rb_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::mutable_upper_rb() {
  
  if (upper_rb_ == NULL) {
    upper_rb_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.Box3D.upper_rb)
  return upper_rb_;
}
inline void Box3D::set_allocated_upper_rb(::autodrive::workflow::proto::Vector3f* upper_rb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(upper_rb_);
  }
  if (upper_rb) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      upper_rb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, upper_rb, submessage_arena);
    }
    
  } else {
    
  }
  upper_rb_ = upper_rb;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.Box3D.upper_rb)
}

// .autodrive.workflow.proto.Vector3f upper_rt = 8;
inline bool Box3D::has_upper_rt() const {
  return this != internal_default_instance() && upper_rt_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3f& Box3D::upper_rt() const {
  const ::autodrive::workflow::proto::Vector3f* p = upper_rt_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Box3D.upper_rt)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3f*>(
      &::autodrive::workflow::proto::_Vector3f_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::release_upper_rt() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.perception_base.Box3D.upper_rt)
  
  ::autodrive::workflow::proto::Vector3f* temp = upper_rt_;
  upper_rt_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3f* Box3D::mutable_upper_rt() {
  
  if (upper_rt_ == NULL) {
    upper_rt_ = new ::autodrive::workflow::proto::Vector3f;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.perception_base.Box3D.upper_rt)
  return upper_rt_;
}
inline void Box3D::set_allocated_upper_rt(::autodrive::workflow::proto::Vector3f* upper_rt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(upper_rt_);
  }
  if (upper_rt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      upper_rt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, upper_rt, submessage_arena);
    }
    
  } else {
    
  }
  upper_rt_ = upper_rt;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.perception_base.Box3D.upper_rt)
}

// float conf = 9;
inline void Box3D::clear_conf() {
  conf_ = 0;
}
inline float Box3D::conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.Box3D.conf)
  return conf_;
}
inline void Box3D::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.Box3D.conf)
}

// -------------------------------------------------------------------

// SceneParsing

// .autodrive.workflow.proto.perception_base.ImageId image_id = 1;
inline void SceneParsing::clear_image_id() {
  image_id_ = 0;
}
inline ::autodrive::workflow::proto::perception_base::ImageId SceneParsing::image_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.SceneParsing.image_id)
  return static_cast< ::autodrive::workflow::proto::perception_base::ImageId >(image_id_);
}
inline void SceneParsing::set_image_id(::autodrive::workflow::proto::perception_base::ImageId value) {
  
  image_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.SceneParsing.image_id)
}

// .autodrive.workflow.proto.perception_base.SceneRegionType region_type = 2;
inline void SceneParsing::clear_region_type() {
  region_type_ = 0;
}
inline ::autodrive::workflow::proto::perception_base::SceneRegionType SceneParsing::region_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.SceneParsing.region_type)
  return static_cast< ::autodrive::workflow::proto::perception_base::SceneRegionType >(region_type_);
}
inline void SceneParsing::set_region_type(::autodrive::workflow::proto::perception_base::SceneRegionType value) {
  
  region_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.SceneParsing.region_type)
}

// .autodrive.workflow.proto.perception_base.SceneIlluminationType illu_type = 3;
inline void SceneParsing::clear_illu_type() {
  illu_type_ = 0;
}
inline ::autodrive::workflow::proto::perception_base::SceneIlluminationType SceneParsing::illu_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.SceneParsing.illu_type)
  return static_cast< ::autodrive::workflow::proto::perception_base::SceneIlluminationType >(illu_type_);
}
inline void SceneParsing::set_illu_type(::autodrive::workflow::proto::perception_base::SceneIlluminationType value) {
  
  illu_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.SceneParsing.illu_type)
}

// .autodrive.workflow.proto.perception_base.SceneParkingType parking_type = 4;
inline void SceneParsing::clear_parking_type() {
  parking_type_ = 0;
}
inline ::autodrive::workflow::proto::perception_base::SceneParkingType SceneParsing::parking_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.SceneParsing.parking_type)
  return static_cast< ::autodrive::workflow::proto::perception_base::SceneParkingType >(parking_type_);
}
inline void SceneParsing::set_parking_type(::autodrive::workflow::proto::perception_base::SceneParkingType value) {
  
  parking_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.SceneParsing.parking_type)
}

// float region_conf = 5;
inline void SceneParsing::clear_region_conf() {
  region_conf_ = 0;
}
inline float SceneParsing::region_conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.SceneParsing.region_conf)
  return region_conf_;
}
inline void SceneParsing::set_region_conf(float value) {
  
  region_conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.SceneParsing.region_conf)
}

// float illu_conf = 6;
inline void SceneParsing::clear_illu_conf() {
  illu_conf_ = 0;
}
inline float SceneParsing::illu_conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.SceneParsing.illu_conf)
  return illu_conf_;
}
inline void SceneParsing::set_illu_conf(float value) {
  
  illu_conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.SceneParsing.illu_conf)
}

// float parking_conf = 7;
inline void SceneParsing::clear_parking_conf() {
  parking_conf_ = 0;
}
inline float SceneParsing::parking_conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.perception_base.SceneParsing.parking_conf)
  return parking_conf_;
}
inline void SceneParsing::set_parking_conf(float value) {
  
  parking_conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.perception_base.SceneParsing.parking_conf)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception_base
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::perception_base::ImageId> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::perception_base::ImageId>() {
  return ::autodrive::workflow::proto::perception_base::ImageId_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::perception_base::RoiId> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::perception_base::RoiId>() {
  return ::autodrive::workflow::proto::perception_base::RoiId_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::perception_base::VehProperty> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::perception_base::VehProperty>() {
  return ::autodrive::workflow::proto::perception_base::VehProperty_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::perception_base::PedProperty> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::perception_base::PedProperty>() {
  return ::autodrive::workflow::proto::perception_base::PedProperty_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::perception_base::VehRearProperty> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::perception_base::VehRearProperty>() {
  return ::autodrive::workflow::proto::perception_base::VehRearProperty_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::perception_base::SceneRegionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::perception_base::SceneRegionType>() {
  return ::autodrive::workflow::proto::perception_base::SceneRegionType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::perception_base::SceneIlluminationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::perception_base::SceneIlluminationType>() {
  return ::autodrive::workflow::proto::perception_base::SceneIlluminationType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::perception_base::SceneParkingType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::perception_base::SceneParkingType>() {
  return ::autodrive::workflow::proto::perception_base::SceneParkingType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perception_5fbase_2eproto__INCLUDED
