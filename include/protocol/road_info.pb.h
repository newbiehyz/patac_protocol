// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: road_info.proto

#ifndef PROTOBUF_road_5finfo_2eproto__INCLUDED
#define PROTOBUF_road_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
#include "common.pb.h"
#include "perception_base.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_road_5finfo_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRoadInfoCurveLineImpl();
void InitDefaultsRoadInfoCurveLine();
void InitDefaultsBorderImpl();
void InitDefaultsBorder();
void InitDefaultsRoadBordersImpl();
void InitDefaultsRoadBorders();
void InitDefaultsTransitionPointsImpl();
void InitDefaultsTransitionPoints();
void InitDefaultsRoadInfoLineImpl();
void InitDefaultsRoadInfoLine();
void InitDefaultsHighWayJunctionInfoImpl();
void InitDefaultsHighWayJunctionInfo();
void InitDefaultsNumberOfLanesImpl();
void InitDefaultsNumberOfLanes();
void InitDefaultsRoadInfoLinesImpl();
void InitDefaultsRoadInfoLines();
void InitDefaultsStopLinesImpl();
void InitDefaultsStopLines();
void InitDefaultsCrossingsImpl();
void InitDefaultsCrossings();
void InitDefaultsRoadInfoMsgImpl();
void InitDefaultsRoadInfoMsg();
inline void InitDefaults() {
  InitDefaultsRoadInfoCurveLine();
  InitDefaultsBorder();
  InitDefaultsRoadBorders();
  InitDefaultsTransitionPoints();
  InitDefaultsRoadInfoLine();
  InitDefaultsHighWayJunctionInfo();
  InitDefaultsNumberOfLanes();
  InitDefaultsRoadInfoLines();
  InitDefaultsStopLines();
  InitDefaultsCrossings();
  InitDefaultsRoadInfoMsg();
}
}  // namespace protobuf_road_5finfo_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
class Border;
class BorderDefaultTypeInternal;
extern BorderDefaultTypeInternal _Border_default_instance_;
class Crossings;
class CrossingsDefaultTypeInternal;
extern CrossingsDefaultTypeInternal _Crossings_default_instance_;
class HighWayJunctionInfo;
class HighWayJunctionInfoDefaultTypeInternal;
extern HighWayJunctionInfoDefaultTypeInternal _HighWayJunctionInfo_default_instance_;
class NumberOfLanes;
class NumberOfLanesDefaultTypeInternal;
extern NumberOfLanesDefaultTypeInternal _NumberOfLanes_default_instance_;
class RoadBorders;
class RoadBordersDefaultTypeInternal;
extern RoadBordersDefaultTypeInternal _RoadBorders_default_instance_;
class RoadInfoCurveLine;
class RoadInfoCurveLineDefaultTypeInternal;
extern RoadInfoCurveLineDefaultTypeInternal _RoadInfoCurveLine_default_instance_;
class RoadInfoLine;
class RoadInfoLineDefaultTypeInternal;
extern RoadInfoLineDefaultTypeInternal _RoadInfoLine_default_instance_;
class RoadInfoLines;
class RoadInfoLinesDefaultTypeInternal;
extern RoadInfoLinesDefaultTypeInternal _RoadInfoLines_default_instance_;
class RoadInfoMsg;
class RoadInfoMsgDefaultTypeInternal;
extern RoadInfoMsgDefaultTypeInternal _RoadInfoMsg_default_instance_;
class StopLines;
class StopLinesDefaultTypeInternal;
extern StopLinesDefaultTypeInternal _StopLines_default_instance_;
class TransitionPoints;
class TransitionPointsDefaultTypeInternal;
extern TransitionPointsDefaultTypeInternal _TransitionPoints_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {

enum RoadInfoLines_DrivingSide {
  RoadInfoLines_DrivingSide_kDrivingSideLeftSide = 0,
  RoadInfoLines_DrivingSide_kDrivingSideRightSide = 1,
  RoadInfoLines_DrivingSide_RoadInfoLines_DrivingSide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadInfoLines_DrivingSide_RoadInfoLines_DrivingSide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadInfoLines_DrivingSide_IsValid(int value);
const RoadInfoLines_DrivingSide RoadInfoLines_DrivingSide_DrivingSide_MIN = RoadInfoLines_DrivingSide_kDrivingSideLeftSide;
const RoadInfoLines_DrivingSide RoadInfoLines_DrivingSide_DrivingSide_MAX = RoadInfoLines_DrivingSide_kDrivingSideRightSide;
const int RoadInfoLines_DrivingSide_DrivingSide_ARRAYSIZE = RoadInfoLines_DrivingSide_DrivingSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadInfoLines_DrivingSide_descriptor();
inline const ::std::string& RoadInfoLines_DrivingSide_Name(RoadInfoLines_DrivingSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadInfoLines_DrivingSide_descriptor(), value);
}
inline bool RoadInfoLines_DrivingSide_Parse(
    const ::std::string& name, RoadInfoLines_DrivingSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadInfoLines_DrivingSide>(
    RoadInfoLines_DrivingSide_descriptor(), name, value);
}
enum RoadBorderSide {
  kRoadBorderSideLeftEdge = 0,
  kRoadBorderSideRightEdge = 1,
  RoadBorderSide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadBorderSide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadBorderSide_IsValid(int value);
const RoadBorderSide RoadBorderSide_MIN = kRoadBorderSideLeftEdge;
const RoadBorderSide RoadBorderSide_MAX = kRoadBorderSideRightEdge;
const int RoadBorderSide_ARRAYSIZE = RoadBorderSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadBorderSide_descriptor();
inline const ::std::string& RoadBorderSide_Name(RoadBorderSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadBorderSide_descriptor(), value);
}
inline bool RoadBorderSide_Parse(
    const ::std::string& name, RoadBorderSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadBorderSide>(
    RoadBorderSide_descriptor(), name, value);
}
enum RoadBorderType {
  kRoadBorderTypeCurb = 0,
  kRoadBorderTypeRoadEdge = 1,
  kRoadBorderTypeBarrier = 2,
  kRoadBorderTypeCone = 3,
  kRoadBorderTypeParkedCars = 4,
  kRoadBorderTypeWall = 5,
  kRoadBorderTypeGuardRail = 6,
  kRoadBorderTypeOther = 7,
  RoadBorderType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadBorderType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadBorderType_IsValid(int value);
const RoadBorderType RoadBorderType_MIN = kRoadBorderTypeCurb;
const RoadBorderType RoadBorderType_MAX = kRoadBorderTypeOther;
const int RoadBorderType_ARRAYSIZE = RoadBorderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadBorderType_descriptor();
inline const ::std::string& RoadBorderType_Name(RoadBorderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadBorderType_descriptor(), value);
}
inline bool RoadBorderType_Parse(
    const ::std::string& name, RoadBorderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadBorderType>(
    RoadBorderType_descriptor(), name, value);
}
enum RoadInfoLineSource {
  kRoadConfNotAvailable = 0,
  kRoadConfPredicted = 1,
  kRoadConfDetected = 2,
  RoadInfoLineSource_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadInfoLineSource_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadInfoLineSource_IsValid(int value);
const RoadInfoLineSource RoadInfoLineSource_MIN = kRoadConfNotAvailable;
const RoadInfoLineSource RoadInfoLineSource_MAX = kRoadConfDetected;
const int RoadInfoLineSource_ARRAYSIZE = RoadInfoLineSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadInfoLineSource_descriptor();
inline const ::std::string& RoadInfoLineSource_Name(RoadInfoLineSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadInfoLineSource_descriptor(), value);
}
inline bool RoadInfoLineSource_Parse(
    const ::std::string& name, RoadInfoLineSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadInfoLineSource>(
    RoadInfoLineSource_descriptor(), name, value);
}
enum RoadInfoCurveType {
  kCurveTypeUnknown = 0,
  kCurveTypeAdas = 2,
  kCurveTypeCubic = 4,
  kCurveTypeBezier = 8,
  RoadInfoCurveType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadInfoCurveType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadInfoCurveType_IsValid(int value);
const RoadInfoCurveType RoadInfoCurveType_MIN = kCurveTypeUnknown;
const RoadInfoCurveType RoadInfoCurveType_MAX = kCurveTypeBezier;
const int RoadInfoCurveType_ARRAYSIZE = RoadInfoCurveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadInfoCurveType_descriptor();
inline const ::std::string& RoadInfoCurveType_Name(RoadInfoCurveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadInfoCurveType_descriptor(), value);
}
inline bool RoadInfoCurveType_Parse(
    const ::std::string& name, RoadInfoCurveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadInfoCurveType>(
    RoadInfoCurveType_descriptor(), name, value);
}
enum RoadInfoLineType {
  kLineTypeUndecided = 0,
  kLineTypeSolidLine = 1,
  kLineTypeDashedLine = 2,
  kLineTypeDoubleLine = 3,
  kLineTypeDecelerationLine = 4,
  kLineTypeBotts = 5,
  kLineTypeHOV = 6,
  RoadInfoLineType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadInfoLineType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadInfoLineType_IsValid(int value);
const RoadInfoLineType RoadInfoLineType_MIN = kLineTypeUndecided;
const RoadInfoLineType RoadInfoLineType_MAX = kLineTypeHOV;
const int RoadInfoLineType_ARRAYSIZE = RoadInfoLineType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadInfoLineType_descriptor();
inline const ::std::string& RoadInfoLineType_Name(RoadInfoLineType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadInfoLineType_descriptor(), value);
}
inline bool RoadInfoLineType_Parse(
    const ::std::string& name, RoadInfoLineType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadInfoLineType>(
    RoadInfoLineType_descriptor(), name, value);
}
enum DlmType {
  kDlmNotDlm = 0,
  kDlmSolidDashed = 1,
  kDlmDashedSolid = 2,
  kDlmSolidSolid = 3,
  kDlmDashedDashed = 4,
  kDlmUndecided = 5,
  DlmType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DlmType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DlmType_IsValid(int value);
const DlmType DlmType_MIN = kDlmNotDlm;
const DlmType DlmType_MAX = kDlmUndecided;
const int DlmType_ARRAYSIZE = DlmType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DlmType_descriptor();
inline const ::std::string& DlmType_Name(DlmType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DlmType_descriptor(), value);
}
inline bool DlmType_Parse(
    const ::std::string& name, DlmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DlmType>(
    DlmType_descriptor(), name, value);
}
enum DecelType {
  kDecelNotDecel = 0,
  kDecelSolid = 1,
  kDecelDashed = 2,
  kDecelUndecided = 3,
  kDecelInvalid = 4,
  DecelType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DecelType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DecelType_IsValid(int value);
const DecelType DecelType_MIN = kDecelNotDecel;
const DecelType DecelType_MAX = kDecelInvalid;
const int DecelType_ARRAYSIZE = DecelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DecelType_descriptor();
inline const ::std::string& DecelType_Name(DecelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DecelType_descriptor(), value);
}
inline bool DecelType_Parse(
    const ::std::string& name, DecelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DecelType>(
    DecelType_descriptor(), name, value);
}
enum RoadInfoLineColor {
  kLineColorUnknown = 0,
  kLineColorWhite = 1,
  kLineColorYellow = 2,
  kLineColorBlue = 3,
  kLineColorGreen = 4,
  RoadInfoLineColor_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadInfoLineColor_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadInfoLineColor_IsValid(int value);
const RoadInfoLineColor RoadInfoLineColor_MIN = kLineColorUnknown;
const RoadInfoLineColor RoadInfoLineColor_MAX = kLineColorGreen;
const int RoadInfoLineColor_ARRAYSIZE = RoadInfoLineColor_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadInfoLineColor_descriptor();
inline const ::std::string& RoadInfoLineColor_Name(RoadInfoLineColor value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadInfoLineColor_descriptor(), value);
}
inline bool RoadInfoLineColor_Parse(
    const ::std::string& name, RoadInfoLineColor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadInfoLineColor>(
    RoadInfoLineColor_descriptor(), name, value);
}
enum RoadInfoLinePosition {
  kLinePositionUnknown = 0,
  kLinePositionLeft = 1,
  kLinePositionRight = 2,
  kLinePositionLeftLeft = 3,
  kLinePositionRightRight = 4,
  kLinePositionLeftOutside = 5,
  kLinePositionRightOutside = 6,
  kLinePositionLeftRight = 7,
  kLinePositionRightLeft = 8,
  kLinePositionLeftLeftLeft = 9,
  kLinePositionRightRightRight = 10,
  RoadInfoLinePosition_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadInfoLinePosition_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadInfoLinePosition_IsValid(int value);
const RoadInfoLinePosition RoadInfoLinePosition_MIN = kLinePositionUnknown;
const RoadInfoLinePosition RoadInfoLinePosition_MAX = kLinePositionRightRightRight;
const int RoadInfoLinePosition_ARRAYSIZE = RoadInfoLinePosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadInfoLinePosition_descriptor();
inline const ::std::string& RoadInfoLinePosition_Name(RoadInfoLinePosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadInfoLinePosition_descriptor(), value);
}
inline bool RoadInfoLinePosition_Parse(
    const ::std::string& name, RoadInfoLinePosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadInfoLinePosition>(
    RoadInfoLinePosition_descriptor(), name, value);
}
enum TransitionType {
  kTransitionTypeSplit = 0,
  kTransitionTypeMerge = 1,
  kTransitionTypeExit = 2,
  TransitionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TransitionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TransitionType_IsValid(int value);
const TransitionType TransitionType_MIN = kTransitionTypeSplit;
const TransitionType TransitionType_MAX = kTransitionTypeExit;
const int TransitionType_ARRAYSIZE = TransitionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransitionType_descriptor();
inline const ::std::string& TransitionType_Name(TransitionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransitionType_descriptor(), value);
}
inline bool TransitionType_Parse(
    const ::std::string& name, TransitionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransitionType>(
    TransitionType_descriptor(), name, value);
}
enum StopLineStatus {
  kStopLineStatusUnknown = 0,
  kStopLineStatusInImage = 1,
  kStopLineStatusPredicted = 2,
  StopLineStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StopLineStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StopLineStatus_IsValid(int value);
const StopLineStatus StopLineStatus_MIN = kStopLineStatusUnknown;
const StopLineStatus StopLineStatus_MAX = kStopLineStatusPredicted;
const int StopLineStatus_ARRAYSIZE = StopLineStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* StopLineStatus_descriptor();
inline const ::std::string& StopLineStatus_Name(StopLineStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    StopLineStatus_descriptor(), value);
}
inline bool StopLineStatus_Parse(
    const ::std::string& name, StopLineStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StopLineStatus>(
    StopLineStatus_descriptor(), name, value);
}
enum StopLineType {
  kStopLineTypeStopLine = 0,
  kStopLineTypeDashedStopLine = 1,
  kStopLineTypeDoubleStopLine = 2,
  kStopLineTypeDashedSolidStopLine = 3,
  kStopLineTypeSolidDashedStopLine = 4,
  kStopLineTypeDoubleDashedStopLine = 5,
  kStopLineTypeTriangularStopLine = 6,
  StopLineType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StopLineType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StopLineType_IsValid(int value);
const StopLineType StopLineType_MIN = kStopLineTypeStopLine;
const StopLineType StopLineType_MAX = kStopLineTypeTriangularStopLine;
const int StopLineType_ARRAYSIZE = StopLineType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StopLineType_descriptor();
inline const ::std::string& StopLineType_Name(StopLineType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StopLineType_descriptor(), value);
}
inline bool StopLineType_Parse(
    const ::std::string& name, StopLineType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StopLineType>(
    StopLineType_descriptor(), name, value);
}
enum StopLineColorType {
  kStopLineColorTypeGreenBlue = 0,
  kStopLineColorTypeWhite = 1,
  kStopLineColorTypeYellowOrangeRed = 2,
  StopLineColorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StopLineColorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StopLineColorType_IsValid(int value);
const StopLineColorType StopLineColorType_MIN = kStopLineColorTypeGreenBlue;
const StopLineColorType StopLineColorType_MAX = kStopLineColorTypeYellowOrangeRed;
const int StopLineColorType_ARRAYSIZE = StopLineColorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StopLineColorType_descriptor();
inline const ::std::string& StopLineColorType_Name(StopLineColorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StopLineColorType_descriptor(), value);
}
inline bool StopLineColorType_Parse(
    const ::std::string& name, StopLineColorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StopLineColorType>(
    StopLineColorType_descriptor(), name, value);
}
enum CrossingsType {
  kRoadSolidCrossing = 0,
  kRoadZebraCrossing = 1,
  kRoadDashedCrossing = 2,
  CrossingsType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CrossingsType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CrossingsType_IsValid(int value);
const CrossingsType CrossingsType_MIN = kRoadSolidCrossing;
const CrossingsType CrossingsType_MAX = kRoadDashedCrossing;
const int CrossingsType_ARRAYSIZE = CrossingsType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CrossingsType_descriptor();
inline const ::std::string& CrossingsType_Name(CrossingsType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CrossingsType_descriptor(), value);
}
inline bool CrossingsType_Parse(
    const ::std::string& name, CrossingsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CrossingsType>(
    CrossingsType_descriptor(), name, value);
}
enum LaneChange {
  kLaneChangeNoChange = 0,
  kLaneChangeToLeft = 1,
  kLaneChangeToRight = 2,
  kLaneChangeToUnknown = 3,
  LaneChange_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LaneChange_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LaneChange_IsValid(int value);
const LaneChange LaneChange_MIN = kLaneChangeNoChange;
const LaneChange LaneChange_MAX = kLaneChangeToUnknown;
const int LaneChange_ARRAYSIZE = LaneChange_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneChange_descriptor();
inline const ::std::string& LaneChange_Name(LaneChange value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneChange_descriptor(), value);
}
inline bool LaneChange_Parse(
    const ::std::string& name, LaneChange* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneChange>(
    LaneChange_descriptor(), name, value);
}
enum LineRole {
  kLineRoleUnknown = 0,
  kLineRoleLeft = 1,
  kLineRoleRight = 2,
  kLineRoleLeftLeft = 3,
  kLineRoleRightRight = 4,
  kLineRoleLeftEdge = 5,
  kLineRoleRightEdge = 6,
  LineRole_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LineRole_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LineRole_IsValid(int value);
const LineRole LineRole_MIN = kLineRoleUnknown;
const LineRole LineRole_MAX = kLineRoleRightEdge;
const int LineRole_ARRAYSIZE = LineRole_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineRole_descriptor();
inline const ::std::string& LineRole_Name(LineRole value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineRole_descriptor(), value);
}
inline bool LineRole_Parse(
    const ::std::string& name, LineRole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineRole>(
    LineRole_descriptor(), name, value);
}
enum TriggerModel {
  kTriggerModelNotAvailable = 0,
  kTriggerModelTriggered = 1,
  kTriggerModelNotTriggered = 2,
  TriggerModel_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TriggerModel_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TriggerModel_IsValid(int value);
const TriggerModel TriggerModel_MIN = kTriggerModelNotAvailable;
const TriggerModel TriggerModel_MAX = kTriggerModelNotTriggered;
const int TriggerModel_ARRAYSIZE = TriggerModel_MAX + 1;

const ::google::protobuf::EnumDescriptor* TriggerModel_descriptor();
inline const ::std::string& TriggerModel_Name(TriggerModel value) {
  return ::google::protobuf::internal::NameOfEnum(
    TriggerModel_descriptor(), value);
}
inline bool TriggerModel_Parse(
    const ::std::string& name, TriggerModel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TriggerModel>(
    TriggerModel_descriptor(), name, value);
}
// ===================================================================

class RoadInfoCurveLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.RoadInfoCurveLine) */ {
 public:
  RoadInfoCurveLine();
  virtual ~RoadInfoCurveLine();

  RoadInfoCurveLine(const RoadInfoCurveLine& from);

  inline RoadInfoCurveLine& operator=(const RoadInfoCurveLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadInfoCurveLine(RoadInfoCurveLine&& from) noexcept
    : RoadInfoCurveLine() {
    *this = ::std::move(from);
  }

  inline RoadInfoCurveLine& operator=(RoadInfoCurveLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadInfoCurveLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadInfoCurveLine* internal_default_instance() {
    return reinterpret_cast<const RoadInfoCurveLine*>(
               &_RoadInfoCurveLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RoadInfoCurveLine* other);
  friend void swap(RoadInfoCurveLine& a, RoadInfoCurveLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadInfoCurveLine* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadInfoCurveLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadInfoCurveLine& from);
  void MergeFrom(const RoadInfoCurveLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadInfoCurveLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.Vector3d points = 5;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 5;
  const ::autodrive::workflow::proto::Vector3d& points(int index) const;
  ::autodrive::workflow::proto::Vector3d* mutable_points(int index);
  ::autodrive::workflow::proto::Vector3d* add_points();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3d >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3d >&
      points() const;

  // repeated double t = 6;
  int t_size() const;
  void clear_t();
  static const int kTFieldNumber = 6;
  double t(int index) const;
  void set_t(int index, double value);
  void add_t(double value);
  const ::google::protobuf::RepeatedField< double >&
      t() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_t();

  // repeated double x_coeff = 9;
  int x_coeff_size() const;
  void clear_x_coeff();
  static const int kXCoeffFieldNumber = 9;
  double x_coeff(int index) const;
  void set_x_coeff(int index, double value);
  void add_x_coeff(double value);
  const ::google::protobuf::RepeatedField< double >&
      x_coeff() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_x_coeff();

  // repeated double y_coeff = 10;
  int y_coeff_size() const;
  void clear_y_coeff();
  static const int kYCoeffFieldNumber = 10;
  double y_coeff(int index) const;
  void set_y_coeff(int index, double value);
  void add_y_coeff(double value);
  const ::google::protobuf::RepeatedField< double >&
      y_coeff() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_y_coeff();

  // .autodrive.workflow.proto.Vector3d start_pt = 8;
  bool has_start_pt() const;
  void clear_start_pt();
  static const int kStartPtFieldNumber = 8;
  const ::autodrive::workflow::proto::Vector3d& start_pt() const;
  ::autodrive::workflow::proto::Vector3d* release_start_pt();
  ::autodrive::workflow::proto::Vector3d* mutable_start_pt();
  void set_allocated_start_pt(::autodrive::workflow::proto::Vector3d* start_pt);

  // float start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  float start() const;
  void set_start(float value);

  // float end = 2;
  void clear_end();
  static const int kEndFieldNumber = 2;
  float end() const;
  void set_end(float value);

  // float rmse = 3;
  void clear_rmse();
  static const int kRmseFieldNumber = 3;
  float rmse() const;
  void set_rmse(float value);

  // .autodrive.workflow.proto.RoadInfoCurveType type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::autodrive::workflow::proto::RoadInfoCurveType type() const;
  void set_type(::autodrive::workflow::proto::RoadInfoCurveType value);

  // double t_max = 7;
  void clear_t_max();
  static const int kTMaxFieldNumber = 7;
  double t_max() const;
  void set_t_max(double value);

  // float length = 11;
  void clear_length();
  static const int kLengthFieldNumber = 11;
  float length() const;
  void set_length(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.RoadInfoCurveLine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3d > points_;
  ::google::protobuf::RepeatedField< double > t_;
  mutable int _t_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > x_coeff_;
  mutable int _x_coeff_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > y_coeff_;
  mutable int _y_coeff_cached_byte_size_;
  ::autodrive::workflow::proto::Vector3d* start_pt_;
  float start_;
  float end_;
  float rmse_;
  int type_;
  double t_max_;
  float length_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoCurveLineImpl();
};
// -------------------------------------------------------------------

class Border : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.Border) */ {
 public:
  Border();
  virtual ~Border();

  Border(const Border& from);

  inline Border& operator=(const Border& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Border(Border&& from) noexcept
    : Border() {
    *this = ::std::move(from);
  }

  inline Border& operator=(Border&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Border& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Border* internal_default_instance() {
    return reinterpret_cast<const Border*>(
               &_Border_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Border* other);
  friend void swap(Border& a, Border& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Border* New() const PROTOBUF_FINAL { return New(NULL); }

  Border* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Border& from);
  void MergeFrom(const Border& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Border* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.RoadInfoCurveLine curve = 4;
  bool has_curve() const;
  void clear_curve();
  static const int kCurveFieldNumber = 4;
  const ::autodrive::workflow::proto::RoadInfoCurveLine& curve() const;
  ::autodrive::workflow::proto::RoadInfoCurveLine* release_curve();
  ::autodrive::workflow::proto::RoadInfoCurveLine* mutable_curve();
  void set_allocated_curve(::autodrive::workflow::proto::RoadInfoCurveLine* curve);

  // .autodrive.workflow.proto.RoadBorderSide border_side = 1;
  void clear_border_side();
  static const int kBorderSideFieldNumber = 1;
  ::autodrive::workflow::proto::RoadBorderSide border_side() const;
  void set_border_side(::autodrive::workflow::proto::RoadBorderSide value);

  // .autodrive.workflow.proto.RoadBorderType border_type = 2;
  void clear_border_type();
  static const int kBorderTypeFieldNumber = 2;
  ::autodrive::workflow::proto::RoadBorderType border_type() const;
  void set_border_type(::autodrive::workflow::proto::RoadBorderType value);

  // .autodrive.workflow.proto.RoadInfoLineSource conf_level = 3;
  void clear_conf_level();
  static const int kConfLevelFieldNumber = 3;
  ::autodrive::workflow::proto::RoadInfoLineSource conf_level() const;
  void set_conf_level(::autodrive::workflow::proto::RoadInfoLineSource value);

  // float conf = 5;
  void clear_conf();
  static const int kConfFieldNumber = 5;
  float conf() const;
  void set_conf(float value);

  // float border_height = 6;
  void clear_border_height();
  static const int kBorderHeightFieldNumber = 6;
  float border_height() const;
  void set_border_height(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.Border)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::RoadInfoCurveLine* curve_;
  int border_side_;
  int border_type_;
  int conf_level_;
  float conf_;
  float border_height_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsBorderImpl();
};
// -------------------------------------------------------------------

class RoadBorders : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.RoadBorders) */ {
 public:
  RoadBorders();
  virtual ~RoadBorders();

  RoadBorders(const RoadBorders& from);

  inline RoadBorders& operator=(const RoadBorders& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadBorders(RoadBorders&& from) noexcept
    : RoadBorders() {
    *this = ::std::move(from);
  }

  inline RoadBorders& operator=(RoadBorders&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadBorders& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadBorders* internal_default_instance() {
    return reinterpret_cast<const RoadBorders*>(
               &_RoadBorders_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RoadBorders* other);
  friend void swap(RoadBorders& a, RoadBorders& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadBorders* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadBorders* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadBorders& from);
  void MergeFrom(const RoadBorders& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadBorders* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.Border borders = 1;
  int borders_size() const;
  void clear_borders();
  static const int kBordersFieldNumber = 1;
  const ::autodrive::workflow::proto::Border& borders(int index) const;
  ::autodrive::workflow::proto::Border* mutable_borders(int index);
  ::autodrive::workflow::proto::Border* add_borders();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Border >*
      mutable_borders();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Border >&
      borders() const;

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.RoadBorders)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Border > borders_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsRoadBordersImpl();
};
// -------------------------------------------------------------------

class TransitionPoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.TransitionPoints) */ {
 public:
  TransitionPoints();
  virtual ~TransitionPoints();

  TransitionPoints(const TransitionPoints& from);

  inline TransitionPoints& operator=(const TransitionPoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransitionPoints(TransitionPoints&& from) noexcept
    : TransitionPoints() {
    *this = ::std::move(from);
  }

  inline TransitionPoints& operator=(TransitionPoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransitionPoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransitionPoints* internal_default_instance() {
    return reinterpret_cast<const TransitionPoints*>(
               &_TransitionPoints_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TransitionPoints* other);
  friend void swap(TransitionPoints& a, TransitionPoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransitionPoints* New() const PROTOBUF_FINAL { return New(NULL); }

  TransitionPoints* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransitionPoints& from);
  void MergeFrom(const TransitionPoints& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransitionPoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float long_position = 1;
  void clear_long_position();
  static const int kLongPositionFieldNumber = 1;
  float long_position() const;
  void set_long_position(float value);

  // float lat_position = 2;
  void clear_lat_position();
  static const int kLatPositionFieldNumber = 2;
  float lat_position() const;
  void set_lat_position(float value);

  // float prob = 3;
  void clear_prob();
  static const int kProbFieldNumber = 3;
  float prob() const;
  void set_prob(float value);

  // .autodrive.workflow.proto.TransitionType type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::autodrive::workflow::proto::TransitionType type() const;
  void set_type(::autodrive::workflow::proto::TransitionType value);

  // .autodrive.workflow.proto.LineRole relate_line = 5;
  void clear_relate_line();
  static const int kRelateLineFieldNumber = 5;
  ::autodrive::workflow::proto::LineRole relate_line() const;
  void set_relate_line(::autodrive::workflow::proto::LineRole value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.TransitionPoints)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float long_position_;
  float lat_position_;
  float prob_;
  int type_;
  int relate_line_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsTransitionPointsImpl();
};
// -------------------------------------------------------------------

class RoadInfoLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.RoadInfoLine) */ {
 public:
  RoadInfoLine();
  virtual ~RoadInfoLine();

  RoadInfoLine(const RoadInfoLine& from);

  inline RoadInfoLine& operator=(const RoadInfoLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadInfoLine(RoadInfoLine&& from) noexcept
    : RoadInfoLine() {
    *this = ::std::move(from);
  }

  inline RoadInfoLine& operator=(RoadInfoLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadInfoLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadInfoLine* internal_default_instance() {
    return reinterpret_cast<const RoadInfoLine*>(
               &_RoadInfoLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RoadInfoLine* other);
  friend void swap(RoadInfoLine& a, RoadInfoLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadInfoLine* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadInfoLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadInfoLine& from);
  void MergeFrom(const RoadInfoLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadInfoLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.RoadInfoCurveLine curve_segs = 3;
  int curve_segs_size() const;
  void clear_curve_segs();
  static const int kCurveSegsFieldNumber = 3;
  const ::autodrive::workflow::proto::RoadInfoCurveLine& curve_segs(int index) const;
  ::autodrive::workflow::proto::RoadInfoCurveLine* mutable_curve_segs(int index);
  ::autodrive::workflow::proto::RoadInfoCurveLine* add_curve_segs();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RoadInfoCurveLine >*
      mutable_curve_segs();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RoadInfoCurveLine >&
      curve_segs() const;

  // string str_id = 2;
  void clear_str_id();
  static const int kStrIdFieldNumber = 2;
  const ::std::string& str_id() const;
  void set_str_id(const ::std::string& value);
  #if LANG_CXX11
  void set_str_id(::std::string&& value);
  #endif
  void set_str_id(const char* value);
  void set_str_id(const char* value, size_t size);
  ::std::string* mutable_str_id();
  ::std::string* release_str_id();
  void set_allocated_str_id(::std::string* str_id);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 life_time = 4;
  void clear_life_time();
  static const int kLifeTimeFieldNumber = 4;
  ::google::protobuf::int32 life_time() const;
  void set_life_time(::google::protobuf::int32 value);

  // float start = 5;
  void clear_start();
  static const int kStartFieldNumber = 5;
  float start() const;
  void set_start(float value);

  // float end = 6;
  void clear_end();
  static const int kEndFieldNumber = 6;
  float end() const;
  void set_end(float value);

  // float conf = 7;
  void clear_conf();
  static const int kConfFieldNumber = 7;
  float conf() const;
  void set_conf(float value);

  // float width = 8;
  void clear_width();
  static const int kWidthFieldNumber = 8;
  float width() const;
  void set_width(float value);

  // .autodrive.workflow.proto.RoadInfoLinePosition position = 9;
  void clear_position();
  static const int kPositionFieldNumber = 9;
  ::autodrive::workflow::proto::RoadInfoLinePosition position() const;
  void set_position(::autodrive::workflow::proto::RoadInfoLinePosition value);

  // .autodrive.workflow.proto.RoadInfoLineSource conf_level = 10;
  void clear_conf_level();
  static const int kConfLevelFieldNumber = 10;
  ::autodrive::workflow::proto::RoadInfoLineSource conf_level() const;
  void set_conf_level(::autodrive::workflow::proto::RoadInfoLineSource value);

  // .autodrive.workflow.proto.RoadInfoLineColor line_color = 11;
  void clear_line_color();
  static const int kLineColorFieldNumber = 11;
  ::autodrive::workflow::proto::RoadInfoLineColor line_color() const;
  void set_line_color(::autodrive::workflow::proto::RoadInfoLineColor value);

  // .autodrive.workflow.proto.RoadInfoLineType type = 12;
  void clear_type();
  static const int kTypeFieldNumber = 12;
  ::autodrive::workflow::proto::RoadInfoLineType type() const;
  void set_type(::autodrive::workflow::proto::RoadInfoLineType value);

  // .autodrive.workflow.proto.DlmType dlm_type = 13;
  void clear_dlm_type();
  static const int kDlmTypeFieldNumber = 13;
  ::autodrive::workflow::proto::DlmType dlm_type() const;
  void set_dlm_type(::autodrive::workflow::proto::DlmType value);

  // .autodrive.workflow.proto.DecelType decel_type = 14;
  void clear_decel_type();
  static const int kDecelTypeFieldNumber = 14;
  ::autodrive::workflow::proto::DecelType decel_type() const;
  void set_decel_type(::autodrive::workflow::proto::DecelType value);

  // uint32 road_prediction = 15;
  void clear_road_prediction();
  static const int kRoadPredictionFieldNumber = 15;
  ::google::protobuf::uint32 road_prediction() const;
  void set_road_prediction(::google::protobuf::uint32 value);

  // float length = 16;
  void clear_length();
  static const int kLengthFieldNumber = 16;
  float length() const;
  void set_length(float value);

  // .autodrive.workflow.proto.TriggerModel triggered_model = 17;
  void clear_triggered_model();
  static const int kTriggeredModelFieldNumber = 17;
  ::autodrive::workflow::proto::TriggerModel triggered_model() const;
  void set_triggered_model(::autodrive::workflow::proto::TriggerModel value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.RoadInfoLine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RoadInfoCurveLine > curve_segs_;
  ::google::protobuf::internal::ArenaStringPtr str_id_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 life_time_;
  float start_;
  float end_;
  float conf_;
  float width_;
  int position_;
  int conf_level_;
  int line_color_;
  int type_;
  int dlm_type_;
  int decel_type_;
  ::google::protobuf::uint32 road_prediction_;
  float length_;
  int triggered_model_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoLineImpl();
};
// -------------------------------------------------------------------

class HighWayJunctionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.HighWayJunctionInfo) */ {
 public:
  HighWayJunctionInfo();
  virtual ~HighWayJunctionInfo();

  HighWayJunctionInfo(const HighWayJunctionInfo& from);

  inline HighWayJunctionInfo& operator=(const HighWayJunctionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HighWayJunctionInfo(HighWayJunctionInfo&& from) noexcept
    : HighWayJunctionInfo() {
    *this = ::std::move(from);
  }

  inline HighWayJunctionInfo& operator=(HighWayJunctionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HighWayJunctionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HighWayJunctionInfo* internal_default_instance() {
    return reinterpret_cast<const HighWayJunctionInfo*>(
               &_HighWayJunctionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(HighWayJunctionInfo* other);
  friend void swap(HighWayJunctionInfo& a, HighWayJunctionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HighWayJunctionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  HighWayJunctionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HighWayJunctionInfo& from);
  void MergeFrom(const HighWayJunctionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HighWayJunctionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool highway_exit_left = 1;
  void clear_highway_exit_left();
  static const int kHighwayExitLeftFieldNumber = 1;
  bool highway_exit_left() const;
  void set_highway_exit_left(bool value);

  // bool highway_exit_right = 2;
  void clear_highway_exit_right();
  static const int kHighwayExitRightFieldNumber = 2;
  bool highway_exit_right() const;
  void set_highway_exit_right(bool value);

  // bool highway_entry_left = 3;
  void clear_highway_entry_left();
  static const int kHighwayEntryLeftFieldNumber = 3;
  bool highway_entry_left() const;
  void set_highway_entry_left(bool value);

  // bool highway_entry_right = 4;
  void clear_highway_entry_right();
  static const int kHighwayEntryRightFieldNumber = 4;
  bool highway_entry_right() const;
  void set_highway_entry_right(bool value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.HighWayJunctionInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool highway_exit_left_;
  bool highway_exit_right_;
  bool highway_entry_left_;
  bool highway_entry_right_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsHighWayJunctionInfoImpl();
};
// -------------------------------------------------------------------

class NumberOfLanes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.NumberOfLanes) */ {
 public:
  NumberOfLanes();
  virtual ~NumberOfLanes();

  NumberOfLanes(const NumberOfLanes& from);

  inline NumberOfLanes& operator=(const NumberOfLanes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NumberOfLanes(NumberOfLanes&& from) noexcept
    : NumberOfLanes() {
    *this = ::std::move(from);
  }

  inline NumberOfLanes& operator=(NumberOfLanes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NumberOfLanes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NumberOfLanes* internal_default_instance() {
    return reinterpret_cast<const NumberOfLanes*>(
               &_NumberOfLanes_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(NumberOfLanes* other);
  friend void swap(NumberOfLanes& a, NumberOfLanes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NumberOfLanes* New() const PROTOBUF_FINAL { return New(NULL); }

  NumberOfLanes* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NumberOfLanes& from);
  void MergeFrom(const NumberOfLanes& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NumberOfLanes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 range_0m = 1;
  void clear_range_0m();
  static const int kRange0MFieldNumber = 1;
  ::google::protobuf::uint32 range_0m() const;
  void set_range_0m(::google::protobuf::uint32 value);

  // uint32 range_35m = 2;
  void clear_range_35m();
  static const int kRange35MFieldNumber = 2;
  ::google::protobuf::uint32 range_35m() const;
  void set_range_35m(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.NumberOfLanes)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 range_0m_;
  ::google::protobuf::uint32 range_35m_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsNumberOfLanesImpl();
};
// -------------------------------------------------------------------

class RoadInfoLines : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.RoadInfoLines) */ {
 public:
  RoadInfoLines();
  virtual ~RoadInfoLines();

  RoadInfoLines(const RoadInfoLines& from);

  inline RoadInfoLines& operator=(const RoadInfoLines& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadInfoLines(RoadInfoLines&& from) noexcept
    : RoadInfoLines() {
    *this = ::std::move(from);
  }

  inline RoadInfoLines& operator=(RoadInfoLines&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadInfoLines& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadInfoLines* internal_default_instance() {
    return reinterpret_cast<const RoadInfoLines*>(
               &_RoadInfoLines_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(RoadInfoLines* other);
  friend void swap(RoadInfoLines& a, RoadInfoLines& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadInfoLines* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadInfoLines* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadInfoLines& from);
  void MergeFrom(const RoadInfoLines& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadInfoLines* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RoadInfoLines_DrivingSide DrivingSide;
  static const DrivingSide kDrivingSideLeftSide =
    RoadInfoLines_DrivingSide_kDrivingSideLeftSide;
  static const DrivingSide kDrivingSideRightSide =
    RoadInfoLines_DrivingSide_kDrivingSideRightSide;
  static inline bool DrivingSide_IsValid(int value) {
    return RoadInfoLines_DrivingSide_IsValid(value);
  }
  static const DrivingSide DrivingSide_MIN =
    RoadInfoLines_DrivingSide_DrivingSide_MIN;
  static const DrivingSide DrivingSide_MAX =
    RoadInfoLines_DrivingSide_DrivingSide_MAX;
  static const int DrivingSide_ARRAYSIZE =
    RoadInfoLines_DrivingSide_DrivingSide_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DrivingSide_descriptor() {
    return RoadInfoLines_DrivingSide_descriptor();
  }
  static inline const ::std::string& DrivingSide_Name(DrivingSide value) {
    return RoadInfoLines_DrivingSide_Name(value);
  }
  static inline bool DrivingSide_Parse(const ::std::string& name,
      DrivingSide* value) {
    return RoadInfoLines_DrivingSide_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.RoadInfoLine lines = 2;
  int lines_size() const;
  void clear_lines();
  static const int kLinesFieldNumber = 2;
  const ::autodrive::workflow::proto::RoadInfoLine& lines(int index) const;
  ::autodrive::workflow::proto::RoadInfoLine* mutable_lines(int index);
  ::autodrive::workflow::proto::RoadInfoLine* add_lines();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RoadInfoLine >*
      mutable_lines();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RoadInfoLine >&
      lines() const;

  // repeated .autodrive.workflow.proto.TransitionPoints transition_points = 10;
  int transition_points_size() const;
  void clear_transition_points();
  static const int kTransitionPointsFieldNumber = 10;
  const ::autodrive::workflow::proto::TransitionPoints& transition_points(int index) const;
  ::autodrive::workflow::proto::TransitionPoints* mutable_transition_points(int index);
  ::autodrive::workflow::proto::TransitionPoints* add_transition_points();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::TransitionPoints >*
      mutable_transition_points();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::TransitionPoints >&
      transition_points() const;

  // .autodrive.workflow.proto.perception_base.CameraMatrix camera_matrix = 1;
  bool has_camera_matrix() const;
  void clear_camera_matrix();
  static const int kCameraMatrixFieldNumber = 1;
  const ::autodrive::workflow::proto::perception_base::CameraMatrix& camera_matrix() const;
  ::autodrive::workflow::proto::perception_base::CameraMatrix* release_camera_matrix();
  ::autodrive::workflow::proto::perception_base::CameraMatrix* mutable_camera_matrix();
  void set_allocated_camera_matrix(::autodrive::workflow::proto::perception_base::CameraMatrix* camera_matrix);

  // .autodrive.workflow.proto.HighWayJunctionInfo highway_junction_info = 11;
  bool has_highway_junction_info() const;
  void clear_highway_junction_info();
  static const int kHighwayJunctionInfoFieldNumber = 11;
  const ::autodrive::workflow::proto::HighWayJunctionInfo& highway_junction_info() const;
  ::autodrive::workflow::proto::HighWayJunctionInfo* release_highway_junction_info();
  ::autodrive::workflow::proto::HighWayJunctionInfo* mutable_highway_junction_info();
  void set_allocated_highway_junction_info(::autodrive::workflow::proto::HighWayJunctionInfo* highway_junction_info);

  // .autodrive.workflow.proto.NumberOfLanes number_of_lanes = 12;
  bool has_number_of_lanes() const;
  void clear_number_of_lanes();
  static const int kNumberOfLanesFieldNumber = 12;
  const ::autodrive::workflow::proto::NumberOfLanes& number_of_lanes() const;
  ::autodrive::workflow::proto::NumberOfLanes* release_number_of_lanes();
  ::autodrive::workflow::proto::NumberOfLanes* mutable_number_of_lanes();
  void set_allocated_number_of_lanes(::autodrive::workflow::proto::NumberOfLanes* number_of_lanes);

  // int64 src_time_stamp = 3;
  void clear_src_time_stamp();
  static const int kSrcTimeStampFieldNumber = 3;
  ::google::protobuf::int64 src_time_stamp() const;
  void set_src_time_stamp(::google::protobuf::int64 value);

  // int64 asyn_time_stamp = 4;
  void clear_asyn_time_stamp();
  static const int kAsynTimeStampFieldNumber = 4;
  ::google::protobuf::int64 asyn_time_stamp() const;
  void set_asyn_time_stamp(::google::protobuf::int64 value);

  // uint32 ambiguous_line_pattern_left = 5;
  void clear_ambiguous_line_pattern_left();
  static const int kAmbiguousLinePatternLeftFieldNumber = 5;
  ::google::protobuf::uint32 ambiguous_line_pattern_left() const;
  void set_ambiguous_line_pattern_left(::google::protobuf::uint32 value);

  // uint32 ambiguous_line_pattern_right = 6;
  void clear_ambiguous_line_pattern_right();
  static const int kAmbiguousLinePatternRightFieldNumber = 6;
  ::google::protobuf::uint32 ambiguous_line_pattern_right() const;
  void set_ambiguous_line_pattern_right(::google::protobuf::uint32 value);

  // uint32 construction_area = 7;
  void clear_construction_area();
  static const int kConstructionAreaFieldNumber = 7;
  ::google::protobuf::uint32 construction_area() const;
  void set_construction_area(::google::protobuf::uint32 value);

  // .autodrive.workflow.proto.LaneChange lane_change = 8;
  void clear_lane_change();
  static const int kLaneChangeFieldNumber = 8;
  ::autodrive::workflow::proto::LaneChange lane_change() const;
  void set_lane_change(::autodrive::workflow::proto::LaneChange value);

  // .autodrive.workflow.proto.RoadInfoLines.DrivingSide driving_side = 9;
  void clear_driving_side();
  static const int kDrivingSideFieldNumber = 9;
  ::autodrive::workflow::proto::RoadInfoLines_DrivingSide driving_side() const;
  void set_driving_side(::autodrive::workflow::proto::RoadInfoLines_DrivingSide value);

  // float host_width = 13;
  void clear_host_width();
  static const int kHostWidthFieldNumber = 13;
  float host_width() const;
  void set_host_width(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.RoadInfoLines)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RoadInfoLine > lines_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::TransitionPoints > transition_points_;
  ::autodrive::workflow::proto::perception_base::CameraMatrix* camera_matrix_;
  ::autodrive::workflow::proto::HighWayJunctionInfo* highway_junction_info_;
  ::autodrive::workflow::proto::NumberOfLanes* number_of_lanes_;
  ::google::protobuf::int64 src_time_stamp_;
  ::google::protobuf::int64 asyn_time_stamp_;
  ::google::protobuf::uint32 ambiguous_line_pattern_left_;
  ::google::protobuf::uint32 ambiguous_line_pattern_right_;
  ::google::protobuf::uint32 construction_area_;
  int lane_change_;
  int driving_side_;
  float host_width_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoLinesImpl();
};
// -------------------------------------------------------------------

class StopLines : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.StopLines) */ {
 public:
  StopLines();
  virtual ~StopLines();

  StopLines(const StopLines& from);

  inline StopLines& operator=(const StopLines& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopLines(StopLines&& from) noexcept
    : StopLines() {
    *this = ::std::move(from);
  }

  inline StopLines& operator=(StopLines&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopLines& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopLines* internal_default_instance() {
    return reinterpret_cast<const StopLines*>(
               &_StopLines_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(StopLines* other);
  friend void swap(StopLines& a, StopLines& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopLines* New() const PROTOBUF_FINAL { return New(NULL); }

  StopLines* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StopLines& from);
  void MergeFrom(const StopLines& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StopLines* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float lateral_distance = 1;
  void clear_lateral_distance();
  static const int kLateralDistanceFieldNumber = 1;
  float lateral_distance() const;
  void set_lateral_distance(float value);

  // float longitudinal_distance = 2;
  void clear_longitudinal_distance();
  static const int kLongitudinalDistanceFieldNumber = 2;
  float longitudinal_distance() const;
  void set_longitudinal_distance(float value);

  // float angle = 3;
  void clear_angle();
  static const int kAngleFieldNumber = 3;
  float angle() const;
  void set_angle(float value);

  // float confidence = 4;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 4;
  float confidence() const;
  void set_confidence(float value);

  // uint32 id = 5;
  void clear_id();
  static const int kIdFieldNumber = 5;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // .autodrive.workflow.proto.StopLineStatus stop_line_status = 6;
  void clear_stop_line_status();
  static const int kStopLineStatusFieldNumber = 6;
  ::autodrive::workflow::proto::StopLineStatus stop_line_status() const;
  void set_stop_line_status(::autodrive::workflow::proto::StopLineStatus value);

  // .autodrive.workflow.proto.StopLineType stop_line_type = 7;
  void clear_stop_line_type();
  static const int kStopLineTypeFieldNumber = 7;
  ::autodrive::workflow::proto::StopLineType stop_line_type() const;
  void set_stop_line_type(::autodrive::workflow::proto::StopLineType value);

  // .autodrive.workflow.proto.StopLineColorType stop_line_color = 8;
  void clear_stop_line_color();
  static const int kStopLineColorFieldNumber = 8;
  ::autodrive::workflow::proto::StopLineColorType stop_line_color() const;
  void set_stop_line_color(::autodrive::workflow::proto::StopLineColorType value);

  // bool is_relevant = 9;
  void clear_is_relevant();
  static const int kIsRelevantFieldNumber = 9;
  bool is_relevant() const;
  void set_is_relevant(bool value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.StopLines)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float lateral_distance_;
  float longitudinal_distance_;
  float angle_;
  float confidence_;
  ::google::protobuf::uint32 id_;
  int stop_line_status_;
  int stop_line_type_;
  int stop_line_color_;
  bool is_relevant_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsStopLinesImpl();
};
// -------------------------------------------------------------------

class Crossings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.Crossings) */ {
 public:
  Crossings();
  virtual ~Crossings();

  Crossings(const Crossings& from);

  inline Crossings& operator=(const Crossings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Crossings(Crossings&& from) noexcept
    : Crossings() {
    *this = ::std::move(from);
  }

  inline Crossings& operator=(Crossings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Crossings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Crossings* internal_default_instance() {
    return reinterpret_cast<const Crossings*>(
               &_Crossings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Crossings* other);
  friend void swap(Crossings& a, Crossings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Crossings* New() const PROTOBUF_FINAL { return New(NULL); }

  Crossings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Crossings& from);
  void MergeFrom(const Crossings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Crossings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float lateral_position = 1;
  void clear_lateral_position();
  static const int kLateralPositionFieldNumber = 1;
  float lateral_position() const;
  void set_lateral_position(float value);

  // float longitudinal_position = 2;
  void clear_longitudinal_position();
  static const int kLongitudinalPositionFieldNumber = 2;
  float longitudinal_position() const;
  void set_longitudinal_position(float value);

  // float confidence = 3;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 3;
  float confidence() const;
  void set_confidence(float value);

  // uint32 id = 4;
  void clear_id();
  static const int kIdFieldNumber = 4;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // .autodrive.workflow.proto.CrossingsType crossings_type = 5;
  void clear_crossings_type();
  static const int kCrossingsTypeFieldNumber = 5;
  ::autodrive::workflow::proto::CrossingsType crossings_type() const;
  void set_crossings_type(::autodrive::workflow::proto::CrossingsType value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.Crossings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float lateral_position_;
  float longitudinal_position_;
  float confidence_;
  ::google::protobuf::uint32 id_;
  int crossings_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsCrossingsImpl();
};
// -------------------------------------------------------------------

class RoadInfoMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.RoadInfoMsg) */ {
 public:
  RoadInfoMsg();
  virtual ~RoadInfoMsg();

  RoadInfoMsg(const RoadInfoMsg& from);

  inline RoadInfoMsg& operator=(const RoadInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadInfoMsg(RoadInfoMsg&& from) noexcept
    : RoadInfoMsg() {
    *this = ::std::move(from);
  }

  inline RoadInfoMsg& operator=(RoadInfoMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadInfoMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadInfoMsg* internal_default_instance() {
    return reinterpret_cast<const RoadInfoMsg*>(
               &_RoadInfoMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(RoadInfoMsg* other);
  friend void swap(RoadInfoMsg& a, RoadInfoMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadInfoMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadInfoMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadInfoMsg& from);
  void MergeFrom(const RoadInfoMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadInfoMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.MsgHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::MsgHeader& header() const;
  ::autodrive::workflow::proto::MsgHeader* release_header();
  ::autodrive::workflow::proto::MsgHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::MsgHeader* header);

  // .autodrive.workflow.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::autodrive::workflow::proto::Error& error() const;
  ::autodrive::workflow::proto::Error* release_error();
  ::autodrive::workflow::proto::Error* mutable_error();
  void set_allocated_error(::autodrive::workflow::proto::Error* error);

  // .autodrive.workflow.proto.RoadBorders road_borders = 3;
  bool has_road_borders() const;
  void clear_road_borders();
  static const int kRoadBordersFieldNumber = 3;
  const ::autodrive::workflow::proto::RoadBorders& road_borders() const;
  ::autodrive::workflow::proto::RoadBorders* release_road_borders();
  ::autodrive::workflow::proto::RoadBorders* mutable_road_borders();
  void set_allocated_road_borders(::autodrive::workflow::proto::RoadBorders* road_borders);

  // .autodrive.workflow.proto.RoadInfoLines lane_lines = 4;
  bool has_lane_lines() const;
  void clear_lane_lines();
  static const int kLaneLinesFieldNumber = 4;
  const ::autodrive::workflow::proto::RoadInfoLines& lane_lines() const;
  ::autodrive::workflow::proto::RoadInfoLines* release_lane_lines();
  ::autodrive::workflow::proto::RoadInfoLines* mutable_lane_lines();
  void set_allocated_lane_lines(::autodrive::workflow::proto::RoadInfoLines* lane_lines);

  // .autodrive.workflow.proto.StopLines stop_lines = 5;
  bool has_stop_lines() const;
  void clear_stop_lines();
  static const int kStopLinesFieldNumber = 5;
  const ::autodrive::workflow::proto::StopLines& stop_lines() const;
  ::autodrive::workflow::proto::StopLines* release_stop_lines();
  ::autodrive::workflow::proto::StopLines* mutable_stop_lines();
  void set_allocated_stop_lines(::autodrive::workflow::proto::StopLines* stop_lines);

  // .autodrive.workflow.proto.Crossings crossings = 6;
  bool has_crossings() const;
  void clear_crossings();
  static const int kCrossingsFieldNumber = 6;
  const ::autodrive::workflow::proto::Crossings& crossings() const;
  ::autodrive::workflow::proto::Crossings* release_crossings();
  ::autodrive::workflow::proto::Crossings* mutable_crossings();
  void set_allocated_crossings(::autodrive::workflow::proto::Crossings* crossings);

  // int32 camera_id = 7;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 7;
  ::google::protobuf::int32 camera_id() const;
  void set_camera_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.RoadInfoMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::MsgHeader* header_;
  ::autodrive::workflow::proto::Error* error_;
  ::autodrive::workflow::proto::RoadBorders* road_borders_;
  ::autodrive::workflow::proto::RoadInfoLines* lane_lines_;
  ::autodrive::workflow::proto::StopLines* stop_lines_;
  ::autodrive::workflow::proto::Crossings* crossings_;
  ::google::protobuf::int32 camera_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_road_5finfo_2eproto::TableStruct;
  friend void ::protobuf_road_5finfo_2eproto::InitDefaultsRoadInfoMsgImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoadInfoCurveLine

// float start = 1;
inline void RoadInfoCurveLine::clear_start() {
  start_ = 0;
}
inline float RoadInfoCurveLine::start() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.start)
  return start_;
}
inline void RoadInfoCurveLine::set_start(float value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoCurveLine.start)
}

// float end = 2;
inline void RoadInfoCurveLine::clear_end() {
  end_ = 0;
}
inline float RoadInfoCurveLine::end() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.end)
  return end_;
}
inline void RoadInfoCurveLine::set_end(float value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoCurveLine.end)
}

// float rmse = 3;
inline void RoadInfoCurveLine::clear_rmse() {
  rmse_ = 0;
}
inline float RoadInfoCurveLine::rmse() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.rmse)
  return rmse_;
}
inline void RoadInfoCurveLine::set_rmse(float value) {
  
  rmse_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoCurveLine.rmse)
}

// .autodrive.workflow.proto.RoadInfoCurveType type = 4;
inline void RoadInfoCurveLine::clear_type() {
  type_ = 0;
}
inline ::autodrive::workflow::proto::RoadInfoCurveType RoadInfoCurveLine::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.type)
  return static_cast< ::autodrive::workflow::proto::RoadInfoCurveType >(type_);
}
inline void RoadInfoCurveLine::set_type(::autodrive::workflow::proto::RoadInfoCurveType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoCurveLine.type)
}

// repeated .autodrive.workflow.proto.Vector3d points = 5;
inline int RoadInfoCurveLine::points_size() const {
  return points_.size();
}
inline const ::autodrive::workflow::proto::Vector3d& RoadInfoCurveLine::points(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.points)
  return points_.Get(index);
}
inline ::autodrive::workflow::proto::Vector3d* RoadInfoCurveLine::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoCurveLine.points)
  return points_.Mutable(index);
}
inline ::autodrive::workflow::proto::Vector3d* RoadInfoCurveLine::add_points() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.RoadInfoCurveLine.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3d >*
RoadInfoCurveLine::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.RoadInfoCurveLine.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Vector3d >&
RoadInfoCurveLine::points() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.RoadInfoCurveLine.points)
  return points_;
}

// repeated double t = 6;
inline int RoadInfoCurveLine::t_size() const {
  return t_.size();
}
inline void RoadInfoCurveLine::clear_t() {
  t_.Clear();
}
inline double RoadInfoCurveLine::t(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.t)
  return t_.Get(index);
}
inline void RoadInfoCurveLine::set_t(int index, double value) {
  t_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoCurveLine.t)
}
inline void RoadInfoCurveLine::add_t(double value) {
  t_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.RoadInfoCurveLine.t)
}
inline const ::google::protobuf::RepeatedField< double >&
RoadInfoCurveLine::t() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.RoadInfoCurveLine.t)
  return t_;
}
inline ::google::protobuf::RepeatedField< double >*
RoadInfoCurveLine::mutable_t() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.RoadInfoCurveLine.t)
  return &t_;
}

// double t_max = 7;
inline void RoadInfoCurveLine::clear_t_max() {
  t_max_ = 0;
}
inline double RoadInfoCurveLine::t_max() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.t_max)
  return t_max_;
}
inline void RoadInfoCurveLine::set_t_max(double value) {
  
  t_max_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoCurveLine.t_max)
}

// .autodrive.workflow.proto.Vector3d start_pt = 8;
inline bool RoadInfoCurveLine::has_start_pt() const {
  return this != internal_default_instance() && start_pt_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& RoadInfoCurveLine::start_pt() const {
  const ::autodrive::workflow::proto::Vector3d* p = start_pt_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.start_pt)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* RoadInfoCurveLine::release_start_pt() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoCurveLine.start_pt)
  
  ::autodrive::workflow::proto::Vector3d* temp = start_pt_;
  start_pt_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* RoadInfoCurveLine::mutable_start_pt() {
  
  if (start_pt_ == NULL) {
    start_pt_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoCurveLine.start_pt)
  return start_pt_;
}
inline void RoadInfoCurveLine::set_allocated_start_pt(::autodrive::workflow::proto::Vector3d* start_pt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_pt_);
  }
  if (start_pt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_pt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_pt, submessage_arena);
    }
    
  } else {
    
  }
  start_pt_ = start_pt;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoCurveLine.start_pt)
}

// repeated double x_coeff = 9;
inline int RoadInfoCurveLine::x_coeff_size() const {
  return x_coeff_.size();
}
inline void RoadInfoCurveLine::clear_x_coeff() {
  x_coeff_.Clear();
}
inline double RoadInfoCurveLine::x_coeff(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.x_coeff)
  return x_coeff_.Get(index);
}
inline void RoadInfoCurveLine::set_x_coeff(int index, double value) {
  x_coeff_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoCurveLine.x_coeff)
}
inline void RoadInfoCurveLine::add_x_coeff(double value) {
  x_coeff_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.RoadInfoCurveLine.x_coeff)
}
inline const ::google::protobuf::RepeatedField< double >&
RoadInfoCurveLine::x_coeff() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.RoadInfoCurveLine.x_coeff)
  return x_coeff_;
}
inline ::google::protobuf::RepeatedField< double >*
RoadInfoCurveLine::mutable_x_coeff() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.RoadInfoCurveLine.x_coeff)
  return &x_coeff_;
}

// repeated double y_coeff = 10;
inline int RoadInfoCurveLine::y_coeff_size() const {
  return y_coeff_.size();
}
inline void RoadInfoCurveLine::clear_y_coeff() {
  y_coeff_.Clear();
}
inline double RoadInfoCurveLine::y_coeff(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.y_coeff)
  return y_coeff_.Get(index);
}
inline void RoadInfoCurveLine::set_y_coeff(int index, double value) {
  y_coeff_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoCurveLine.y_coeff)
}
inline void RoadInfoCurveLine::add_y_coeff(double value) {
  y_coeff_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.RoadInfoCurveLine.y_coeff)
}
inline const ::google::protobuf::RepeatedField< double >&
RoadInfoCurveLine::y_coeff() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.RoadInfoCurveLine.y_coeff)
  return y_coeff_;
}
inline ::google::protobuf::RepeatedField< double >*
RoadInfoCurveLine::mutable_y_coeff() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.RoadInfoCurveLine.y_coeff)
  return &y_coeff_;
}

// float length = 11;
inline void RoadInfoCurveLine::clear_length() {
  length_ = 0;
}
inline float RoadInfoCurveLine::length() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoCurveLine.length)
  return length_;
}
inline void RoadInfoCurveLine::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoCurveLine.length)
}

// -------------------------------------------------------------------

// Border

// .autodrive.workflow.proto.RoadBorderSide border_side = 1;
inline void Border::clear_border_side() {
  border_side_ = 0;
}
inline ::autodrive::workflow::proto::RoadBorderSide Border::border_side() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Border.border_side)
  return static_cast< ::autodrive::workflow::proto::RoadBorderSide >(border_side_);
}
inline void Border::set_border_side(::autodrive::workflow::proto::RoadBorderSide value) {
  
  border_side_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Border.border_side)
}

// .autodrive.workflow.proto.RoadBorderType border_type = 2;
inline void Border::clear_border_type() {
  border_type_ = 0;
}
inline ::autodrive::workflow::proto::RoadBorderType Border::border_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Border.border_type)
  return static_cast< ::autodrive::workflow::proto::RoadBorderType >(border_type_);
}
inline void Border::set_border_type(::autodrive::workflow::proto::RoadBorderType value) {
  
  border_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Border.border_type)
}

// .autodrive.workflow.proto.RoadInfoLineSource conf_level = 3;
inline void Border::clear_conf_level() {
  conf_level_ = 0;
}
inline ::autodrive::workflow::proto::RoadInfoLineSource Border::conf_level() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Border.conf_level)
  return static_cast< ::autodrive::workflow::proto::RoadInfoLineSource >(conf_level_);
}
inline void Border::set_conf_level(::autodrive::workflow::proto::RoadInfoLineSource value) {
  
  conf_level_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Border.conf_level)
}

// .autodrive.workflow.proto.RoadInfoCurveLine curve = 4;
inline bool Border::has_curve() const {
  return this != internal_default_instance() && curve_ != NULL;
}
inline void Border::clear_curve() {
  if (GetArenaNoVirtual() == NULL && curve_ != NULL) {
    delete curve_;
  }
  curve_ = NULL;
}
inline const ::autodrive::workflow::proto::RoadInfoCurveLine& Border::curve() const {
  const ::autodrive::workflow::proto::RoadInfoCurveLine* p = curve_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Border.curve)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::RoadInfoCurveLine*>(
      &::autodrive::workflow::proto::_RoadInfoCurveLine_default_instance_);
}
inline ::autodrive::workflow::proto::RoadInfoCurveLine* Border::release_curve() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.Border.curve)
  
  ::autodrive::workflow::proto::RoadInfoCurveLine* temp = curve_;
  curve_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::RoadInfoCurveLine* Border::mutable_curve() {
  
  if (curve_ == NULL) {
    curve_ = new ::autodrive::workflow::proto::RoadInfoCurveLine;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.Border.curve)
  return curve_;
}
inline void Border::set_allocated_curve(::autodrive::workflow::proto::RoadInfoCurveLine* curve) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete curve_;
  }
  if (curve) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      curve = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, curve, submessage_arena);
    }
    
  } else {
    
  }
  curve_ = curve;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.Border.curve)
}

// float conf = 5;
inline void Border::clear_conf() {
  conf_ = 0;
}
inline float Border::conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Border.conf)
  return conf_;
}
inline void Border::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Border.conf)
}

// float border_height = 6;
inline void Border::clear_border_height() {
  border_height_ = 0;
}
inline float Border::border_height() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Border.border_height)
  return border_height_;
}
inline void Border::set_border_height(float value) {
  
  border_height_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Border.border_height)
}

// -------------------------------------------------------------------

// RoadBorders

// repeated .autodrive.workflow.proto.Border borders = 1;
inline int RoadBorders::borders_size() const {
  return borders_.size();
}
inline void RoadBorders::clear_borders() {
  borders_.Clear();
}
inline const ::autodrive::workflow::proto::Border& RoadBorders::borders(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadBorders.borders)
  return borders_.Get(index);
}
inline ::autodrive::workflow::proto::Border* RoadBorders::mutable_borders(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadBorders.borders)
  return borders_.Mutable(index);
}
inline ::autodrive::workflow::proto::Border* RoadBorders::add_borders() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.RoadBorders.borders)
  return borders_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Border >*
RoadBorders::mutable_borders() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.RoadBorders.borders)
  return &borders_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::Border >&
RoadBorders::borders() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.RoadBorders.borders)
  return borders_;
}

// -------------------------------------------------------------------

// TransitionPoints

// float long_position = 1;
inline void TransitionPoints::clear_long_position() {
  long_position_ = 0;
}
inline float TransitionPoints::long_position() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.TransitionPoints.long_position)
  return long_position_;
}
inline void TransitionPoints::set_long_position(float value) {
  
  long_position_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.TransitionPoints.long_position)
}

// float lat_position = 2;
inline void TransitionPoints::clear_lat_position() {
  lat_position_ = 0;
}
inline float TransitionPoints::lat_position() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.TransitionPoints.lat_position)
  return lat_position_;
}
inline void TransitionPoints::set_lat_position(float value) {
  
  lat_position_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.TransitionPoints.lat_position)
}

// float prob = 3;
inline void TransitionPoints::clear_prob() {
  prob_ = 0;
}
inline float TransitionPoints::prob() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.TransitionPoints.prob)
  return prob_;
}
inline void TransitionPoints::set_prob(float value) {
  
  prob_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.TransitionPoints.prob)
}

// .autodrive.workflow.proto.TransitionType type = 4;
inline void TransitionPoints::clear_type() {
  type_ = 0;
}
inline ::autodrive::workflow::proto::TransitionType TransitionPoints::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.TransitionPoints.type)
  return static_cast< ::autodrive::workflow::proto::TransitionType >(type_);
}
inline void TransitionPoints::set_type(::autodrive::workflow::proto::TransitionType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.TransitionPoints.type)
}

// .autodrive.workflow.proto.LineRole relate_line = 5;
inline void TransitionPoints::clear_relate_line() {
  relate_line_ = 0;
}
inline ::autodrive::workflow::proto::LineRole TransitionPoints::relate_line() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.TransitionPoints.relate_line)
  return static_cast< ::autodrive::workflow::proto::LineRole >(relate_line_);
}
inline void TransitionPoints::set_relate_line(::autodrive::workflow::proto::LineRole value) {
  
  relate_line_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.TransitionPoints.relate_line)
}

// -------------------------------------------------------------------

// RoadInfoLine

// int32 id = 1;
inline void RoadInfoLine::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 RoadInfoLine::id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.id)
  return id_;
}
inline void RoadInfoLine::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.id)
}

// string str_id = 2;
inline void RoadInfoLine::clear_str_id() {
  str_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoadInfoLine::str_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.str_id)
  return str_id_.GetNoArena();
}
inline void RoadInfoLine::set_str_id(const ::std::string& value) {
  
  str_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.str_id)
}
#if LANG_CXX11
inline void RoadInfoLine::set_str_id(::std::string&& value) {
  
  str_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.RoadInfoLine.str_id)
}
#endif
inline void RoadInfoLine::set_str_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  str_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.RoadInfoLine.str_id)
}
inline void RoadInfoLine::set_str_id(const char* value, size_t size) {
  
  str_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.RoadInfoLine.str_id)
}
inline ::std::string* RoadInfoLine::mutable_str_id() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoLine.str_id)
  return str_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoadInfoLine::release_str_id() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoLine.str_id)
  
  return str_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoadInfoLine::set_allocated_str_id(::std::string* str_id) {
  if (str_id != NULL) {
    
  } else {
    
  }
  str_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str_id);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoLine.str_id)
}

// repeated .autodrive.workflow.proto.RoadInfoCurveLine curve_segs = 3;
inline int RoadInfoLine::curve_segs_size() const {
  return curve_segs_.size();
}
inline void RoadInfoLine::clear_curve_segs() {
  curve_segs_.Clear();
}
inline const ::autodrive::workflow::proto::RoadInfoCurveLine& RoadInfoLine::curve_segs(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.curve_segs)
  return curve_segs_.Get(index);
}
inline ::autodrive::workflow::proto::RoadInfoCurveLine* RoadInfoLine::mutable_curve_segs(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoLine.curve_segs)
  return curve_segs_.Mutable(index);
}
inline ::autodrive::workflow::proto::RoadInfoCurveLine* RoadInfoLine::add_curve_segs() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.RoadInfoLine.curve_segs)
  return curve_segs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RoadInfoCurveLine >*
RoadInfoLine::mutable_curve_segs() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.RoadInfoLine.curve_segs)
  return &curve_segs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RoadInfoCurveLine >&
RoadInfoLine::curve_segs() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.RoadInfoLine.curve_segs)
  return curve_segs_;
}

// int32 life_time = 4;
inline void RoadInfoLine::clear_life_time() {
  life_time_ = 0;
}
inline ::google::protobuf::int32 RoadInfoLine::life_time() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.life_time)
  return life_time_;
}
inline void RoadInfoLine::set_life_time(::google::protobuf::int32 value) {
  
  life_time_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.life_time)
}

// float start = 5;
inline void RoadInfoLine::clear_start() {
  start_ = 0;
}
inline float RoadInfoLine::start() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.start)
  return start_;
}
inline void RoadInfoLine::set_start(float value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.start)
}

// float end = 6;
inline void RoadInfoLine::clear_end() {
  end_ = 0;
}
inline float RoadInfoLine::end() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.end)
  return end_;
}
inline void RoadInfoLine::set_end(float value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.end)
}

// float conf = 7;
inline void RoadInfoLine::clear_conf() {
  conf_ = 0;
}
inline float RoadInfoLine::conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.conf)
  return conf_;
}
inline void RoadInfoLine::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.conf)
}

// float width = 8;
inline void RoadInfoLine::clear_width() {
  width_ = 0;
}
inline float RoadInfoLine::width() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.width)
  return width_;
}
inline void RoadInfoLine::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.width)
}

// .autodrive.workflow.proto.RoadInfoLinePosition position = 9;
inline void RoadInfoLine::clear_position() {
  position_ = 0;
}
inline ::autodrive::workflow::proto::RoadInfoLinePosition RoadInfoLine::position() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.position)
  return static_cast< ::autodrive::workflow::proto::RoadInfoLinePosition >(position_);
}
inline void RoadInfoLine::set_position(::autodrive::workflow::proto::RoadInfoLinePosition value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.position)
}

// .autodrive.workflow.proto.RoadInfoLineSource conf_level = 10;
inline void RoadInfoLine::clear_conf_level() {
  conf_level_ = 0;
}
inline ::autodrive::workflow::proto::RoadInfoLineSource RoadInfoLine::conf_level() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.conf_level)
  return static_cast< ::autodrive::workflow::proto::RoadInfoLineSource >(conf_level_);
}
inline void RoadInfoLine::set_conf_level(::autodrive::workflow::proto::RoadInfoLineSource value) {
  
  conf_level_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.conf_level)
}

// .autodrive.workflow.proto.RoadInfoLineColor line_color = 11;
inline void RoadInfoLine::clear_line_color() {
  line_color_ = 0;
}
inline ::autodrive::workflow::proto::RoadInfoLineColor RoadInfoLine::line_color() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.line_color)
  return static_cast< ::autodrive::workflow::proto::RoadInfoLineColor >(line_color_);
}
inline void RoadInfoLine::set_line_color(::autodrive::workflow::proto::RoadInfoLineColor value) {
  
  line_color_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.line_color)
}

// .autodrive.workflow.proto.RoadInfoLineType type = 12;
inline void RoadInfoLine::clear_type() {
  type_ = 0;
}
inline ::autodrive::workflow::proto::RoadInfoLineType RoadInfoLine::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.type)
  return static_cast< ::autodrive::workflow::proto::RoadInfoLineType >(type_);
}
inline void RoadInfoLine::set_type(::autodrive::workflow::proto::RoadInfoLineType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.type)
}

// .autodrive.workflow.proto.DlmType dlm_type = 13;
inline void RoadInfoLine::clear_dlm_type() {
  dlm_type_ = 0;
}
inline ::autodrive::workflow::proto::DlmType RoadInfoLine::dlm_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.dlm_type)
  return static_cast< ::autodrive::workflow::proto::DlmType >(dlm_type_);
}
inline void RoadInfoLine::set_dlm_type(::autodrive::workflow::proto::DlmType value) {
  
  dlm_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.dlm_type)
}

// .autodrive.workflow.proto.DecelType decel_type = 14;
inline void RoadInfoLine::clear_decel_type() {
  decel_type_ = 0;
}
inline ::autodrive::workflow::proto::DecelType RoadInfoLine::decel_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.decel_type)
  return static_cast< ::autodrive::workflow::proto::DecelType >(decel_type_);
}
inline void RoadInfoLine::set_decel_type(::autodrive::workflow::proto::DecelType value) {
  
  decel_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.decel_type)
}

// uint32 road_prediction = 15;
inline void RoadInfoLine::clear_road_prediction() {
  road_prediction_ = 0u;
}
inline ::google::protobuf::uint32 RoadInfoLine::road_prediction() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.road_prediction)
  return road_prediction_;
}
inline void RoadInfoLine::set_road_prediction(::google::protobuf::uint32 value) {
  
  road_prediction_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.road_prediction)
}

// float length = 16;
inline void RoadInfoLine::clear_length() {
  length_ = 0;
}
inline float RoadInfoLine::length() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.length)
  return length_;
}
inline void RoadInfoLine::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.length)
}

// .autodrive.workflow.proto.TriggerModel triggered_model = 17;
inline void RoadInfoLine::clear_triggered_model() {
  triggered_model_ = 0;
}
inline ::autodrive::workflow::proto::TriggerModel RoadInfoLine::triggered_model() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLine.triggered_model)
  return static_cast< ::autodrive::workflow::proto::TriggerModel >(triggered_model_);
}
inline void RoadInfoLine::set_triggered_model(::autodrive::workflow::proto::TriggerModel value) {
  
  triggered_model_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLine.triggered_model)
}

// -------------------------------------------------------------------

// HighWayJunctionInfo

// bool highway_exit_left = 1;
inline void HighWayJunctionInfo::clear_highway_exit_left() {
  highway_exit_left_ = false;
}
inline bool HighWayJunctionInfo::highway_exit_left() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HighWayJunctionInfo.highway_exit_left)
  return highway_exit_left_;
}
inline void HighWayJunctionInfo::set_highway_exit_left(bool value) {
  
  highway_exit_left_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HighWayJunctionInfo.highway_exit_left)
}

// bool highway_exit_right = 2;
inline void HighWayJunctionInfo::clear_highway_exit_right() {
  highway_exit_right_ = false;
}
inline bool HighWayJunctionInfo::highway_exit_right() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HighWayJunctionInfo.highway_exit_right)
  return highway_exit_right_;
}
inline void HighWayJunctionInfo::set_highway_exit_right(bool value) {
  
  highway_exit_right_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HighWayJunctionInfo.highway_exit_right)
}

// bool highway_entry_left = 3;
inline void HighWayJunctionInfo::clear_highway_entry_left() {
  highway_entry_left_ = false;
}
inline bool HighWayJunctionInfo::highway_entry_left() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HighWayJunctionInfo.highway_entry_left)
  return highway_entry_left_;
}
inline void HighWayJunctionInfo::set_highway_entry_left(bool value) {
  
  highway_entry_left_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HighWayJunctionInfo.highway_entry_left)
}

// bool highway_entry_right = 4;
inline void HighWayJunctionInfo::clear_highway_entry_right() {
  highway_entry_right_ = false;
}
inline bool HighWayJunctionInfo::highway_entry_right() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.HighWayJunctionInfo.highway_entry_right)
  return highway_entry_right_;
}
inline void HighWayJunctionInfo::set_highway_entry_right(bool value) {
  
  highway_entry_right_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.HighWayJunctionInfo.highway_entry_right)
}

// -------------------------------------------------------------------

// NumberOfLanes

// uint32 range_0m = 1;
inline void NumberOfLanes::clear_range_0m() {
  range_0m_ = 0u;
}
inline ::google::protobuf::uint32 NumberOfLanes::range_0m() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.NumberOfLanes.range_0m)
  return range_0m_;
}
inline void NumberOfLanes::set_range_0m(::google::protobuf::uint32 value) {
  
  range_0m_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.NumberOfLanes.range_0m)
}

// uint32 range_35m = 2;
inline void NumberOfLanes::clear_range_35m() {
  range_35m_ = 0u;
}
inline ::google::protobuf::uint32 NumberOfLanes::range_35m() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.NumberOfLanes.range_35m)
  return range_35m_;
}
inline void NumberOfLanes::set_range_35m(::google::protobuf::uint32 value) {
  
  range_35m_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.NumberOfLanes.range_35m)
}

// -------------------------------------------------------------------

// RoadInfoLines

// .autodrive.workflow.proto.perception_base.CameraMatrix camera_matrix = 1;
inline bool RoadInfoLines::has_camera_matrix() const {
  return this != internal_default_instance() && camera_matrix_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::CameraMatrix& RoadInfoLines::camera_matrix() const {
  const ::autodrive::workflow::proto::perception_base::CameraMatrix* p = camera_matrix_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.camera_matrix)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::CameraMatrix*>(
      &::autodrive::workflow::proto::perception_base::_CameraMatrix_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::CameraMatrix* RoadInfoLines::release_camera_matrix() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoLines.camera_matrix)
  
  ::autodrive::workflow::proto::perception_base::CameraMatrix* temp = camera_matrix_;
  camera_matrix_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::CameraMatrix* RoadInfoLines::mutable_camera_matrix() {
  
  if (camera_matrix_ == NULL) {
    camera_matrix_ = new ::autodrive::workflow::proto::perception_base::CameraMatrix;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoLines.camera_matrix)
  return camera_matrix_;
}
inline void RoadInfoLines::set_allocated_camera_matrix(::autodrive::workflow::proto::perception_base::CameraMatrix* camera_matrix) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(camera_matrix_);
  }
  if (camera_matrix) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      camera_matrix = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, camera_matrix, submessage_arena);
    }
    
  } else {
    
  }
  camera_matrix_ = camera_matrix;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoLines.camera_matrix)
}

// repeated .autodrive.workflow.proto.RoadInfoLine lines = 2;
inline int RoadInfoLines::lines_size() const {
  return lines_.size();
}
inline void RoadInfoLines::clear_lines() {
  lines_.Clear();
}
inline const ::autodrive::workflow::proto::RoadInfoLine& RoadInfoLines::lines(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.lines)
  return lines_.Get(index);
}
inline ::autodrive::workflow::proto::RoadInfoLine* RoadInfoLines::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoLines.lines)
  return lines_.Mutable(index);
}
inline ::autodrive::workflow::proto::RoadInfoLine* RoadInfoLines::add_lines() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.RoadInfoLines.lines)
  return lines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RoadInfoLine >*
RoadInfoLines::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.RoadInfoLines.lines)
  return &lines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RoadInfoLine >&
RoadInfoLines::lines() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.RoadInfoLines.lines)
  return lines_;
}

// int64 src_time_stamp = 3;
inline void RoadInfoLines::clear_src_time_stamp() {
  src_time_stamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RoadInfoLines::src_time_stamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.src_time_stamp)
  return src_time_stamp_;
}
inline void RoadInfoLines::set_src_time_stamp(::google::protobuf::int64 value) {
  
  src_time_stamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLines.src_time_stamp)
}

// int64 asyn_time_stamp = 4;
inline void RoadInfoLines::clear_asyn_time_stamp() {
  asyn_time_stamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RoadInfoLines::asyn_time_stamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.asyn_time_stamp)
  return asyn_time_stamp_;
}
inline void RoadInfoLines::set_asyn_time_stamp(::google::protobuf::int64 value) {
  
  asyn_time_stamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLines.asyn_time_stamp)
}

// uint32 ambiguous_line_pattern_left = 5;
inline void RoadInfoLines::clear_ambiguous_line_pattern_left() {
  ambiguous_line_pattern_left_ = 0u;
}
inline ::google::protobuf::uint32 RoadInfoLines::ambiguous_line_pattern_left() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.ambiguous_line_pattern_left)
  return ambiguous_line_pattern_left_;
}
inline void RoadInfoLines::set_ambiguous_line_pattern_left(::google::protobuf::uint32 value) {
  
  ambiguous_line_pattern_left_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLines.ambiguous_line_pattern_left)
}

// uint32 ambiguous_line_pattern_right = 6;
inline void RoadInfoLines::clear_ambiguous_line_pattern_right() {
  ambiguous_line_pattern_right_ = 0u;
}
inline ::google::protobuf::uint32 RoadInfoLines::ambiguous_line_pattern_right() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.ambiguous_line_pattern_right)
  return ambiguous_line_pattern_right_;
}
inline void RoadInfoLines::set_ambiguous_line_pattern_right(::google::protobuf::uint32 value) {
  
  ambiguous_line_pattern_right_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLines.ambiguous_line_pattern_right)
}

// uint32 construction_area = 7;
inline void RoadInfoLines::clear_construction_area() {
  construction_area_ = 0u;
}
inline ::google::protobuf::uint32 RoadInfoLines::construction_area() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.construction_area)
  return construction_area_;
}
inline void RoadInfoLines::set_construction_area(::google::protobuf::uint32 value) {
  
  construction_area_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLines.construction_area)
}

// .autodrive.workflow.proto.LaneChange lane_change = 8;
inline void RoadInfoLines::clear_lane_change() {
  lane_change_ = 0;
}
inline ::autodrive::workflow::proto::LaneChange RoadInfoLines::lane_change() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.lane_change)
  return static_cast< ::autodrive::workflow::proto::LaneChange >(lane_change_);
}
inline void RoadInfoLines::set_lane_change(::autodrive::workflow::proto::LaneChange value) {
  
  lane_change_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLines.lane_change)
}

// .autodrive.workflow.proto.RoadInfoLines.DrivingSide driving_side = 9;
inline void RoadInfoLines::clear_driving_side() {
  driving_side_ = 0;
}
inline ::autodrive::workflow::proto::RoadInfoLines_DrivingSide RoadInfoLines::driving_side() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.driving_side)
  return static_cast< ::autodrive::workflow::proto::RoadInfoLines_DrivingSide >(driving_side_);
}
inline void RoadInfoLines::set_driving_side(::autodrive::workflow::proto::RoadInfoLines_DrivingSide value) {
  
  driving_side_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLines.driving_side)
}

// repeated .autodrive.workflow.proto.TransitionPoints transition_points = 10;
inline int RoadInfoLines::transition_points_size() const {
  return transition_points_.size();
}
inline void RoadInfoLines::clear_transition_points() {
  transition_points_.Clear();
}
inline const ::autodrive::workflow::proto::TransitionPoints& RoadInfoLines::transition_points(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.transition_points)
  return transition_points_.Get(index);
}
inline ::autodrive::workflow::proto::TransitionPoints* RoadInfoLines::mutable_transition_points(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoLines.transition_points)
  return transition_points_.Mutable(index);
}
inline ::autodrive::workflow::proto::TransitionPoints* RoadInfoLines::add_transition_points() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.RoadInfoLines.transition_points)
  return transition_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::TransitionPoints >*
RoadInfoLines::mutable_transition_points() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.RoadInfoLines.transition_points)
  return &transition_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::TransitionPoints >&
RoadInfoLines::transition_points() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.RoadInfoLines.transition_points)
  return transition_points_;
}

// .autodrive.workflow.proto.HighWayJunctionInfo highway_junction_info = 11;
inline bool RoadInfoLines::has_highway_junction_info() const {
  return this != internal_default_instance() && highway_junction_info_ != NULL;
}
inline void RoadInfoLines::clear_highway_junction_info() {
  if (GetArenaNoVirtual() == NULL && highway_junction_info_ != NULL) {
    delete highway_junction_info_;
  }
  highway_junction_info_ = NULL;
}
inline const ::autodrive::workflow::proto::HighWayJunctionInfo& RoadInfoLines::highway_junction_info() const {
  const ::autodrive::workflow::proto::HighWayJunctionInfo* p = highway_junction_info_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.highway_junction_info)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::HighWayJunctionInfo*>(
      &::autodrive::workflow::proto::_HighWayJunctionInfo_default_instance_);
}
inline ::autodrive::workflow::proto::HighWayJunctionInfo* RoadInfoLines::release_highway_junction_info() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoLines.highway_junction_info)
  
  ::autodrive::workflow::proto::HighWayJunctionInfo* temp = highway_junction_info_;
  highway_junction_info_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::HighWayJunctionInfo* RoadInfoLines::mutable_highway_junction_info() {
  
  if (highway_junction_info_ == NULL) {
    highway_junction_info_ = new ::autodrive::workflow::proto::HighWayJunctionInfo;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoLines.highway_junction_info)
  return highway_junction_info_;
}
inline void RoadInfoLines::set_allocated_highway_junction_info(::autodrive::workflow::proto::HighWayJunctionInfo* highway_junction_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete highway_junction_info_;
  }
  if (highway_junction_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      highway_junction_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, highway_junction_info, submessage_arena);
    }
    
  } else {
    
  }
  highway_junction_info_ = highway_junction_info;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoLines.highway_junction_info)
}

// .autodrive.workflow.proto.NumberOfLanes number_of_lanes = 12;
inline bool RoadInfoLines::has_number_of_lanes() const {
  return this != internal_default_instance() && number_of_lanes_ != NULL;
}
inline void RoadInfoLines::clear_number_of_lanes() {
  if (GetArenaNoVirtual() == NULL && number_of_lanes_ != NULL) {
    delete number_of_lanes_;
  }
  number_of_lanes_ = NULL;
}
inline const ::autodrive::workflow::proto::NumberOfLanes& RoadInfoLines::number_of_lanes() const {
  const ::autodrive::workflow::proto::NumberOfLanes* p = number_of_lanes_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.number_of_lanes)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::NumberOfLanes*>(
      &::autodrive::workflow::proto::_NumberOfLanes_default_instance_);
}
inline ::autodrive::workflow::proto::NumberOfLanes* RoadInfoLines::release_number_of_lanes() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoLines.number_of_lanes)
  
  ::autodrive::workflow::proto::NumberOfLanes* temp = number_of_lanes_;
  number_of_lanes_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::NumberOfLanes* RoadInfoLines::mutable_number_of_lanes() {
  
  if (number_of_lanes_ == NULL) {
    number_of_lanes_ = new ::autodrive::workflow::proto::NumberOfLanes;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoLines.number_of_lanes)
  return number_of_lanes_;
}
inline void RoadInfoLines::set_allocated_number_of_lanes(::autodrive::workflow::proto::NumberOfLanes* number_of_lanes) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete number_of_lanes_;
  }
  if (number_of_lanes) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      number_of_lanes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, number_of_lanes, submessage_arena);
    }
    
  } else {
    
  }
  number_of_lanes_ = number_of_lanes;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoLines.number_of_lanes)
}

// float host_width = 13;
inline void RoadInfoLines::clear_host_width() {
  host_width_ = 0;
}
inline float RoadInfoLines::host_width() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoLines.host_width)
  return host_width_;
}
inline void RoadInfoLines::set_host_width(float value) {
  
  host_width_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoLines.host_width)
}

// -------------------------------------------------------------------

// StopLines

// float lateral_distance = 1;
inline void StopLines::clear_lateral_distance() {
  lateral_distance_ = 0;
}
inline float StopLines::lateral_distance() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StopLines.lateral_distance)
  return lateral_distance_;
}
inline void StopLines::set_lateral_distance(float value) {
  
  lateral_distance_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StopLines.lateral_distance)
}

// float longitudinal_distance = 2;
inline void StopLines::clear_longitudinal_distance() {
  longitudinal_distance_ = 0;
}
inline float StopLines::longitudinal_distance() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StopLines.longitudinal_distance)
  return longitudinal_distance_;
}
inline void StopLines::set_longitudinal_distance(float value) {
  
  longitudinal_distance_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StopLines.longitudinal_distance)
}

// float angle = 3;
inline void StopLines::clear_angle() {
  angle_ = 0;
}
inline float StopLines::angle() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StopLines.angle)
  return angle_;
}
inline void StopLines::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StopLines.angle)
}

// float confidence = 4;
inline void StopLines::clear_confidence() {
  confidence_ = 0;
}
inline float StopLines::confidence() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StopLines.confidence)
  return confidence_;
}
inline void StopLines::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StopLines.confidence)
}

// uint32 id = 5;
inline void StopLines::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 StopLines::id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StopLines.id)
  return id_;
}
inline void StopLines::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StopLines.id)
}

// .autodrive.workflow.proto.StopLineStatus stop_line_status = 6;
inline void StopLines::clear_stop_line_status() {
  stop_line_status_ = 0;
}
inline ::autodrive::workflow::proto::StopLineStatus StopLines::stop_line_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StopLines.stop_line_status)
  return static_cast< ::autodrive::workflow::proto::StopLineStatus >(stop_line_status_);
}
inline void StopLines::set_stop_line_status(::autodrive::workflow::proto::StopLineStatus value) {
  
  stop_line_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StopLines.stop_line_status)
}

// .autodrive.workflow.proto.StopLineType stop_line_type = 7;
inline void StopLines::clear_stop_line_type() {
  stop_line_type_ = 0;
}
inline ::autodrive::workflow::proto::StopLineType StopLines::stop_line_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StopLines.stop_line_type)
  return static_cast< ::autodrive::workflow::proto::StopLineType >(stop_line_type_);
}
inline void StopLines::set_stop_line_type(::autodrive::workflow::proto::StopLineType value) {
  
  stop_line_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StopLines.stop_line_type)
}

// .autodrive.workflow.proto.StopLineColorType stop_line_color = 8;
inline void StopLines::clear_stop_line_color() {
  stop_line_color_ = 0;
}
inline ::autodrive::workflow::proto::StopLineColorType StopLines::stop_line_color() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StopLines.stop_line_color)
  return static_cast< ::autodrive::workflow::proto::StopLineColorType >(stop_line_color_);
}
inline void StopLines::set_stop_line_color(::autodrive::workflow::proto::StopLineColorType value) {
  
  stop_line_color_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StopLines.stop_line_color)
}

// bool is_relevant = 9;
inline void StopLines::clear_is_relevant() {
  is_relevant_ = false;
}
inline bool StopLines::is_relevant() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.StopLines.is_relevant)
  return is_relevant_;
}
inline void StopLines::set_is_relevant(bool value) {
  
  is_relevant_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.StopLines.is_relevant)
}

// -------------------------------------------------------------------

// Crossings

// float lateral_position = 1;
inline void Crossings::clear_lateral_position() {
  lateral_position_ = 0;
}
inline float Crossings::lateral_position() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Crossings.lateral_position)
  return lateral_position_;
}
inline void Crossings::set_lateral_position(float value) {
  
  lateral_position_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Crossings.lateral_position)
}

// float longitudinal_position = 2;
inline void Crossings::clear_longitudinal_position() {
  longitudinal_position_ = 0;
}
inline float Crossings::longitudinal_position() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Crossings.longitudinal_position)
  return longitudinal_position_;
}
inline void Crossings::set_longitudinal_position(float value) {
  
  longitudinal_position_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Crossings.longitudinal_position)
}

// float confidence = 3;
inline void Crossings::clear_confidence() {
  confidence_ = 0;
}
inline float Crossings::confidence() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Crossings.confidence)
  return confidence_;
}
inline void Crossings::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Crossings.confidence)
}

// uint32 id = 4;
inline void Crossings::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 Crossings::id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Crossings.id)
  return id_;
}
inline void Crossings::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Crossings.id)
}

// .autodrive.workflow.proto.CrossingsType crossings_type = 5;
inline void Crossings::clear_crossings_type() {
  crossings_type_ = 0;
}
inline ::autodrive::workflow::proto::CrossingsType Crossings::crossings_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.Crossings.crossings_type)
  return static_cast< ::autodrive::workflow::proto::CrossingsType >(crossings_type_);
}
inline void Crossings::set_crossings_type(::autodrive::workflow::proto::CrossingsType value) {
  
  crossings_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.Crossings.crossings_type)
}

// -------------------------------------------------------------------

// RoadInfoMsg

// .autodrive.workflow.proto.MsgHeader header = 1;
inline bool RoadInfoMsg::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::MsgHeader& RoadInfoMsg::header() const {
  const ::autodrive::workflow::proto::MsgHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::MsgHeader*>(
      &::autodrive::workflow::proto::_MsgHeader_default_instance_);
}
inline ::autodrive::workflow::proto::MsgHeader* RoadInfoMsg::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoMsg.header)
  
  ::autodrive::workflow::proto::MsgHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::MsgHeader* RoadInfoMsg::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::MsgHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoMsg.header)
  return header_;
}
inline void RoadInfoMsg::set_allocated_header(::autodrive::workflow::proto::MsgHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoMsg.header)
}

// .autodrive.workflow.proto.Error error = 2;
inline bool RoadInfoMsg::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::autodrive::workflow::proto::Error& RoadInfoMsg::error() const {
  const ::autodrive::workflow::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoMsg.error)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Error*>(
      &::autodrive::workflow::proto::_Error_default_instance_);
}
inline ::autodrive::workflow::proto::Error* RoadInfoMsg::release_error() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoMsg.error)
  
  ::autodrive::workflow::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Error* RoadInfoMsg::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::autodrive::workflow::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoMsg.error)
  return error_;
}
inline void RoadInfoMsg::set_allocated_error(::autodrive::workflow::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoMsg.error)
}

// .autodrive.workflow.proto.RoadBorders road_borders = 3;
inline bool RoadInfoMsg::has_road_borders() const {
  return this != internal_default_instance() && road_borders_ != NULL;
}
inline void RoadInfoMsg::clear_road_borders() {
  if (GetArenaNoVirtual() == NULL && road_borders_ != NULL) {
    delete road_borders_;
  }
  road_borders_ = NULL;
}
inline const ::autodrive::workflow::proto::RoadBorders& RoadInfoMsg::road_borders() const {
  const ::autodrive::workflow::proto::RoadBorders* p = road_borders_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoMsg.road_borders)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::RoadBorders*>(
      &::autodrive::workflow::proto::_RoadBorders_default_instance_);
}
inline ::autodrive::workflow::proto::RoadBorders* RoadInfoMsg::release_road_borders() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoMsg.road_borders)
  
  ::autodrive::workflow::proto::RoadBorders* temp = road_borders_;
  road_borders_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::RoadBorders* RoadInfoMsg::mutable_road_borders() {
  
  if (road_borders_ == NULL) {
    road_borders_ = new ::autodrive::workflow::proto::RoadBorders;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoMsg.road_borders)
  return road_borders_;
}
inline void RoadInfoMsg::set_allocated_road_borders(::autodrive::workflow::proto::RoadBorders* road_borders) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete road_borders_;
  }
  if (road_borders) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      road_borders = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, road_borders, submessage_arena);
    }
    
  } else {
    
  }
  road_borders_ = road_borders;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoMsg.road_borders)
}

// .autodrive.workflow.proto.RoadInfoLines lane_lines = 4;
inline bool RoadInfoMsg::has_lane_lines() const {
  return this != internal_default_instance() && lane_lines_ != NULL;
}
inline void RoadInfoMsg::clear_lane_lines() {
  if (GetArenaNoVirtual() == NULL && lane_lines_ != NULL) {
    delete lane_lines_;
  }
  lane_lines_ = NULL;
}
inline const ::autodrive::workflow::proto::RoadInfoLines& RoadInfoMsg::lane_lines() const {
  const ::autodrive::workflow::proto::RoadInfoLines* p = lane_lines_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoMsg.lane_lines)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::RoadInfoLines*>(
      &::autodrive::workflow::proto::_RoadInfoLines_default_instance_);
}
inline ::autodrive::workflow::proto::RoadInfoLines* RoadInfoMsg::release_lane_lines() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoMsg.lane_lines)
  
  ::autodrive::workflow::proto::RoadInfoLines* temp = lane_lines_;
  lane_lines_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::RoadInfoLines* RoadInfoMsg::mutable_lane_lines() {
  
  if (lane_lines_ == NULL) {
    lane_lines_ = new ::autodrive::workflow::proto::RoadInfoLines;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoMsg.lane_lines)
  return lane_lines_;
}
inline void RoadInfoMsg::set_allocated_lane_lines(::autodrive::workflow::proto::RoadInfoLines* lane_lines) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lane_lines_;
  }
  if (lane_lines) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lane_lines = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_lines, submessage_arena);
    }
    
  } else {
    
  }
  lane_lines_ = lane_lines;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoMsg.lane_lines)
}

// .autodrive.workflow.proto.StopLines stop_lines = 5;
inline bool RoadInfoMsg::has_stop_lines() const {
  return this != internal_default_instance() && stop_lines_ != NULL;
}
inline void RoadInfoMsg::clear_stop_lines() {
  if (GetArenaNoVirtual() == NULL && stop_lines_ != NULL) {
    delete stop_lines_;
  }
  stop_lines_ = NULL;
}
inline const ::autodrive::workflow::proto::StopLines& RoadInfoMsg::stop_lines() const {
  const ::autodrive::workflow::proto::StopLines* p = stop_lines_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoMsg.stop_lines)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::StopLines*>(
      &::autodrive::workflow::proto::_StopLines_default_instance_);
}
inline ::autodrive::workflow::proto::StopLines* RoadInfoMsg::release_stop_lines() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoMsg.stop_lines)
  
  ::autodrive::workflow::proto::StopLines* temp = stop_lines_;
  stop_lines_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::StopLines* RoadInfoMsg::mutable_stop_lines() {
  
  if (stop_lines_ == NULL) {
    stop_lines_ = new ::autodrive::workflow::proto::StopLines;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoMsg.stop_lines)
  return stop_lines_;
}
inline void RoadInfoMsg::set_allocated_stop_lines(::autodrive::workflow::proto::StopLines* stop_lines) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stop_lines_;
  }
  if (stop_lines) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stop_lines = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stop_lines, submessage_arena);
    }
    
  } else {
    
  }
  stop_lines_ = stop_lines;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoMsg.stop_lines)
}

// .autodrive.workflow.proto.Crossings crossings = 6;
inline bool RoadInfoMsg::has_crossings() const {
  return this != internal_default_instance() && crossings_ != NULL;
}
inline void RoadInfoMsg::clear_crossings() {
  if (GetArenaNoVirtual() == NULL && crossings_ != NULL) {
    delete crossings_;
  }
  crossings_ = NULL;
}
inline const ::autodrive::workflow::proto::Crossings& RoadInfoMsg::crossings() const {
  const ::autodrive::workflow::proto::Crossings* p = crossings_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoMsg.crossings)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Crossings*>(
      &::autodrive::workflow::proto::_Crossings_default_instance_);
}
inline ::autodrive::workflow::proto::Crossings* RoadInfoMsg::release_crossings() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RoadInfoMsg.crossings)
  
  ::autodrive::workflow::proto::Crossings* temp = crossings_;
  crossings_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Crossings* RoadInfoMsg::mutable_crossings() {
  
  if (crossings_ == NULL) {
    crossings_ = new ::autodrive::workflow::proto::Crossings;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RoadInfoMsg.crossings)
  return crossings_;
}
inline void RoadInfoMsg::set_allocated_crossings(::autodrive::workflow::proto::Crossings* crossings) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete crossings_;
  }
  if (crossings) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      crossings = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, crossings, submessage_arena);
    }
    
  } else {
    
  }
  crossings_ = crossings;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RoadInfoMsg.crossings)
}

// int32 camera_id = 7;
inline void RoadInfoMsg::clear_camera_id() {
  camera_id_ = 0;
}
inline ::google::protobuf::int32 RoadInfoMsg::camera_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RoadInfoMsg.camera_id)
  return camera_id_;
}
inline void RoadInfoMsg::set_camera_id(::google::protobuf::int32 value) {
  
  camera_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RoadInfoMsg.camera_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::RoadInfoLines_DrivingSide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::RoadInfoLines_DrivingSide>() {
  return ::autodrive::workflow::proto::RoadInfoLines_DrivingSide_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::RoadBorderSide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::RoadBorderSide>() {
  return ::autodrive::workflow::proto::RoadBorderSide_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::RoadBorderType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::RoadBorderType>() {
  return ::autodrive::workflow::proto::RoadBorderType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::RoadInfoLineSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::RoadInfoLineSource>() {
  return ::autodrive::workflow::proto::RoadInfoLineSource_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::RoadInfoCurveType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::RoadInfoCurveType>() {
  return ::autodrive::workflow::proto::RoadInfoCurveType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::RoadInfoLineType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::RoadInfoLineType>() {
  return ::autodrive::workflow::proto::RoadInfoLineType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::DlmType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::DlmType>() {
  return ::autodrive::workflow::proto::DlmType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::DecelType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::DecelType>() {
  return ::autodrive::workflow::proto::DecelType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::RoadInfoLineColor> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::RoadInfoLineColor>() {
  return ::autodrive::workflow::proto::RoadInfoLineColor_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::RoadInfoLinePosition> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::RoadInfoLinePosition>() {
  return ::autodrive::workflow::proto::RoadInfoLinePosition_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::TransitionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::TransitionType>() {
  return ::autodrive::workflow::proto::TransitionType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::StopLineStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::StopLineStatus>() {
  return ::autodrive::workflow::proto::StopLineStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::StopLineType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::StopLineType>() {
  return ::autodrive::workflow::proto::StopLineType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::StopLineColorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::StopLineColorType>() {
  return ::autodrive::workflow::proto::StopLineColorType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::CrossingsType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::CrossingsType>() {
  return ::autodrive::workflow::proto::CrossingsType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::LaneChange> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::LaneChange>() {
  return ::autodrive::workflow::proto::LaneChange_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::LineRole> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::LineRole>() {
  return ::autodrive::workflow::proto::LineRole_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::TriggerModel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::TriggerModel>() {
  return ::autodrive::workflow::proto::TriggerModel_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_road_5finfo_2eproto__INCLUDED
