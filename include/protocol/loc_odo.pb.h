// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: loc_odo.proto

#ifndef PROTOBUF_loc_5fodo_2eproto__INCLUDED
#define PROTOBUF_loc_5fodo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_loc_5fodo_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsQuaternion4dImpl();
void InitDefaultsQuaternion4d();
void InitDefaultsOdometryImpl();
void InitDefaultsOdometry();
inline void InitDefaults() {
  InitDefaultsQuaternion4d();
  InitDefaultsOdometry();
}
}  // namespace protobuf_loc_5fodo_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
namespace loc_odo {
class Odometry;
class OdometryDefaultTypeInternal;
extern OdometryDefaultTypeInternal _Odometry_default_instance_;
class Quaternion4d;
class Quaternion4dDefaultTypeInternal;
extern Quaternion4dDefaultTypeInternal _Quaternion4d_default_instance_;
}  // namespace loc_odo
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {
namespace loc_odo {

// ===================================================================

class Quaternion4d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.loc_odo.Quaternion4d) */ {
 public:
  Quaternion4d();
  virtual ~Quaternion4d();

  Quaternion4d(const Quaternion4d& from);

  inline Quaternion4d& operator=(const Quaternion4d& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion4d(Quaternion4d&& from) noexcept
    : Quaternion4d() {
    *this = ::std::move(from);
  }

  inline Quaternion4d& operator=(Quaternion4d&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion4d& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion4d* internal_default_instance() {
    return reinterpret_cast<const Quaternion4d*>(
               &_Quaternion4d_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Quaternion4d* other);
  friend void swap(Quaternion4d& a, Quaternion4d& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion4d* New() const PROTOBUF_FINAL { return New(NULL); }

  Quaternion4d* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Quaternion4d& from);
  void MergeFrom(const Quaternion4d& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Quaternion4d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // double w = 4;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.loc_odo.Quaternion4d)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  double w_;
  mutable int _cached_size_;
  friend struct ::protobuf_loc_5fodo_2eproto::TableStruct;
  friend void ::protobuf_loc_5fodo_2eproto::InitDefaultsQuaternion4dImpl();
};
// -------------------------------------------------------------------

class Odometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.loc_odo.Odometry) */ {
 public:
  Odometry();
  virtual ~Odometry();

  Odometry(const Odometry& from);

  inline Odometry& operator=(const Odometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Odometry(Odometry&& from) noexcept
    : Odometry() {
    *this = ::std::move(from);
  }

  inline Odometry& operator=(Odometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Odometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Odometry* internal_default_instance() {
    return reinterpret_cast<const Odometry*>(
               &_Odometry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Odometry* other);
  friend void swap(Odometry& a, Odometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Odometry* New() const PROTOBUF_FINAL { return New(NULL); }

  Odometry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Odometry& from);
  void MergeFrom(const Odometry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Odometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double pose_cov = 5;
  int pose_cov_size() const;
  void clear_pose_cov();
  static const int kPoseCovFieldNumber = 5;
  double pose_cov(int index) const;
  void set_pose_cov(int index, double value);
  void add_pose_cov(double value);
  const ::google::protobuf::RepeatedField< double >&
      pose_cov() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pose_cov();

  // repeated double twist_cov = 8;
  int twist_cov_size() const;
  void clear_twist_cov();
  static const int kTwistCovFieldNumber = 8;
  double twist_cov(int index) const;
  void set_twist_cov(int index, double value);
  void add_twist_cov(double value);
  const ::google::protobuf::RepeatedField< double >&
      twist_cov() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_twist_cov();

  // .autodrive.workflow.proto.loc_odo.Quaternion4d quaternion = 2;
  bool has_quaternion() const;
  void clear_quaternion();
  static const int kQuaternionFieldNumber = 2;
  const ::autodrive::workflow::proto::loc_odo::Quaternion4d& quaternion() const;
  ::autodrive::workflow::proto::loc_odo::Quaternion4d* release_quaternion();
  ::autodrive::workflow::proto::loc_odo::Quaternion4d* mutable_quaternion();
  void set_allocated_quaternion(::autodrive::workflow::proto::loc_odo::Quaternion4d* quaternion);

  // .autodrive.workflow.proto.Vector3d position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::autodrive::workflow::proto::Vector3d& position() const;
  ::autodrive::workflow::proto::Vector3d* release_position();
  ::autodrive::workflow::proto::Vector3d* mutable_position();
  void set_allocated_position(::autodrive::workflow::proto::Vector3d* position);

  // .autodrive.workflow.proto.Vector3d linear_velocity = 6;
  bool has_linear_velocity() const;
  void clear_linear_velocity();
  static const int kLinearVelocityFieldNumber = 6;
  const ::autodrive::workflow::proto::Vector3d& linear_velocity() const;
  ::autodrive::workflow::proto::Vector3d* release_linear_velocity();
  ::autodrive::workflow::proto::Vector3d* mutable_linear_velocity();
  void set_allocated_linear_velocity(::autodrive::workflow::proto::Vector3d* linear_velocity);

  // .autodrive.workflow.proto.Vector3d angular_velocity = 7;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 7;
  const ::autodrive::workflow::proto::Vector3d& angular_velocity() const;
  ::autodrive::workflow::proto::Vector3d* release_angular_velocity();
  ::autodrive::workflow::proto::Vector3d* mutable_angular_velocity();
  void set_allocated_angular_velocity(::autodrive::workflow::proto::Vector3d* angular_velocity);

  // .autodrive.workflow.proto.Vector3d map_offset = 9;
  bool has_map_offset() const;
  void clear_map_offset();
  static const int kMapOffsetFieldNumber = 9;
  const ::autodrive::workflow::proto::Vector3d& map_offset() const;
  ::autodrive::workflow::proto::Vector3d* release_map_offset();
  ::autodrive::workflow::proto::Vector3d* mutable_map_offset();
  void set_allocated_map_offset(::autodrive::workflow::proto::Vector3d* map_offset);

  // .autodrive.workflow.proto.Vector3d velocity = 10;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 10;
  const ::autodrive::workflow::proto::Vector3d& velocity() const;
  ::autodrive::workflow::proto::Vector3d* release_velocity();
  ::autodrive::workflow::proto::Vector3d* mutable_velocity();
  void set_allocated_velocity(::autodrive::workflow::proto::Vector3d* velocity);

  // .autodrive.workflow.proto.Vector3d acceleration = 11;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 11;
  const ::autodrive::workflow::proto::Vector3d& acceleration() const;
  ::autodrive::workflow::proto::Vector3d* release_acceleration();
  ::autodrive::workflow::proto::Vector3d* mutable_acceleration();
  void set_allocated_acceleration(::autodrive::workflow::proto::Vector3d* acceleration);

  // uint64 stamp = 1;
  void clear_stamp();
  static const int kStampFieldNumber = 1;
  ::google::protobuf::uint64 stamp() const;
  void set_stamp(::google::protobuf::uint64 value);

  // uint32 seq_id = 4;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 4;
  ::google::protobuf::uint32 seq_id() const;
  void set_seq_id(::google::protobuf::uint32 value);

  // float floor = 12;
  void clear_floor();
  static const int kFloorFieldNumber = 12;
  float floor() const;
  void set_floor(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.loc_odo.Odometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > pose_cov_;
  mutable int _pose_cov_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > twist_cov_;
  mutable int _twist_cov_cached_byte_size_;
  ::autodrive::workflow::proto::loc_odo::Quaternion4d* quaternion_;
  ::autodrive::workflow::proto::Vector3d* position_;
  ::autodrive::workflow::proto::Vector3d* linear_velocity_;
  ::autodrive::workflow::proto::Vector3d* angular_velocity_;
  ::autodrive::workflow::proto::Vector3d* map_offset_;
  ::autodrive::workflow::proto::Vector3d* velocity_;
  ::autodrive::workflow::proto::Vector3d* acceleration_;
  ::google::protobuf::uint64 stamp_;
  ::google::protobuf::uint32 seq_id_;
  float floor_;
  mutable int _cached_size_;
  friend struct ::protobuf_loc_5fodo_2eproto::TableStruct;
  friend void ::protobuf_loc_5fodo_2eproto::InitDefaultsOdometryImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Quaternion4d

// double x = 1;
inline void Quaternion4d::clear_x() {
  x_ = 0;
}
inline double Quaternion4d::x() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Quaternion4d.x)
  return x_;
}
inline void Quaternion4d::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.loc_odo.Quaternion4d.x)
}

// double y = 2;
inline void Quaternion4d::clear_y() {
  y_ = 0;
}
inline double Quaternion4d::y() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Quaternion4d.y)
  return y_;
}
inline void Quaternion4d::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.loc_odo.Quaternion4d.y)
}

// double z = 3;
inline void Quaternion4d::clear_z() {
  z_ = 0;
}
inline double Quaternion4d::z() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Quaternion4d.z)
  return z_;
}
inline void Quaternion4d::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.loc_odo.Quaternion4d.z)
}

// double w = 4;
inline void Quaternion4d::clear_w() {
  w_ = 0;
}
inline double Quaternion4d::w() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Quaternion4d.w)
  return w_;
}
inline void Quaternion4d::set_w(double value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.loc_odo.Quaternion4d.w)
}

// -------------------------------------------------------------------

// Odometry

// uint64 stamp = 1;
inline void Odometry::clear_stamp() {
  stamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Odometry::stamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.stamp)
  return stamp_;
}
inline void Odometry::set_stamp(::google::protobuf::uint64 value) {
  
  stamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.loc_odo.Odometry.stamp)
}

// .autodrive.workflow.proto.loc_odo.Quaternion4d quaternion = 2;
inline bool Odometry::has_quaternion() const {
  return this != internal_default_instance() && quaternion_ != NULL;
}
inline void Odometry::clear_quaternion() {
  if (GetArenaNoVirtual() == NULL && quaternion_ != NULL) {
    delete quaternion_;
  }
  quaternion_ = NULL;
}
inline const ::autodrive::workflow::proto::loc_odo::Quaternion4d& Odometry::quaternion() const {
  const ::autodrive::workflow::proto::loc_odo::Quaternion4d* p = quaternion_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.quaternion)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::loc_odo::Quaternion4d*>(
      &::autodrive::workflow::proto::loc_odo::_Quaternion4d_default_instance_);
}
inline ::autodrive::workflow::proto::loc_odo::Quaternion4d* Odometry::release_quaternion() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.loc_odo.Odometry.quaternion)
  
  ::autodrive::workflow::proto::loc_odo::Quaternion4d* temp = quaternion_;
  quaternion_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::loc_odo::Quaternion4d* Odometry::mutable_quaternion() {
  
  if (quaternion_ == NULL) {
    quaternion_ = new ::autodrive::workflow::proto::loc_odo::Quaternion4d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.loc_odo.Odometry.quaternion)
  return quaternion_;
}
inline void Odometry::set_allocated_quaternion(::autodrive::workflow::proto::loc_odo::Quaternion4d* quaternion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete quaternion_;
  }
  if (quaternion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      quaternion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quaternion, submessage_arena);
    }
    
  } else {
    
  }
  quaternion_ = quaternion;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.loc_odo.Odometry.quaternion)
}

// .autodrive.workflow.proto.Vector3d position = 3;
inline bool Odometry::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& Odometry::position() const {
  const ::autodrive::workflow::proto::Vector3d* p = position_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.position)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::release_position() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.loc_odo.Odometry.position)
  
  ::autodrive::workflow::proto::Vector3d* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.loc_odo.Odometry.position)
  return position_;
}
inline void Odometry::set_allocated_position(::autodrive::workflow::proto::Vector3d* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.loc_odo.Odometry.position)
}

// uint32 seq_id = 4;
inline void Odometry::clear_seq_id() {
  seq_id_ = 0u;
}
inline ::google::protobuf::uint32 Odometry::seq_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.seq_id)
  return seq_id_;
}
inline void Odometry::set_seq_id(::google::protobuf::uint32 value) {
  
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.loc_odo.Odometry.seq_id)
}

// repeated double pose_cov = 5;
inline int Odometry::pose_cov_size() const {
  return pose_cov_.size();
}
inline void Odometry::clear_pose_cov() {
  pose_cov_.Clear();
}
inline double Odometry::pose_cov(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.pose_cov)
  return pose_cov_.Get(index);
}
inline void Odometry::set_pose_cov(int index, double value) {
  pose_cov_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.loc_odo.Odometry.pose_cov)
}
inline void Odometry::add_pose_cov(double value) {
  pose_cov_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.loc_odo.Odometry.pose_cov)
}
inline const ::google::protobuf::RepeatedField< double >&
Odometry::pose_cov() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.loc_odo.Odometry.pose_cov)
  return pose_cov_;
}
inline ::google::protobuf::RepeatedField< double >*
Odometry::mutable_pose_cov() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.loc_odo.Odometry.pose_cov)
  return &pose_cov_;
}

// .autodrive.workflow.proto.Vector3d linear_velocity = 6;
inline bool Odometry::has_linear_velocity() const {
  return this != internal_default_instance() && linear_velocity_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& Odometry::linear_velocity() const {
  const ::autodrive::workflow::proto::Vector3d* p = linear_velocity_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.linear_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::release_linear_velocity() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.loc_odo.Odometry.linear_velocity)
  
  ::autodrive::workflow::proto::Vector3d* temp = linear_velocity_;
  linear_velocity_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::mutable_linear_velocity() {
  
  if (linear_velocity_ == NULL) {
    linear_velocity_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.loc_odo.Odometry.linear_velocity)
  return linear_velocity_;
}
inline void Odometry::set_allocated_linear_velocity(::autodrive::workflow::proto::Vector3d* linear_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(linear_velocity_);
  }
  if (linear_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    
  } else {
    
  }
  linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.loc_odo.Odometry.linear_velocity)
}

// .autodrive.workflow.proto.Vector3d angular_velocity = 7;
inline bool Odometry::has_angular_velocity() const {
  return this != internal_default_instance() && angular_velocity_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& Odometry::angular_velocity() const {
  const ::autodrive::workflow::proto::Vector3d* p = angular_velocity_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.angular_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.loc_odo.Odometry.angular_velocity)
  
  ::autodrive::workflow::proto::Vector3d* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::mutable_angular_velocity() {
  
  if (angular_velocity_ == NULL) {
    angular_velocity_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.loc_odo.Odometry.angular_velocity)
  return angular_velocity_;
}
inline void Odometry::set_allocated_angular_velocity(::autodrive::workflow::proto::Vector3d* angular_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(angular_velocity_);
  }
  if (angular_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    
  } else {
    
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.loc_odo.Odometry.angular_velocity)
}

// repeated double twist_cov = 8;
inline int Odometry::twist_cov_size() const {
  return twist_cov_.size();
}
inline void Odometry::clear_twist_cov() {
  twist_cov_.Clear();
}
inline double Odometry::twist_cov(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.twist_cov)
  return twist_cov_.Get(index);
}
inline void Odometry::set_twist_cov(int index, double value) {
  twist_cov_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.loc_odo.Odometry.twist_cov)
}
inline void Odometry::add_twist_cov(double value) {
  twist_cov_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.loc_odo.Odometry.twist_cov)
}
inline const ::google::protobuf::RepeatedField< double >&
Odometry::twist_cov() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.loc_odo.Odometry.twist_cov)
  return twist_cov_;
}
inline ::google::protobuf::RepeatedField< double >*
Odometry::mutable_twist_cov() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.loc_odo.Odometry.twist_cov)
  return &twist_cov_;
}

// .autodrive.workflow.proto.Vector3d map_offset = 9;
inline bool Odometry::has_map_offset() const {
  return this != internal_default_instance() && map_offset_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& Odometry::map_offset() const {
  const ::autodrive::workflow::proto::Vector3d* p = map_offset_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.map_offset)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::release_map_offset() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.loc_odo.Odometry.map_offset)
  
  ::autodrive::workflow::proto::Vector3d* temp = map_offset_;
  map_offset_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::mutable_map_offset() {
  
  if (map_offset_ == NULL) {
    map_offset_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.loc_odo.Odometry.map_offset)
  return map_offset_;
}
inline void Odometry::set_allocated_map_offset(::autodrive::workflow::proto::Vector3d* map_offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(map_offset_);
  }
  if (map_offset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_offset, submessage_arena);
    }
    
  } else {
    
  }
  map_offset_ = map_offset;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.loc_odo.Odometry.map_offset)
}

// .autodrive.workflow.proto.Vector3d velocity = 10;
inline bool Odometry::has_velocity() const {
  return this != internal_default_instance() && velocity_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& Odometry::velocity() const {
  const ::autodrive::workflow::proto::Vector3d* p = velocity_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::release_velocity() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.loc_odo.Odometry.velocity)
  
  ::autodrive::workflow::proto::Vector3d* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::mutable_velocity() {
  
  if (velocity_ == NULL) {
    velocity_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.loc_odo.Odometry.velocity)
  return velocity_;
}
inline void Odometry::set_allocated_velocity(::autodrive::workflow::proto::Vector3d* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_);
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.loc_odo.Odometry.velocity)
}

// .autodrive.workflow.proto.Vector3d acceleration = 11;
inline bool Odometry::has_acceleration() const {
  return this != internal_default_instance() && acceleration_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& Odometry::acceleration() const {
  const ::autodrive::workflow::proto::Vector3d* p = acceleration_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::release_acceleration() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.loc_odo.Odometry.acceleration)
  
  ::autodrive::workflow::proto::Vector3d* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* Odometry::mutable_acceleration() {
  
  if (acceleration_ == NULL) {
    acceleration_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.loc_odo.Odometry.acceleration)
  return acceleration_;
}
inline void Odometry::set_allocated_acceleration(::autodrive::workflow::proto::Vector3d* acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(acceleration_);
  }
  if (acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.loc_odo.Odometry.acceleration)
}

// float floor = 12;
inline void Odometry::clear_floor() {
  floor_ = 0;
}
inline float Odometry::floor() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.loc_odo.Odometry.floor)
  return floor_;
}
inline void Odometry::set_floor(float value) {
  
  floor_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.loc_odo.Odometry.floor)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace loc_odo
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_loc_5fodo_2eproto__INCLUDED
