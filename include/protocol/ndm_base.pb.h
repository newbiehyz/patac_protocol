// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ndm_base.proto

#ifndef PROTOBUF_ndm_5fbase_2eproto__INCLUDED
#define PROTOBUF_ndm_5fbase_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_ndm_5fbase_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsNdmSpecImpl();
void InitDefaultsNdmSpec();
void InitDefaultsIdImpl();
void InitDefaultsId();
void InitDefaultsLinkImpl();
void InitDefaultsLink();
void InitDefaultsNdmVehicleTypeImpl();
void InitDefaultsNdmVehicleType();
void InitDefaultsSpeedLimitImpl();
void InitDefaultsSpeedLimit();
void InitDefaultsNumberImpl();
void InitDefaultsNumber();
void InitDefaultsTimeLimitImpl();
void InitDefaultsTimeLimit();
void InitDefaultsParkingSpaceRestrictionImpl();
void InitDefaultsParkingSpaceRestriction();
void InitDefaultsIndexImpl();
void InitDefaultsIndex();
inline void InitDefaults() {
  InitDefaultsNdmSpec();
  InitDefaultsId();
  InitDefaultsLink();
  InitDefaultsNdmVehicleType();
  InitDefaultsSpeedLimit();
  InitDefaultsNumber();
  InitDefaultsTimeLimit();
  InitDefaultsParkingSpaceRestriction();
  InitDefaultsIndex();
}
}  // namespace protobuf_ndm_5fbase_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
namespace ndm_base {
class Id;
class IdDefaultTypeInternal;
extern IdDefaultTypeInternal _Id_default_instance_;
class Index;
class IndexDefaultTypeInternal;
extern IndexDefaultTypeInternal _Index_default_instance_;
class Link;
class LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class NdmSpec;
class NdmSpecDefaultTypeInternal;
extern NdmSpecDefaultTypeInternal _NdmSpec_default_instance_;
class NdmVehicleType;
class NdmVehicleTypeDefaultTypeInternal;
extern NdmVehicleTypeDefaultTypeInternal _NdmVehicleType_default_instance_;
class Number;
class NumberDefaultTypeInternal;
extern NumberDefaultTypeInternal _Number_default_instance_;
class ParkingSpaceRestriction;
class ParkingSpaceRestrictionDefaultTypeInternal;
extern ParkingSpaceRestrictionDefaultTypeInternal _ParkingSpaceRestriction_default_instance_;
class SpeedLimit;
class SpeedLimitDefaultTypeInternal;
extern SpeedLimitDefaultTypeInternal _SpeedLimit_default_instance_;
class TimeLimit;
class TimeLimitDefaultTypeInternal;
extern TimeLimitDefaultTypeInternal _TimeLimit_default_instance_;
}  // namespace ndm_base
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {
namespace ndm_base {

enum NdmVehicleType_Type {
  NdmVehicleType_Type_kTypeUnknown = 0,
  NdmVehicleType_Type_kTypeCar = 1,
  NdmVehicleType_Type_kTypeMotorcycle = 2,
  NdmVehicleType_Type_kTypeBicycle = 3,
  NdmVehicleType_Type_kTypeTruck = 4,
  NdmVehicleType_Type_kTypeTaxi = 5,
  NdmVehicleType_Type_kTypeBus = 6,
  NdmVehicleType_Type_kTypePedestrian = 7,
  NdmVehicleType_Type_kTypeCableCar = 8,
  NdmVehicleType_Type_NdmVehicleType_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  NdmVehicleType_Type_NdmVehicleType_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool NdmVehicleType_Type_IsValid(int value);
const NdmVehicleType_Type NdmVehicleType_Type_Type_MIN = NdmVehicleType_Type_kTypeUnknown;
const NdmVehicleType_Type NdmVehicleType_Type_Type_MAX = NdmVehicleType_Type_kTypeCableCar;
const int NdmVehicleType_Type_Type_ARRAYSIZE = NdmVehicleType_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* NdmVehicleType_Type_descriptor();
inline const ::std::string& NdmVehicleType_Type_Name(NdmVehicleType_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    NdmVehicleType_Type_descriptor(), value);
}
inline bool NdmVehicleType_Type_Parse(
    const ::std::string& name, NdmVehicleType_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NdmVehicleType_Type>(
    NdmVehicleType_Type_descriptor(), name, value);
}
enum DrivingSide {
  kRightHandDriving = 0,
  kLeftHandDriving = 1,
  DrivingSide_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DrivingSide_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DrivingSide_IsValid(int value);
const DrivingSide DrivingSide_MIN = kRightHandDriving;
const DrivingSide DrivingSide_MAX = kLeftHandDriving;
const int DrivingSide_ARRAYSIZE = DrivingSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* DrivingSide_descriptor();
inline const ::std::string& DrivingSide_Name(DrivingSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    DrivingSide_descriptor(), value);
}
inline bool DrivingSide_Parse(
    const ::std::string& name, DrivingSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DrivingSide>(
    DrivingSide_descriptor(), name, value);
}
enum SpeedLimitType {
  kSpeedLimitTypeUnknown = 0,
  kSpeedLimitTypeMin = 1,
  kSpeedLimitTypeMax = 2,
  SpeedLimitType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SpeedLimitType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SpeedLimitType_IsValid(int value);
const SpeedLimitType SpeedLimitType_MIN = kSpeedLimitTypeUnknown;
const SpeedLimitType SpeedLimitType_MAX = kSpeedLimitTypeMax;
const int SpeedLimitType_ARRAYSIZE = SpeedLimitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpeedLimitType_descriptor();
inline const ::std::string& SpeedLimitType_Name(SpeedLimitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpeedLimitType_descriptor(), value);
}
inline bool SpeedLimitType_Parse(
    const ::std::string& name, SpeedLimitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpeedLimitType>(
    SpeedLimitType_descriptor(), name, value);
}
enum SpeedLimitSource {
  kSpeedLimitSourceUnknown = 0,
  kSpeedLimitSourceImplicit = 1,
  kSpeedLimitSourceExplicit = 2,
  SpeedLimitSource_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SpeedLimitSource_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SpeedLimitSource_IsValid(int value);
const SpeedLimitSource SpeedLimitSource_MIN = kSpeedLimitSourceUnknown;
const SpeedLimitSource SpeedLimitSource_MAX = kSpeedLimitSourceExplicit;
const int SpeedLimitSource_ARRAYSIZE = SpeedLimitSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpeedLimitSource_descriptor();
inline const ::std::string& SpeedLimitSource_Name(SpeedLimitSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpeedLimitSource_descriptor(), value);
}
inline bool SpeedLimitSource_Parse(
    const ::std::string& name, SpeedLimitSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpeedLimitSource>(
    SpeedLimitSource_descriptor(), name, value);
}
// ===================================================================

class NdmSpec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ndm_base.NdmSpec) */ {
 public:
  NdmSpec();
  virtual ~NdmSpec();

  NdmSpec(const NdmSpec& from);

  inline NdmSpec& operator=(const NdmSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NdmSpec(NdmSpec&& from) noexcept
    : NdmSpec() {
    *this = ::std::move(from);
  }

  inline NdmSpec& operator=(NdmSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NdmSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NdmSpec* internal_default_instance() {
    return reinterpret_cast<const NdmSpec*>(
               &_NdmSpec_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(NdmSpec* other);
  friend void swap(NdmSpec& a, NdmSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NdmSpec* New() const PROTOBUF_FINAL { return New(NULL); }

  NdmSpec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NdmSpec& from);
  void MergeFrom(const NdmSpec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NdmSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string date = 2;
  void clear_date();
  static const int kDateFieldNumber = 2;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // string projection = 5;
  void clear_projection();
  static const int kProjectionFieldNumber = 5;
  const ::std::string& projection() const;
  void set_projection(const ::std::string& value);
  #if LANG_CXX11
  void set_projection(::std::string&& value);
  #endif
  void set_projection(const char* value);
  void set_projection(const char* value, size_t size);
  ::std::string* mutable_projection();
  ::std::string* release_projection();
  void set_allocated_projection(::std::string* projection);

  // string utm_zone = 6;
  void clear_utm_zone();
  static const int kUtmZoneFieldNumber = 6;
  const ::std::string& utm_zone() const;
  void set_utm_zone(const ::std::string& value);
  #if LANG_CXX11
  void set_utm_zone(::std::string&& value);
  #endif
  void set_utm_zone(const char* value);
  void set_utm_zone(const char* value, size_t size);
  ::std::string* mutable_utm_zone();
  ::std::string* release_utm_zone();
  void set_allocated_utm_zone(::std::string* utm_zone);

  // .autodrive.workflow.proto.Vector3d base_offset = 7;
  bool has_base_offset() const;
  void clear_base_offset();
  static const int kBaseOffsetFieldNumber = 7;
  const ::autodrive::workflow::proto::Vector3d& base_offset() const;
  ::autodrive::workflow::proto::Vector3d* release_base_offset();
  ::autodrive::workflow::proto::Vector3d* mutable_base_offset();
  void set_allocated_base_offset(::autodrive::workflow::proto::Vector3d* base_offset);

  // uint64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // uint64 seq_id = 4;
  void clear_seq_id();
  static const int kSeqIdFieldNumber = 4;
  ::google::protobuf::uint64 seq_id() const;
  void set_seq_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ndm_base.NdmSpec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr projection_;
  ::google::protobuf::internal::ArenaStringPtr utm_zone_;
  ::autodrive::workflow::proto::Vector3d* base_offset_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint64 seq_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_ndm_5fbase_2eproto::TableStruct;
  friend void ::protobuf_ndm_5fbase_2eproto::InitDefaultsNdmSpecImpl();
};
// -------------------------------------------------------------------

class Id : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ndm_base.Id) */ {
 public:
  Id();
  virtual ~Id();

  Id(const Id& from);

  inline Id& operator=(const Id& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Id(Id&& from) noexcept
    : Id() {
    *this = ::std::move(from);
  }

  inline Id& operator=(Id&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Id& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Id* internal_default_instance() {
    return reinterpret_cast<const Id*>(
               &_Id_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Id* other);
  friend void swap(Id& a, Id& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Id* New() const PROTOBUF_FINAL { return New(NULL); }

  Id* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Id& from);
  void MergeFrom(const Id& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Id* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ndm_base.Id)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_ndm_5fbase_2eproto::TableStruct;
  friend void ::protobuf_ndm_5fbase_2eproto::InitDefaultsIdImpl();
};
// -------------------------------------------------------------------

class Link : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ndm_base.Link) */ {
 public:
  Link();
  virtual ~Link();

  Link(const Link& from);

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(Link&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Link& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Link* other);
  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Link* New() const PROTOBUF_FINAL { return New(NULL); }

  Link* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Link& from);
  void MergeFrom(const Link& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Link* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.ndm_base.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::autodrive::workflow::proto::ndm_base::Id& id() const;
  ::autodrive::workflow::proto::ndm_base::Id* release_id();
  ::autodrive::workflow::proto::ndm_base::Id* mutable_id();
  void set_allocated_id(::autodrive::workflow::proto::ndm_base::Id* id);

  // float offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  float offset() const;
  void set_offset(float value);

  // float end_offset = 3;
  void clear_end_offset();
  static const int kEndOffsetFieldNumber = 3;
  float end_offset() const;
  void set_end_offset(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ndm_base.Link)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::ndm_base::Id* id_;
  float offset_;
  float end_offset_;
  mutable int _cached_size_;
  friend struct ::protobuf_ndm_5fbase_2eproto::TableStruct;
  friend void ::protobuf_ndm_5fbase_2eproto::InitDefaultsLinkImpl();
};
// -------------------------------------------------------------------

class NdmVehicleType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ndm_base.NdmVehicleType) */ {
 public:
  NdmVehicleType();
  virtual ~NdmVehicleType();

  NdmVehicleType(const NdmVehicleType& from);

  inline NdmVehicleType& operator=(const NdmVehicleType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NdmVehicleType(NdmVehicleType&& from) noexcept
    : NdmVehicleType() {
    *this = ::std::move(from);
  }

  inline NdmVehicleType& operator=(NdmVehicleType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NdmVehicleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NdmVehicleType* internal_default_instance() {
    return reinterpret_cast<const NdmVehicleType*>(
               &_NdmVehicleType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NdmVehicleType* other);
  friend void swap(NdmVehicleType& a, NdmVehicleType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NdmVehicleType* New() const PROTOBUF_FINAL { return New(NULL); }

  NdmVehicleType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NdmVehicleType& from);
  void MergeFrom(const NdmVehicleType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NdmVehicleType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef NdmVehicleType_Type Type;
  static const Type kTypeUnknown =
    NdmVehicleType_Type_kTypeUnknown;
  static const Type kTypeCar =
    NdmVehicleType_Type_kTypeCar;
  static const Type kTypeMotorcycle =
    NdmVehicleType_Type_kTypeMotorcycle;
  static const Type kTypeBicycle =
    NdmVehicleType_Type_kTypeBicycle;
  static const Type kTypeTruck =
    NdmVehicleType_Type_kTypeTruck;
  static const Type kTypeTaxi =
    NdmVehicleType_Type_kTypeTaxi;
  static const Type kTypeBus =
    NdmVehicleType_Type_kTypeBus;
  static const Type kTypePedestrian =
    NdmVehicleType_Type_kTypePedestrian;
  static const Type kTypeCableCar =
    NdmVehicleType_Type_kTypeCableCar;
  static inline bool Type_IsValid(int value) {
    return NdmVehicleType_Type_IsValid(value);
  }
  static const Type Type_MIN =
    NdmVehicleType_Type_Type_MIN;
  static const Type Type_MAX =
    NdmVehicleType_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    NdmVehicleType_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return NdmVehicleType_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return NdmVehicleType_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return NdmVehicleType_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.ndm_base.NdmVehicleType.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::autodrive::workflow::proto::ndm_base::NdmVehicleType_Type type() const;
  void set_type(::autodrive::workflow::proto::ndm_base::NdmVehicleType_Type value);

  // float conf = 2;
  void clear_conf();
  static const int kConfFieldNumber = 2;
  float conf() const;
  void set_conf(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ndm_base.NdmVehicleType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  float conf_;
  mutable int _cached_size_;
  friend struct ::protobuf_ndm_5fbase_2eproto::TableStruct;
  friend void ::protobuf_ndm_5fbase_2eproto::InitDefaultsNdmVehicleTypeImpl();
};
// -------------------------------------------------------------------

class SpeedLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ndm_base.SpeedLimit) */ {
 public:
  SpeedLimit();
  virtual ~SpeedLimit();

  SpeedLimit(const SpeedLimit& from);

  inline SpeedLimit& operator=(const SpeedLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeedLimit(SpeedLimit&& from) noexcept
    : SpeedLimit() {
    *this = ::std::move(from);
  }

  inline SpeedLimit& operator=(SpeedLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedLimit* internal_default_instance() {
    return reinterpret_cast<const SpeedLimit*>(
               &_SpeedLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SpeedLimit* other);
  friend void swap(SpeedLimit& a, SpeedLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeedLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  SpeedLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpeedLimit& from);
  void MergeFrom(const SpeedLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpeedLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.ndm_base.SpeedLimitType limit_type = 1;
  void clear_limit_type();
  static const int kLimitTypeFieldNumber = 1;
  ::autodrive::workflow::proto::ndm_base::SpeedLimitType limit_type() const;
  void set_limit_type(::autodrive::workflow::proto::ndm_base::SpeedLimitType value);

  // .autodrive.workflow.proto.ndm_base.SpeedLimitSource source = 2;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  ::autodrive::workflow::proto::ndm_base::SpeedLimitSource source() const;
  void set_source(::autodrive::workflow::proto::ndm_base::SpeedLimitSource value);

  // float speed_value = 3;
  void clear_speed_value();
  static const int kSpeedValueFieldNumber = 3;
  float speed_value() const;
  void set_speed_value(float value);

  // float offset = 4;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  float offset() const;
  void set_offset(float value);

  // float end_offset = 5;
  void clear_end_offset();
  static const int kEndOffsetFieldNumber = 5;
  float end_offset() const;
  void set_end_offset(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ndm_base.SpeedLimit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int limit_type_;
  int source_;
  float speed_value_;
  float offset_;
  float end_offset_;
  mutable int _cached_size_;
  friend struct ::protobuf_ndm_5fbase_2eproto::TableStruct;
  friend void ::protobuf_ndm_5fbase_2eproto::InitDefaultsSpeedLimitImpl();
};
// -------------------------------------------------------------------

class Number : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ndm_base.Number) */ {
 public:
  Number();
  virtual ~Number();

  Number(const Number& from);

  inline Number& operator=(const Number& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Number(Number&& from) noexcept
    : Number() {
    *this = ::std::move(from);
  }

  inline Number& operator=(Number&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Number& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Number* internal_default_instance() {
    return reinterpret_cast<const Number*>(
               &_Number_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Number* other);
  friend void swap(Number& a, Number& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Number* New() const PROTOBUF_FINAL { return New(NULL); }

  Number* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Number& from);
  void MergeFrom(const Number& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Number* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value() const;
  void set_value(float value);

  // float cov = 2;
  void clear_cov();
  static const int kCovFieldNumber = 2;
  float cov() const;
  void set_cov(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ndm_base.Number)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float value_;
  float cov_;
  mutable int _cached_size_;
  friend struct ::protobuf_ndm_5fbase_2eproto::TableStruct;
  friend void ::protobuf_ndm_5fbase_2eproto::InitDefaultsNumberImpl();
};
// -------------------------------------------------------------------

class TimeLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ndm_base.TimeLimit) */ {
 public:
  TimeLimit();
  virtual ~TimeLimit();

  TimeLimit(const TimeLimit& from);

  inline TimeLimit& operator=(const TimeLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeLimit(TimeLimit&& from) noexcept
    : TimeLimit() {
    *this = ::std::move(from);
  }

  inline TimeLimit& operator=(TimeLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeLimit* internal_default_instance() {
    return reinterpret_cast<const TimeLimit*>(
               &_TimeLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TimeLimit* other);
  friend void swap(TimeLimit& a, TimeLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeLimit& from);
  void MergeFrom(const TimeLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float time_begin = 1;
  void clear_time_begin();
  static const int kTimeBeginFieldNumber = 1;
  float time_begin() const;
  void set_time_begin(float value);

  // float time_end = 2;
  void clear_time_end();
  static const int kTimeEndFieldNumber = 2;
  float time_end() const;
  void set_time_end(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ndm_base.TimeLimit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float time_begin_;
  float time_end_;
  mutable int _cached_size_;
  friend struct ::protobuf_ndm_5fbase_2eproto::TableStruct;
  friend void ::protobuf_ndm_5fbase_2eproto::InitDefaultsTimeLimitImpl();
};
// -------------------------------------------------------------------

class ParkingSpaceRestriction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction) */ {
 public:
  ParkingSpaceRestriction();
  virtual ~ParkingSpaceRestriction();

  ParkingSpaceRestriction(const ParkingSpaceRestriction& from);

  inline ParkingSpaceRestriction& operator=(const ParkingSpaceRestriction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingSpaceRestriction(ParkingSpaceRestriction&& from) noexcept
    : ParkingSpaceRestriction() {
    *this = ::std::move(from);
  }

  inline ParkingSpaceRestriction& operator=(ParkingSpaceRestriction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSpaceRestriction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingSpaceRestriction* internal_default_instance() {
    return reinterpret_cast<const ParkingSpaceRestriction*>(
               &_ParkingSpaceRestriction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ParkingSpaceRestriction* other);
  friend void swap(ParkingSpaceRestriction& a, ParkingSpaceRestriction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingSpaceRestriction* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSpaceRestriction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSpaceRestriction& from);
  void MergeFrom(const ParkingSpaceRestriction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSpaceRestriction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.ndm_base.TimeLimit time_limits = 2;
  int time_limits_size() const;
  void clear_time_limits();
  static const int kTimeLimitsFieldNumber = 2;
  const ::autodrive::workflow::proto::ndm_base::TimeLimit& time_limits(int index) const;
  ::autodrive::workflow::proto::ndm_base::TimeLimit* mutable_time_limits(int index);
  ::autodrive::workflow::proto::ndm_base::TimeLimit* add_time_limits();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ndm_base::TimeLimit >*
      mutable_time_limits();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ndm_base::TimeLimit >&
      time_limits() const;

  // repeated .autodrive.workflow.proto.ndm_base.NdmVehicleType vehicle_types = 3;
  int vehicle_types_size() const;
  void clear_vehicle_types();
  static const int kVehicleTypesFieldNumber = 3;
  const ::autodrive::workflow::proto::ndm_base::NdmVehicleType& vehicle_types(int index) const;
  ::autodrive::workflow::proto::ndm_base::NdmVehicleType* mutable_vehicle_types(int index);
  ::autodrive::workflow::proto::ndm_base::NdmVehicleType* add_vehicle_types();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ndm_base::NdmVehicleType >*
      mutable_vehicle_types();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ndm_base::NdmVehicleType >&
      vehicle_types() const;

  // .autodrive.workflow.proto.ndm_base.Number number_limit = 1;
  bool has_number_limit() const;
  void clear_number_limit();
  static const int kNumberLimitFieldNumber = 1;
  const ::autodrive::workflow::proto::ndm_base::Number& number_limit() const;
  ::autodrive::workflow::proto::ndm_base::Number* release_number_limit();
  ::autodrive::workflow::proto::ndm_base::Number* mutable_number_limit();
  void set_allocated_number_limit(::autodrive::workflow::proto::ndm_base::Number* number_limit);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ndm_base::TimeLimit > time_limits_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ndm_base::NdmVehicleType > vehicle_types_;
  ::autodrive::workflow::proto::ndm_base::Number* number_limit_;
  mutable int _cached_size_;
  friend struct ::protobuf_ndm_5fbase_2eproto::TableStruct;
  friend void ::protobuf_ndm_5fbase_2eproto::InitDefaultsParkingSpaceRestrictionImpl();
};
// -------------------------------------------------------------------

class Index : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ndm_base.Index) */ {
 public:
  Index();
  virtual ~Index();

  Index(const Index& from);

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Index(Index&& from) noexcept
    : Index() {
    *this = ::std::move(from);
  }

  inline Index& operator=(Index&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Index& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Index* internal_default_instance() {
    return reinterpret_cast<const Index*>(
               &_Index_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Index* other);
  friend void swap(Index& a, Index& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Index* New() const PROTOBUF_FINAL { return New(NULL); }

  Index* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Index& from);
  void MergeFrom(const Index& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Index* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::uint64 x() const;
  void set_x(::google::protobuf::uint64 value);

  // uint64 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::uint64 y() const;
  void set_y(::google::protobuf::uint64 value);

  // uint64 z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::uint64 z() const;
  void set_z(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ndm_base.Index)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 x_;
  ::google::protobuf::uint64 y_;
  ::google::protobuf::uint64 z_;
  mutable int _cached_size_;
  friend struct ::protobuf_ndm_5fbase_2eproto::TableStruct;
  friend void ::protobuf_ndm_5fbase_2eproto::InitDefaultsIndexImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NdmSpec

// string version = 1;
inline void NdmSpec::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NdmSpec::version() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.NdmSpec.version)
  return version_.GetNoArena();
}
inline void NdmSpec::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.NdmSpec.version)
}
#if LANG_CXX11
inline void NdmSpec::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.ndm_base.NdmSpec.version)
}
#endif
inline void NdmSpec::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.ndm_base.NdmSpec.version)
}
inline void NdmSpec::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.ndm_base.NdmSpec.version)
}
inline ::std::string* NdmSpec::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ndm_base.NdmSpec.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NdmSpec::release_version() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ndm_base.NdmSpec.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NdmSpec::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ndm_base.NdmSpec.version)
}

// string date = 2;
inline void NdmSpec::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NdmSpec::date() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.NdmSpec.date)
  return date_.GetNoArena();
}
inline void NdmSpec::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.NdmSpec.date)
}
#if LANG_CXX11
inline void NdmSpec::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.ndm_base.NdmSpec.date)
}
#endif
inline void NdmSpec::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.ndm_base.NdmSpec.date)
}
inline void NdmSpec::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.ndm_base.NdmSpec.date)
}
inline ::std::string* NdmSpec::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ndm_base.NdmSpec.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NdmSpec::release_date() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ndm_base.NdmSpec.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NdmSpec::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ndm_base.NdmSpec.date)
}

// uint64 timestamp = 3;
inline void NdmSpec::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NdmSpec::timestamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.NdmSpec.timestamp)
  return timestamp_;
}
inline void NdmSpec::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.NdmSpec.timestamp)
}

// uint64 seq_id = 4;
inline void NdmSpec::clear_seq_id() {
  seq_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NdmSpec::seq_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.NdmSpec.seq_id)
  return seq_id_;
}
inline void NdmSpec::set_seq_id(::google::protobuf::uint64 value) {
  
  seq_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.NdmSpec.seq_id)
}

// string projection = 5;
inline void NdmSpec::clear_projection() {
  projection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NdmSpec::projection() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.NdmSpec.projection)
  return projection_.GetNoArena();
}
inline void NdmSpec::set_projection(const ::std::string& value) {
  
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.NdmSpec.projection)
}
#if LANG_CXX11
inline void NdmSpec::set_projection(::std::string&& value) {
  
  projection_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.ndm_base.NdmSpec.projection)
}
#endif
inline void NdmSpec::set_projection(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.ndm_base.NdmSpec.projection)
}
inline void NdmSpec::set_projection(const char* value, size_t size) {
  
  projection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.ndm_base.NdmSpec.projection)
}
inline ::std::string* NdmSpec::mutable_projection() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ndm_base.NdmSpec.projection)
  return projection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NdmSpec::release_projection() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ndm_base.NdmSpec.projection)
  
  return projection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NdmSpec::set_allocated_projection(::std::string* projection) {
  if (projection != NULL) {
    
  } else {
    
  }
  projection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), projection);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ndm_base.NdmSpec.projection)
}

// string utm_zone = 6;
inline void NdmSpec::clear_utm_zone() {
  utm_zone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NdmSpec::utm_zone() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.NdmSpec.utm_zone)
  return utm_zone_.GetNoArena();
}
inline void NdmSpec::set_utm_zone(const ::std::string& value) {
  
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.NdmSpec.utm_zone)
}
#if LANG_CXX11
inline void NdmSpec::set_utm_zone(::std::string&& value) {
  
  utm_zone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.ndm_base.NdmSpec.utm_zone)
}
#endif
inline void NdmSpec::set_utm_zone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.ndm_base.NdmSpec.utm_zone)
}
inline void NdmSpec::set_utm_zone(const char* value, size_t size) {
  
  utm_zone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.ndm_base.NdmSpec.utm_zone)
}
inline ::std::string* NdmSpec::mutable_utm_zone() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ndm_base.NdmSpec.utm_zone)
  return utm_zone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NdmSpec::release_utm_zone() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ndm_base.NdmSpec.utm_zone)
  
  return utm_zone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NdmSpec::set_allocated_utm_zone(::std::string* utm_zone) {
  if (utm_zone != NULL) {
    
  } else {
    
  }
  utm_zone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), utm_zone);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ndm_base.NdmSpec.utm_zone)
}

// .autodrive.workflow.proto.Vector3d base_offset = 7;
inline bool NdmSpec::has_base_offset() const {
  return this != internal_default_instance() && base_offset_ != NULL;
}
inline const ::autodrive::workflow::proto::Vector3d& NdmSpec::base_offset() const {
  const ::autodrive::workflow::proto::Vector3d* p = base_offset_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.NdmSpec.base_offset)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Vector3d*>(
      &::autodrive::workflow::proto::_Vector3d_default_instance_);
}
inline ::autodrive::workflow::proto::Vector3d* NdmSpec::release_base_offset() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ndm_base.NdmSpec.base_offset)
  
  ::autodrive::workflow::proto::Vector3d* temp = base_offset_;
  base_offset_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Vector3d* NdmSpec::mutable_base_offset() {
  
  if (base_offset_ == NULL) {
    base_offset_ = new ::autodrive::workflow::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ndm_base.NdmSpec.base_offset)
  return base_offset_;
}
inline void NdmSpec::set_allocated_base_offset(::autodrive::workflow::proto::Vector3d* base_offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(base_offset_);
  }
  if (base_offset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      base_offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base_offset, submessage_arena);
    }
    
  } else {
    
  }
  base_offset_ = base_offset;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ndm_base.NdmSpec.base_offset)
}

// -------------------------------------------------------------------

// Id

// uint32 id = 1;
inline void Id::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 Id::id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.Id.id)
  return id_;
}
inline void Id::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.Id.id)
}

// bytes name = 2;
inline void Id::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Id::name() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.Id.name)
  return name_.GetNoArena();
}
inline void Id::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.Id.name)
}
#if LANG_CXX11
inline void Id::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.ndm_base.Id.name)
}
#endif
inline void Id::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.ndm_base.Id.name)
}
inline void Id::set_name(const void* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.ndm_base.Id.name)
}
inline ::std::string* Id::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ndm_base.Id.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Id::release_name() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ndm_base.Id.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Id::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ndm_base.Id.name)
}

// -------------------------------------------------------------------

// Link

// .autodrive.workflow.proto.ndm_base.Id id = 1;
inline bool Link::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void Link::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) {
    delete id_;
  }
  id_ = NULL;
}
inline const ::autodrive::workflow::proto::ndm_base::Id& Link::id() const {
  const ::autodrive::workflow::proto::ndm_base::Id* p = id_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.Link.id)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::ndm_base::Id*>(
      &::autodrive::workflow::proto::ndm_base::_Id_default_instance_);
}
inline ::autodrive::workflow::proto::ndm_base::Id* Link::release_id() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ndm_base.Link.id)
  
  ::autodrive::workflow::proto::ndm_base::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::ndm_base::Id* Link::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::autodrive::workflow::proto::ndm_base::Id;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ndm_base.Link.id)
  return id_;
}
inline void Link::set_allocated_id(::autodrive::workflow::proto::ndm_base::Id* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete id_;
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ndm_base.Link.id)
}

// float offset = 2;
inline void Link::clear_offset() {
  offset_ = 0;
}
inline float Link::offset() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.Link.offset)
  return offset_;
}
inline void Link::set_offset(float value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.Link.offset)
}

// float end_offset = 3;
inline void Link::clear_end_offset() {
  end_offset_ = 0;
}
inline float Link::end_offset() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.Link.end_offset)
  return end_offset_;
}
inline void Link::set_end_offset(float value) {
  
  end_offset_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.Link.end_offset)
}

// -------------------------------------------------------------------

// NdmVehicleType

// .autodrive.workflow.proto.ndm_base.NdmVehicleType.Type type = 1;
inline void NdmVehicleType::clear_type() {
  type_ = 0;
}
inline ::autodrive::workflow::proto::ndm_base::NdmVehicleType_Type NdmVehicleType::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.NdmVehicleType.type)
  return static_cast< ::autodrive::workflow::proto::ndm_base::NdmVehicleType_Type >(type_);
}
inline void NdmVehicleType::set_type(::autodrive::workflow::proto::ndm_base::NdmVehicleType_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.NdmVehicleType.type)
}

// float conf = 2;
inline void NdmVehicleType::clear_conf() {
  conf_ = 0;
}
inline float NdmVehicleType::conf() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.NdmVehicleType.conf)
  return conf_;
}
inline void NdmVehicleType::set_conf(float value) {
  
  conf_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.NdmVehicleType.conf)
}

// -------------------------------------------------------------------

// SpeedLimit

// .autodrive.workflow.proto.ndm_base.SpeedLimitType limit_type = 1;
inline void SpeedLimit::clear_limit_type() {
  limit_type_ = 0;
}
inline ::autodrive::workflow::proto::ndm_base::SpeedLimitType SpeedLimit::limit_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.SpeedLimit.limit_type)
  return static_cast< ::autodrive::workflow::proto::ndm_base::SpeedLimitType >(limit_type_);
}
inline void SpeedLimit::set_limit_type(::autodrive::workflow::proto::ndm_base::SpeedLimitType value) {
  
  limit_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.SpeedLimit.limit_type)
}

// .autodrive.workflow.proto.ndm_base.SpeedLimitSource source = 2;
inline void SpeedLimit::clear_source() {
  source_ = 0;
}
inline ::autodrive::workflow::proto::ndm_base::SpeedLimitSource SpeedLimit::source() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.SpeedLimit.source)
  return static_cast< ::autodrive::workflow::proto::ndm_base::SpeedLimitSource >(source_);
}
inline void SpeedLimit::set_source(::autodrive::workflow::proto::ndm_base::SpeedLimitSource value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.SpeedLimit.source)
}

// float speed_value = 3;
inline void SpeedLimit::clear_speed_value() {
  speed_value_ = 0;
}
inline float SpeedLimit::speed_value() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.SpeedLimit.speed_value)
  return speed_value_;
}
inline void SpeedLimit::set_speed_value(float value) {
  
  speed_value_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.SpeedLimit.speed_value)
}

// float offset = 4;
inline void SpeedLimit::clear_offset() {
  offset_ = 0;
}
inline float SpeedLimit::offset() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.SpeedLimit.offset)
  return offset_;
}
inline void SpeedLimit::set_offset(float value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.SpeedLimit.offset)
}

// float end_offset = 5;
inline void SpeedLimit::clear_end_offset() {
  end_offset_ = 0;
}
inline float SpeedLimit::end_offset() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.SpeedLimit.end_offset)
  return end_offset_;
}
inline void SpeedLimit::set_end_offset(float value) {
  
  end_offset_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.SpeedLimit.end_offset)
}

// -------------------------------------------------------------------

// Number

// float value = 1;
inline void Number::clear_value() {
  value_ = 0;
}
inline float Number::value() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.Number.value)
  return value_;
}
inline void Number::set_value(float value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.Number.value)
}

// float cov = 2;
inline void Number::clear_cov() {
  cov_ = 0;
}
inline float Number::cov() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.Number.cov)
  return cov_;
}
inline void Number::set_cov(float value) {
  
  cov_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.Number.cov)
}

// -------------------------------------------------------------------

// TimeLimit

// float time_begin = 1;
inline void TimeLimit::clear_time_begin() {
  time_begin_ = 0;
}
inline float TimeLimit::time_begin() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.TimeLimit.time_begin)
  return time_begin_;
}
inline void TimeLimit::set_time_begin(float value) {
  
  time_begin_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.TimeLimit.time_begin)
}

// float time_end = 2;
inline void TimeLimit::clear_time_end() {
  time_end_ = 0;
}
inline float TimeLimit::time_end() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.TimeLimit.time_end)
  return time_end_;
}
inline void TimeLimit::set_time_end(float value) {
  
  time_end_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.TimeLimit.time_end)
}

// -------------------------------------------------------------------

// ParkingSpaceRestriction

// .autodrive.workflow.proto.ndm_base.Number number_limit = 1;
inline bool ParkingSpaceRestriction::has_number_limit() const {
  return this != internal_default_instance() && number_limit_ != NULL;
}
inline void ParkingSpaceRestriction::clear_number_limit() {
  if (GetArenaNoVirtual() == NULL && number_limit_ != NULL) {
    delete number_limit_;
  }
  number_limit_ = NULL;
}
inline const ::autodrive::workflow::proto::ndm_base::Number& ParkingSpaceRestriction::number_limit() const {
  const ::autodrive::workflow::proto::ndm_base::Number* p = number_limit_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.number_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::ndm_base::Number*>(
      &::autodrive::workflow::proto::ndm_base::_Number_default_instance_);
}
inline ::autodrive::workflow::proto::ndm_base::Number* ParkingSpaceRestriction::release_number_limit() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.number_limit)
  
  ::autodrive::workflow::proto::ndm_base::Number* temp = number_limit_;
  number_limit_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::ndm_base::Number* ParkingSpaceRestriction::mutable_number_limit() {
  
  if (number_limit_ == NULL) {
    number_limit_ = new ::autodrive::workflow::proto::ndm_base::Number;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.number_limit)
  return number_limit_;
}
inline void ParkingSpaceRestriction::set_allocated_number_limit(::autodrive::workflow::proto::ndm_base::Number* number_limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete number_limit_;
  }
  if (number_limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      number_limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, number_limit, submessage_arena);
    }
    
  } else {
    
  }
  number_limit_ = number_limit;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.number_limit)
}

// repeated .autodrive.workflow.proto.ndm_base.TimeLimit time_limits = 2;
inline int ParkingSpaceRestriction::time_limits_size() const {
  return time_limits_.size();
}
inline void ParkingSpaceRestriction::clear_time_limits() {
  time_limits_.Clear();
}
inline const ::autodrive::workflow::proto::ndm_base::TimeLimit& ParkingSpaceRestriction::time_limits(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.time_limits)
  return time_limits_.Get(index);
}
inline ::autodrive::workflow::proto::ndm_base::TimeLimit* ParkingSpaceRestriction::mutable_time_limits(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.time_limits)
  return time_limits_.Mutable(index);
}
inline ::autodrive::workflow::proto::ndm_base::TimeLimit* ParkingSpaceRestriction::add_time_limits() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.time_limits)
  return time_limits_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ndm_base::TimeLimit >*
ParkingSpaceRestriction::mutable_time_limits() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.time_limits)
  return &time_limits_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ndm_base::TimeLimit >&
ParkingSpaceRestriction::time_limits() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.time_limits)
  return time_limits_;
}

// repeated .autodrive.workflow.proto.ndm_base.NdmVehicleType vehicle_types = 3;
inline int ParkingSpaceRestriction::vehicle_types_size() const {
  return vehicle_types_.size();
}
inline void ParkingSpaceRestriction::clear_vehicle_types() {
  vehicle_types_.Clear();
}
inline const ::autodrive::workflow::proto::ndm_base::NdmVehicleType& ParkingSpaceRestriction::vehicle_types(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.vehicle_types)
  return vehicle_types_.Get(index);
}
inline ::autodrive::workflow::proto::ndm_base::NdmVehicleType* ParkingSpaceRestriction::mutable_vehicle_types(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.vehicle_types)
  return vehicle_types_.Mutable(index);
}
inline ::autodrive::workflow::proto::ndm_base::NdmVehicleType* ParkingSpaceRestriction::add_vehicle_types() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.vehicle_types)
  return vehicle_types_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ndm_base::NdmVehicleType >*
ParkingSpaceRestriction::mutable_vehicle_types() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.vehicle_types)
  return &vehicle_types_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ndm_base::NdmVehicleType >&
ParkingSpaceRestriction::vehicle_types() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ndm_base.ParkingSpaceRestriction.vehicle_types)
  return vehicle_types_;
}

// -------------------------------------------------------------------

// Index

// uint64 x = 1;
inline void Index::clear_x() {
  x_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Index::x() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.Index.x)
  return x_;
}
inline void Index::set_x(::google::protobuf::uint64 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.Index.x)
}

// uint64 y = 2;
inline void Index::clear_y() {
  y_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Index::y() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.Index.y)
  return y_;
}
inline void Index::set_y(::google::protobuf::uint64 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.Index.y)
}

// uint64 z = 3;
inline void Index::clear_z() {
  z_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Index::z() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ndm_base.Index.z)
  return z_;
}
inline void Index::set_z(::google::protobuf::uint64 value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ndm_base.Index.z)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ndm_base
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::ndm_base::NdmVehicleType_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ndm_base::NdmVehicleType_Type>() {
  return ::autodrive::workflow::proto::ndm_base::NdmVehicleType_Type_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ndm_base::DrivingSide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ndm_base::DrivingSide>() {
  return ::autodrive::workflow::proto::ndm_base::DrivingSide_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ndm_base::SpeedLimitType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ndm_base::SpeedLimitType>() {
  return ::autodrive::workflow::proto::ndm_base::SpeedLimitType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ndm_base::SpeedLimitSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ndm_base::SpeedLimitSource>() {
  return ::autodrive::workflow::proto::ndm_base::SpeedLimitSource_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ndm_5fbase_2eproto__INCLUDED
