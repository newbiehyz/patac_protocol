// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: parsing.proto

#ifndef PROTOBUF_parsing_2eproto__INCLUDED
#define PROTOBUF_parsing_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "perception_base.pb.h"
#include "parsing_base.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_parsing_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsParsingImageImpl();
void InitDefaultsParsingImage();
void InitDefaultsCameraValidHeightImpl();
void InitDefaultsCameraValidHeight();
void InitDefaultsVCSParamImpl();
void InitDefaultsVCSParam();
void InitDefaultsDistortParamImpl();
void InitDefaultsDistortParam();
void InitDefaultsCameraParamImpl();
void InitDefaultsCameraParam();
void InitDefaultsParsingColorImpl();
void InitDefaultsParsingColor();
void InitDefaultsRuntimeModelInfoImpl();
void InitDefaultsRuntimeModelInfo();
void InitDefaultsParsingSettingImpl();
void InitDefaultsParsingSetting();
void InitDefaultsDepthSettingImpl();
void InitDefaultsDepthSetting();
void InitDefaultsParsingImageDataImpl();
void InitDefaultsParsingImageData();
void InitDefaultsParsingMsgImpl();
void InitDefaultsParsingMsg();
inline void InitDefaults() {
  InitDefaultsParsingImage();
  InitDefaultsCameraValidHeight();
  InitDefaultsVCSParam();
  InitDefaultsDistortParam();
  InitDefaultsCameraParam();
  InitDefaultsParsingColor();
  InitDefaultsRuntimeModelInfo();
  InitDefaultsParsingSetting();
  InitDefaultsDepthSetting();
  InitDefaultsParsingImageData();
  InitDefaultsParsingMsg();
}
}  // namespace protobuf_parsing_2eproto
namespace autodrive {
namespace workflow {
namespace proto {
class CameraParam;
class CameraParamDefaultTypeInternal;
extern CameraParamDefaultTypeInternal _CameraParam_default_instance_;
class CameraValidHeight;
class CameraValidHeightDefaultTypeInternal;
extern CameraValidHeightDefaultTypeInternal _CameraValidHeight_default_instance_;
class DepthSetting;
class DepthSettingDefaultTypeInternal;
extern DepthSettingDefaultTypeInternal _DepthSetting_default_instance_;
class DistortParam;
class DistortParamDefaultTypeInternal;
extern DistortParamDefaultTypeInternal _DistortParam_default_instance_;
class ParsingColor;
class ParsingColorDefaultTypeInternal;
extern ParsingColorDefaultTypeInternal _ParsingColor_default_instance_;
class ParsingImage;
class ParsingImageDefaultTypeInternal;
extern ParsingImageDefaultTypeInternal _ParsingImage_default_instance_;
class ParsingImageData;
class ParsingImageDataDefaultTypeInternal;
extern ParsingImageDataDefaultTypeInternal _ParsingImageData_default_instance_;
class ParsingMsg;
class ParsingMsgDefaultTypeInternal;
extern ParsingMsgDefaultTypeInternal _ParsingMsg_default_instance_;
class ParsingSetting;
class ParsingSettingDefaultTypeInternal;
extern ParsingSettingDefaultTypeInternal _ParsingSetting_default_instance_;
class RuntimeModelInfo;
class RuntimeModelInfoDefaultTypeInternal;
extern RuntimeModelInfoDefaultTypeInternal _RuntimeModelInfo_default_instance_;
class VCSParam;
class VCSParamDefaultTypeInternal;
extern VCSParamDefaultTypeInternal _VCSParam_default_instance_;
}  // namespace proto
}  // namespace workflow
}  // namespace autodrive
namespace autodrive {
namespace workflow {
namespace proto {

enum CompressionFormat {
  kOriginalImage = 0,
  kOriginalImageHalf = 1,
  kOriginalImageQuarter = 2,
  kCompressionJPEG = 3,
  kCompressionH265I = 4,
  kCompressionH265P = 5,
  CompressionFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CompressionFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CompressionFormat_IsValid(int value);
const CompressionFormat CompressionFormat_MIN = kOriginalImage;
const CompressionFormat CompressionFormat_MAX = kCompressionH265P;
const int CompressionFormat_ARRAYSIZE = CompressionFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* CompressionFormat_descriptor();
inline const ::std::string& CompressionFormat_Name(CompressionFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    CompressionFormat_descriptor(), value);
}
inline bool CompressionFormat_Parse(
    const ::std::string& name, CompressionFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompressionFormat>(
    CompressionFormat_descriptor(), name, value);
}
enum ImageFormat {
  kImageFormatGray = 0,
  kImageFormatYV12 = 1,
  kImageFormatJPEG = 2,
  kImageFormatPNG = 3,
  kImageFormatCR12 = 4,
  kImageFormatBad = 5,
  kImageFormatNV12 = 6,
  kImageFormatNV21 = 7,
  kImageFormatTimeout = 8,
  kImageFormatBypassOnly = 9,
  kImageFormatYUYV = 10,
  kImageFormatUYVY = 11,
  kImageFormatRaw12Planar = 12,
  kImageFormatRaw12PlanarJPEG = 13,
  kImageFormatRaw12PlanarJPEGLossless = 14,
  kImageFormatRaw12 = 15,
  kImageFormatRaw12JPEG = 16,
  kImageFormatRaw12JPEGLossless = 17,
  kImageFormatRaw16 = 18,
  kImageFormatRaw16JPEG = 19,
  kImageFormatRaw16JPEGLossless = 20,
  kImageFormatRaw20 = 21,
  kImageFormatRaw20JPEG = 22,
  kImageFormatRaw20JPEGLossless = 23,
  kImageFormatRaw20Planar = 24,
  kImageFormatRaw20PlanarJPEG = 25,
  kImageFormatRaw20PlanarJPEGLossless = 26,
  kImageFormatRaw16WithFront = 27,
  kImageFormatRaw16WithRear = 28,
  kImageFormatRaw16WithFrontRear = 29,
  kImageFormatRaw16PlanarJPEGLossless = 30,
  kImageFormatRaw14PlanarJPEGLossless = 31,
  kImageFormatBitstream = 32,
  kImageFormatBitstreamH264 = 33,
  ImageFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ImageFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ImageFormat_IsValid(int value);
const ImageFormat ImageFormat_MIN = kImageFormatGray;
const ImageFormat ImageFormat_MAX = kImageFormatBitstreamH264;
const int ImageFormat_ARRAYSIZE = ImageFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor();
inline const ::std::string& ImageFormat_Name(ImageFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageFormat_descriptor(), value);
}
inline bool ImageFormat_Parse(
    const ::std::string& name, ImageFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageFormat>(
    ImageFormat_descriptor(), name, value);
}
enum ParsingFormat {
  kParsingFormatRaw = 0,
  kParsingFormatLabel = 1,
  kParsingFormatLabelRLE = 2,
  ParsingFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParsingFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParsingFormat_IsValid(int value);
const ParsingFormat ParsingFormat_MIN = kParsingFormatRaw;
const ParsingFormat ParsingFormat_MAX = kParsingFormatLabelRLE;
const int ParsingFormat_ARRAYSIZE = ParsingFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParsingFormat_descriptor();
inline const ::std::string& ParsingFormat_Name(ParsingFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParsingFormat_descriptor(), value);
}
inline bool ParsingFormat_Parse(
    const ::std::string& name, ParsingFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParsingFormat>(
    ParsingFormat_descriptor(), name, value);
}
enum IPMSelect {
  kIPMSelectNinetyDistant = 0,
  kIPMSelectFortyDistant = 1,
  kIPMSelectFortyHalfWidth = 2,
  kIPMSelectTwentyDistant = 3,
  IPMSelect_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  IPMSelect_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool IPMSelect_IsValid(int value);
const IPMSelect IPMSelect_MIN = kIPMSelectNinetyDistant;
const IPMSelect IPMSelect_MAX = kIPMSelectTwentyDistant;
const int IPMSelect_ARRAYSIZE = IPMSelect_MAX + 1;

const ::google::protobuf::EnumDescriptor* IPMSelect_descriptor();
inline const ::std::string& IPMSelect_Name(IPMSelect value) {
  return ::google::protobuf::internal::NameOfEnum(
    IPMSelect_descriptor(), value);
}
inline bool IPMSelect_Parse(
    const ::std::string& name, IPMSelect* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IPMSelect>(
    IPMSelect_descriptor(), name, value);
}
enum PerceptionStatus {
  kPerceptionStatusNoPerception = 0,
  kPerceptionStatusWithPerception = 1,
  PerceptionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PerceptionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PerceptionStatus_IsValid(int value);
const PerceptionStatus PerceptionStatus_MIN = kPerceptionStatusNoPerception;
const PerceptionStatus PerceptionStatus_MAX = kPerceptionStatusWithPerception;
const int PerceptionStatus_ARRAYSIZE = PerceptionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* PerceptionStatus_descriptor();
inline const ::std::string& PerceptionStatus_Name(PerceptionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    PerceptionStatus_descriptor(), value);
}
inline bool PerceptionStatus_Parse(
    const ::std::string& name, PerceptionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PerceptionStatus>(
    PerceptionStatus_descriptor(), name, value);
}
enum ImageStatus {
  kImageStatusNormal = 0,
  kImageStatusNoInterrupt = 1,
  ImageStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ImageStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ImageStatus_IsValid(int value);
const ImageStatus ImageStatus_MIN = kImageStatusNormal;
const ImageStatus ImageStatus_MAX = kImageStatusNoInterrupt;
const int ImageStatus_ARRAYSIZE = ImageStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageStatus_descriptor();
inline const ::std::string& ImageStatus_Name(ImageStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageStatus_descriptor(), value);
}
inline bool ImageStatus_Parse(
    const ::std::string& name, ImageStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageStatus>(
    ImageStatus_descriptor(), name, value);
}
enum CameraType {
  kCameraTypePinHole = 0,
  kCameraTypeFishEye = 1,
  CameraType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CameraType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CameraType_IsValid(int value);
const CameraType CameraType_MIN = kCameraTypePinHole;
const CameraType CameraType_MAX = kCameraTypeFishEye;
const int CameraType_ARRAYSIZE = CameraType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CameraType_descriptor();
inline const ::std::string& CameraType_Name(CameraType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CameraType_descriptor(), value);
}
inline bool CameraType_Parse(
    const ::std::string& name, CameraType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraType>(
    CameraType_descriptor(), name, value);
}
enum CameraVersion {
  kCameraVersionCV = 0,
  kCameraVersionVCS = 1,
  CameraVersion_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CameraVersion_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CameraVersion_IsValid(int value);
const CameraVersion CameraVersion_MIN = kCameraVersionCV;
const CameraVersion CameraVersion_MAX = kCameraVersionVCS;
const int CameraVersion_ARRAYSIZE = CameraVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* CameraVersion_descriptor();
inline const ::std::string& CameraVersion_Name(CameraVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    CameraVersion_descriptor(), value);
}
inline bool CameraVersion_Parse(
    const ::std::string& name, CameraVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraVersion>(
    CameraVersion_descriptor(), name, value);
}
enum ParsingCalibrationStatus {
  kCalibrationStatusDefault = 0,
  kCalibrationStatusIntrinsicDone = 1,
  kCalibrationStatusExtrinsicDone = 2,
  ParsingCalibrationStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParsingCalibrationStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParsingCalibrationStatus_IsValid(int value);
const ParsingCalibrationStatus ParsingCalibrationStatus_MIN = kCalibrationStatusDefault;
const ParsingCalibrationStatus ParsingCalibrationStatus_MAX = kCalibrationStatusExtrinsicDone;
const int ParsingCalibrationStatus_ARRAYSIZE = ParsingCalibrationStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParsingCalibrationStatus_descriptor();
inline const ::std::string& ParsingCalibrationStatus_Name(ParsingCalibrationStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParsingCalibrationStatus_descriptor(), value);
}
inline bool ParsingCalibrationStatus_Parse(
    const ::std::string& name, ParsingCalibrationStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParsingCalibrationStatus>(
    ParsingCalibrationStatus_descriptor(), name, value);
}
enum CalibrationType {
  kCalibrationTypeUnknown = 0,
  kCalibrationTypeEOL = 1,
  kCalibrationTypeAfterSale = 2,
  kCalibrationTypeBackground = 3,
  CalibrationType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CalibrationType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CalibrationType_IsValid(int value);
const CalibrationType CalibrationType_MIN = kCalibrationTypeUnknown;
const CalibrationType CalibrationType_MAX = kCalibrationTypeBackground;
const int CalibrationType_ARRAYSIZE = CalibrationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CalibrationType_descriptor();
inline const ::std::string& CalibrationType_Name(CalibrationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CalibrationType_descriptor(), value);
}
inline bool CalibrationType_Parse(
    const ::std::string& name, CalibrationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CalibrationType>(
    CalibrationType_descriptor(), name, value);
}
enum ParsingType {
  kParsingTypeDefault = 0,
  kParsingTypeLane = 1,
  kParsingTypeDepth = 2,
  kParsingTypeIPM = 3,
  kParsingTypeBEV = 4,
  kParsingTypeIQA = 5,
  ParsingType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParsingType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParsingType_IsValid(int value);
const ParsingType ParsingType_MIN = kParsingTypeDefault;
const ParsingType ParsingType_MAX = kParsingTypeIQA;
const int ParsingType_ARRAYSIZE = ParsingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParsingType_descriptor();
inline const ::std::string& ParsingType_Name(ParsingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParsingType_descriptor(), value);
}
inline bool ParsingType_Parse(
    const ::std::string& name, ParsingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParsingType>(
    ParsingType_descriptor(), name, value);
}
// ===================================================================

class ParsingImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ParsingImage) */ {
 public:
  ParsingImage();
  virtual ~ParsingImage();

  ParsingImage(const ParsingImage& from);

  inline ParsingImage& operator=(const ParsingImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParsingImage(ParsingImage&& from) noexcept
    : ParsingImage() {
    *this = ::std::move(from);
  }

  inline ParsingImage& operator=(ParsingImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParsingImage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParsingImage* internal_default_instance() {
    return reinterpret_cast<const ParsingImage*>(
               &_ParsingImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ParsingImage* other);
  friend void swap(ParsingImage& a, ParsingImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParsingImage* New() const PROTOBUF_FINAL { return New(NULL); }

  ParsingImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParsingImage& from);
  void MergeFrom(const ParsingImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParsingImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .autodrive.workflow.proto.perception_base.RoiMap roi_map = 16;
  int roi_map_size() const;
  void clear_roi_map();
  static const int kRoiMapFieldNumber = 16;
  const ::autodrive::workflow::proto::perception_base::RoiMap& roi_map(int index) const;
  ::autodrive::workflow::proto::perception_base::RoiMap* mutable_roi_map(int index);
  ::autodrive::workflow::proto::perception_base::RoiMap* add_roi_map();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::RoiMap >*
      mutable_roi_map();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::RoiMap >&
      roi_map() const;

  // int32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // int32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 channel = 3;
  void clear_channel();
  static const int kChannelFieldNumber = 3;
  ::google::protobuf::int32 channel() const;
  void set_channel(::google::protobuf::int32 value);

  // int32 send_mod = 4;
  void clear_send_mod();
  static const int kSendModFieldNumber = 4;
  ::google::protobuf::int32 send_mod() const;
  void set_send_mod(::google::protobuf::int32 value);

  // int64 time_stamp = 5;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 5;
  ::google::protobuf::int64 time_stamp() const;
  void set_time_stamp(::google::protobuf::int64 value);

  // int32 format = 6;
  void clear_format();
  static const int kFormatFieldNumber = 6;
  ::google::protobuf::int32 format() const;
  void set_format(::google::protobuf::int32 value);

  // int32 index = 7;
  void clear_index();
  static const int kIndexFieldNumber = 7;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // int32 count = 8;
  void clear_count();
  static const int kCountFieldNumber = 8;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // int32 depth = 9;
  void clear_depth();
  static const int kDepthFieldNumber = 9;
  ::google::protobuf::int32 depth() const;
  void set_depth(::google::protobuf::int32 value);

  // int32 align = 10;
  void clear_align();
  static const int kAlignFieldNumber = 10;
  ::google::protobuf::int32 align() const;
  void set_align(::google::protobuf::int32 value);

  // uint32 image_counter = 11;
  void clear_image_counter();
  static const int kImageCounterFieldNumber = 11;
  ::google::protobuf::uint32 image_counter() const;
  void set_image_counter(::google::protobuf::uint32 value);

  // int64 bypass_time_diff = 13;
  void clear_bypass_time_diff();
  static const int kBypassTimeDiffFieldNumber = 13;
  ::google::protobuf::int64 bypass_time_diff() const;
  void set_bypass_time_diff(::google::protobuf::int64 value);

  // int32 perception_status = 12;
  void clear_perception_status();
  static const int kPerceptionStatusFieldNumber = 12;
  ::google::protobuf::int32 perception_status() const;
  void set_perception_status(::google::protobuf::int32 value);

  // int32 compression_format = 14;
  void clear_compression_format();
  static const int kCompressionFormatFieldNumber = 14;
  ::google::protobuf::int32 compression_format() const;
  void set_compression_format(::google::protobuf::int32 value);

  // int32 status = 15;
  void clear_status();
  static const int kStatusFieldNumber = 15;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // int32 perception_mode = 17;
  void clear_perception_mode();
  static const int kPerceptionModeFieldNumber = 17;
  ::google::protobuf::int32 perception_mode() const;
  void set_perception_mode(::google::protobuf::int32 value);

  // int32 postprocessor_status = 18;
  void clear_postprocessor_status();
  static const int kPostprocessorStatusFieldNumber = 18;
  ::google::protobuf::int32 postprocessor_status() const;
  void set_postprocessor_status(::google::protobuf::int32 value);

  // int32 frame_id = 19;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 19;
  ::google::protobuf::int32 frame_id() const;
  void set_frame_id(::google::protobuf::int32 value);

  // int64 time_stamp_us = 21;
  void clear_time_stamp_us();
  static const int kTimeStampUsFieldNumber = 21;
  ::google::protobuf::int64 time_stamp_us() const;
  void set_time_stamp_us(::google::protobuf::int64 value);

  // uint64 hw_time_stamp = 22;
  void clear_hw_time_stamp();
  static const int kHwTimeStampFieldNumber = 22;
  ::google::protobuf::uint64 hw_time_stamp() const;
  void set_hw_time_stamp(::google::protobuf::uint64 value);

  // int64 mcu_time_diff = 23;
  void clear_mcu_time_diff();
  static const int kMcuTimeDiffFieldNumber = 23;
  ::google::protobuf::int64 mcu_time_diff() const;
  void set_mcu_time_diff(::google::protobuf::int64 value);

  // int64 mcu_board_timediff = 24;
  void clear_mcu_board_timediff();
  static const int kMcuBoardTimediffFieldNumber = 24;
  ::google::protobuf::int64 mcu_board_timediff() const;
  void set_mcu_board_timediff(::google::protobuf::int64 value);

  // int32 step = 20;
  void clear_step();
  static const int kStepFieldNumber = 20;
  ::google::protobuf::int32 step() const;
  void set_step(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ParsingImage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::RoiMap > roi_map_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 send_mod_;
  ::google::protobuf::int64 time_stamp_;
  ::google::protobuf::int32 format_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 depth_;
  ::google::protobuf::int32 align_;
  ::google::protobuf::uint32 image_counter_;
  ::google::protobuf::int64 bypass_time_diff_;
  ::google::protobuf::int32 perception_status_;
  ::google::protobuf::int32 compression_format_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 perception_mode_;
  ::google::protobuf::int32 postprocessor_status_;
  ::google::protobuf::int32 frame_id_;
  ::google::protobuf::int64 time_stamp_us_;
  ::google::protobuf::uint64 hw_time_stamp_;
  ::google::protobuf::int64 mcu_time_diff_;
  ::google::protobuf::int64 mcu_board_timediff_;
  ::google::protobuf::int32 step_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsParsingImageImpl();
};
// -------------------------------------------------------------------

class CameraValidHeight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.CameraValidHeight) */ {
 public:
  CameraValidHeight();
  virtual ~CameraValidHeight();

  CameraValidHeight(const CameraValidHeight& from);

  inline CameraValidHeight& operator=(const CameraValidHeight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraValidHeight(CameraValidHeight&& from) noexcept
    : CameraValidHeight() {
    *this = ::std::move(from);
  }

  inline CameraValidHeight& operator=(CameraValidHeight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraValidHeight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraValidHeight* internal_default_instance() {
    return reinterpret_cast<const CameraValidHeight*>(
               &_CameraValidHeight_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CameraValidHeight* other);
  friend void swap(CameraValidHeight& a, CameraValidHeight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraValidHeight* New() const PROTOBUF_FINAL { return New(NULL); }

  CameraValidHeight* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CameraValidHeight& from);
  void MergeFrom(const CameraValidHeight& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CameraValidHeight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 left_y = 1;
  void clear_left_y();
  static const int kLeftYFieldNumber = 1;
  ::google::protobuf::int32 left_y() const;
  void set_left_y(::google::protobuf::int32 value);

  // int32 right_y = 2;
  void clear_right_y();
  static const int kRightYFieldNumber = 2;
  ::google::protobuf::int32 right_y() const;
  void set_right_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.CameraValidHeight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 left_y_;
  ::google::protobuf::int32 right_y_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsCameraValidHeightImpl();
};
// -------------------------------------------------------------------

class VCSParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.VCSParam) */ {
 public:
  VCSParam();
  virtual ~VCSParam();

  VCSParam(const VCSParam& from);

  inline VCSParam& operator=(const VCSParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VCSParam(VCSParam&& from) noexcept
    : VCSParam() {
    *this = ::std::move(from);
  }

  inline VCSParam& operator=(VCSParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VCSParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VCSParam* internal_default_instance() {
    return reinterpret_cast<const VCSParam*>(
               &_VCSParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(VCSParam* other);
  friend void swap(VCSParam& a, VCSParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VCSParam* New() const PROTOBUF_FINAL { return New(NULL); }

  VCSParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VCSParam& from);
  void MergeFrom(const VCSParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VCSParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float rotation = 1;
  int rotation_size() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 1;
  float rotation(int index) const;
  void set_rotation(int index, float value);
  void add_rotation(float value);
  const ::google::protobuf::RepeatedField< float >&
      rotation() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_rotation();

  // repeated float translation = 2;
  int translation_size() const;
  void clear_translation();
  static const int kTranslationFieldNumber = 2;
  float translation(int index) const;
  void set_translation(int index, float value);
  void add_translation(float value);
  const ::google::protobuf::RepeatedField< float >&
      translation() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_translation();

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.VCSParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > rotation_;
  mutable int _rotation_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > translation_;
  mutable int _translation_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsVCSParamImpl();
};
// -------------------------------------------------------------------

class DistortParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.DistortParam) */ {
 public:
  DistortParam();
  virtual ~DistortParam();

  DistortParam(const DistortParam& from);

  inline DistortParam& operator=(const DistortParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DistortParam(DistortParam&& from) noexcept
    : DistortParam() {
    *this = ::std::move(from);
  }

  inline DistortParam& operator=(DistortParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DistortParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DistortParam* internal_default_instance() {
    return reinterpret_cast<const DistortParam*>(
               &_DistortParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DistortParam* other);
  friend void swap(DistortParam& a, DistortParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DistortParam* New() const PROTOBUF_FINAL { return New(NULL); }

  DistortParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DistortParam& from);
  void MergeFrom(const DistortParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DistortParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float param = 1;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 1;
  float param(int index) const;
  void set_param(int index, float value);
  void add_param(float value);
  const ::google::protobuf::RepeatedField< float >&
      param() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_param();

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.DistortParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > param_;
  mutable int _param_cached_byte_size_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsDistortParamImpl();
};
// -------------------------------------------------------------------

class CameraParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.CameraParam) */ {
 public:
  CameraParam();
  virtual ~CameraParam();

  CameraParam(const CameraParam& from);

  inline CameraParam& operator=(const CameraParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraParam(CameraParam&& from) noexcept
    : CameraParam() {
    *this = ::std::move(from);
  }

  inline CameraParam& operator=(CameraParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraParam* internal_default_instance() {
    return reinterpret_cast<const CameraParam*>(
               &_CameraParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CameraParam* other);
  friend void swap(CameraParam& a, CameraParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraParam* New() const PROTOBUF_FINAL { return New(NULL); }

  CameraParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CameraParam& from);
  void MergeFrom(const CameraParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CameraParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.CameraValidHeight valid_height = 15;
  bool has_valid_height() const;
  void clear_valid_height();
  static const int kValidHeightFieldNumber = 15;
  const ::autodrive::workflow::proto::CameraValidHeight& valid_height() const;
  ::autodrive::workflow::proto::CameraValidHeight* release_valid_height();
  ::autodrive::workflow::proto::CameraValidHeight* mutable_valid_height();
  void set_allocated_valid_height(::autodrive::workflow::proto::CameraValidHeight* valid_height);

  // .autodrive.workflow.proto.DistortParam distort = 16;
  bool has_distort() const;
  void clear_distort();
  static const int kDistortFieldNumber = 16;
  const ::autodrive::workflow::proto::DistortParam& distort() const;
  ::autodrive::workflow::proto::DistortParam* release_distort();
  ::autodrive::workflow::proto::DistortParam* mutable_distort();
  void set_allocated_distort(::autodrive::workflow::proto::DistortParam* distort);

  // .autodrive.workflow.proto.VCSParam vcs = 17;
  bool has_vcs() const;
  void clear_vcs();
  static const int kVcsFieldNumber = 17;
  const ::autodrive::workflow::proto::VCSParam& vcs() const;
  ::autodrive::workflow::proto::VCSParam* release_vcs();
  ::autodrive::workflow::proto::VCSParam* mutable_vcs();
  void set_allocated_vcs(::autodrive::workflow::proto::VCSParam* vcs);

  // .autodrive.workflow.proto.perception_base.CameraMatrix mat = 18;
  bool has_mat() const;
  void clear_mat();
  static const int kMatFieldNumber = 18;
  const ::autodrive::workflow::proto::perception_base::CameraMatrix& mat() const;
  ::autodrive::workflow::proto::perception_base::CameraMatrix* release_mat();
  ::autodrive::workflow::proto::perception_base::CameraMatrix* mutable_mat();
  void set_allocated_mat(::autodrive::workflow::proto::perception_base::CameraMatrix* mat);

  // float focal_u = 1;
  void clear_focal_u();
  static const int kFocalUFieldNumber = 1;
  float focal_u() const;
  void set_focal_u(float value);

  // float focal_v = 2;
  void clear_focal_v();
  static const int kFocalVFieldNumber = 2;
  float focal_v() const;
  void set_focal_v(float value);

  // float center_u = 3;
  void clear_center_u();
  static const int kCenterUFieldNumber = 3;
  float center_u() const;
  void set_center_u(float value);

  // float center_v = 4;
  void clear_center_v();
  static const int kCenterVFieldNumber = 4;
  float center_v() const;
  void set_center_v(float value);

  // float camera_x = 5;
  void clear_camera_x();
  static const int kCameraXFieldNumber = 5;
  float camera_x() const;
  void set_camera_x(float value);

  // float camera_y = 6;
  void clear_camera_y();
  static const int kCameraYFieldNumber = 6;
  float camera_y() const;
  void set_camera_y(float value);

  // float camera_z = 7;
  void clear_camera_z();
  static const int kCameraZFieldNumber = 7;
  float camera_z() const;
  void set_camera_z(float value);

  // float pitch = 8;
  void clear_pitch();
  static const int kPitchFieldNumber = 8;
  float pitch() const;
  void set_pitch(float value);

  // float yaw = 9;
  void clear_yaw();
  static const int kYawFieldNumber = 9;
  float yaw() const;
  void set_yaw(float value);

  // float roll = 10;
  void clear_roll();
  static const int kRollFieldNumber = 10;
  float roll() const;
  void set_roll(float value);

  // int32 type = 11;
  void clear_type();
  static const int kTypeFieldNumber = 11;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // float fov = 12;
  void clear_fov();
  static const int kFovFieldNumber = 12;
  float fov() const;
  void set_fov(float value);

  // int32 version = 13;
  void clear_version();
  static const int kVersionFieldNumber = 13;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // .autodrive.workflow.proto.ParsingCalibrationStatus cali_status = 14;
  void clear_cali_status();
  static const int kCaliStatusFieldNumber = 14;
  ::autodrive::workflow::proto::ParsingCalibrationStatus cali_status() const;
  void set_cali_status(::autodrive::workflow::proto::ParsingCalibrationStatus value);

  // int64 time_stamp = 19;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 19;
  ::google::protobuf::int64 time_stamp() const;
  void set_time_stamp(::google::protobuf::int64 value);

  // int32 cam_id = 20;
  void clear_cam_id();
  static const int kCamIdFieldNumber = 20;
  ::google::protobuf::int32 cam_id() const;
  void set_cam_id(::google::protobuf::int32 value);

  // int32 frame_id = 21;
  void clear_frame_id();
  static const int kFrameIdFieldNumber = 21;
  ::google::protobuf::int32 frame_id() const;
  void set_frame_id(::google::protobuf::int32 value);

  // int32 image_height = 22;
  void clear_image_height();
  static const int kImageHeightFieldNumber = 22;
  ::google::protobuf::int32 image_height() const;
  void set_image_height(::google::protobuf::int32 value);

  // int32 image_width = 23;
  void clear_image_width();
  static const int kImageWidthFieldNumber = 23;
  ::google::protobuf::int32 image_width() const;
  void set_image_width(::google::protobuf::int32 value);

  // int32 base_calib_done = 24;
  void clear_base_calib_done();
  static const int kBaseCalibDoneFieldNumber = 24;
  ::google::protobuf::int32 base_calib_done() const;
  void set_base_calib_done(::google::protobuf::int32 value);

  // .autodrive.workflow.proto.CalibrationType calib_src = 25;
  void clear_calib_src();
  static const int kCalibSrcFieldNumber = 25;
  ::autodrive::workflow::proto::CalibrationType calib_src() const;
  void set_calib_src(::autodrive::workflow::proto::CalibrationType value);

  // int64 calib_done_ts = 26;
  void clear_calib_done_ts();
  static const int kCalibDoneTsFieldNumber = 26;
  ::google::protobuf::int64 calib_done_ts() const;
  void set_calib_done_ts(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.CameraParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::CameraValidHeight* valid_height_;
  ::autodrive::workflow::proto::DistortParam* distort_;
  ::autodrive::workflow::proto::VCSParam* vcs_;
  ::autodrive::workflow::proto::perception_base::CameraMatrix* mat_;
  float focal_u_;
  float focal_v_;
  float center_u_;
  float center_v_;
  float camera_x_;
  float camera_y_;
  float camera_z_;
  float pitch_;
  float yaw_;
  float roll_;
  ::google::protobuf::int32 type_;
  float fov_;
  ::google::protobuf::int32 version_;
  int cali_status_;
  ::google::protobuf::int64 time_stamp_;
  ::google::protobuf::int32 cam_id_;
  ::google::protobuf::int32 frame_id_;
  ::google::protobuf::int32 image_height_;
  ::google::protobuf::int32 image_width_;
  ::google::protobuf::int32 base_calib_done_;
  int calib_src_;
  ::google::protobuf::int64 calib_done_ts_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsCameraParamImpl();
};
// -------------------------------------------------------------------

class ParsingColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ParsingColor) */ {
 public:
  ParsingColor();
  virtual ~ParsingColor();

  ParsingColor(const ParsingColor& from);

  inline ParsingColor& operator=(const ParsingColor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParsingColor(ParsingColor&& from) noexcept
    : ParsingColor() {
    *this = ::std::move(from);
  }

  inline ParsingColor& operator=(ParsingColor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParsingColor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParsingColor* internal_default_instance() {
    return reinterpret_cast<const ParsingColor*>(
               &_ParsingColor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ParsingColor* other);
  friend void swap(ParsingColor& a, ParsingColor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParsingColor* New() const PROTOBUF_FINAL { return New(NULL); }

  ParsingColor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParsingColor& from);
  void MergeFrom(const ParsingColor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParsingColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 b = 1;
  void clear_b();
  static const int kBFieldNumber = 1;
  ::google::protobuf::uint32 b() const;
  void set_b(::google::protobuf::uint32 value);

  // uint32 g = 2;
  void clear_g();
  static const int kGFieldNumber = 2;
  ::google::protobuf::uint32 g() const;
  void set_g(::google::protobuf::uint32 value);

  // uint32 r = 3;
  void clear_r();
  static const int kRFieldNumber = 3;
  ::google::protobuf::uint32 r() const;
  void set_r(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ParsingColor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 b_;
  ::google::protobuf::uint32 g_;
  ::google::protobuf::uint32 r_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsParsingColorImpl();
};
// -------------------------------------------------------------------

class RuntimeModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.RuntimeModelInfo) */ {
 public:
  RuntimeModelInfo();
  virtual ~RuntimeModelInfo();

  RuntimeModelInfo(const RuntimeModelInfo& from);

  inline RuntimeModelInfo& operator=(const RuntimeModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RuntimeModelInfo(RuntimeModelInfo&& from) noexcept
    : RuntimeModelInfo() {
    *this = ::std::move(from);
  }

  inline RuntimeModelInfo& operator=(RuntimeModelInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RuntimeModelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RuntimeModelInfo* internal_default_instance() {
    return reinterpret_cast<const RuntimeModelInfo*>(
               &_RuntimeModelInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(RuntimeModelInfo* other);
  friend void swap(RuntimeModelInfo& a, RuntimeModelInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RuntimeModelInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RuntimeModelInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RuntimeModelInfo& from);
  void MergeFrom(const RuntimeModelInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RuntimeModelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string model_name = 2;
  void clear_model_name();
  static const int kModelNameFieldNumber = 2;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // int32 model_id = 1;
  void clear_model_id();
  static const int kModelIdFieldNumber = 1;
  ::google::protobuf::int32 model_id() const;
  void set_model_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.RuntimeModelInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::int32 model_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsRuntimeModelInfoImpl();
};
// -------------------------------------------------------------------

class ParsingSetting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ParsingSetting) */ {
 public:
  ParsingSetting();
  virtual ~ParsingSetting();

  ParsingSetting(const ParsingSetting& from);

  inline ParsingSetting& operator=(const ParsingSetting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParsingSetting(ParsingSetting&& from) noexcept
    : ParsingSetting() {
    *this = ::std::move(from);
  }

  inline ParsingSetting& operator=(ParsingSetting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParsingSetting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParsingSetting* internal_default_instance() {
    return reinterpret_cast<const ParsingSetting*>(
               &_ParsingSetting_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ParsingSetting* other);
  friend void swap(ParsingSetting& a, ParsingSetting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParsingSetting* New() const PROTOBUF_FINAL { return New(NULL); }

  ParsingSetting* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParsingSetting& from);
  void MergeFrom(const ParsingSetting& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParsingSetting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 channel_labels = 4;
  int channel_labels_size() const;
  void clear_channel_labels();
  static const int kChannelLabelsFieldNumber = 4;
  ::google::protobuf::uint64 channel_labels(int index) const;
  void set_channel_labels(int index, ::google::protobuf::uint64 value);
  void add_channel_labels(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      channel_labels() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_channel_labels();

  // repeated .autodrive.workflow.proto.ParsingColor channel_colors = 5;
  int channel_colors_size() const;
  void clear_channel_colors();
  static const int kChannelColorsFieldNumber = 5;
  const ::autodrive::workflow::proto::ParsingColor& channel_colors(int index) const;
  ::autodrive::workflow::proto::ParsingColor* mutable_channel_colors(int index);
  ::autodrive::workflow::proto::ParsingColor* add_channel_colors();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ParsingColor >*
      mutable_channel_colors();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ParsingColor >&
      channel_colors() const;

  // repeated int32 freespace_channels = 6;
  int freespace_channels_size() const;
  void clear_freespace_channels();
  static const int kFreespaceChannelsFieldNumber = 6;
  ::google::protobuf::int32 freespace_channels(int index) const;
  void set_freespace_channels(int index, ::google::protobuf::int32 value);
  void add_freespace_channels(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      freespace_channels() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_freespace_channels();

  // repeated int32 boundspace_channels = 7;
  int boundspace_channels_size() const;
  void clear_boundspace_channels();
  static const int kBoundspaceChannelsFieldNumber = 7;
  ::google::protobuf::int32 boundspace_channels(int index) const;
  void set_boundspace_channels(int index, ::google::protobuf::int32 value);
  void add_boundspace_channels(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      boundspace_channels() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_boundspace_channels();

  // repeated .autodrive.workflow.proto.RuntimeModelInfo model_info = 10;
  int model_info_size() const;
  void clear_model_info();
  static const int kModelInfoFieldNumber = 10;
  const ::autodrive::workflow::proto::RuntimeModelInfo& model_info(int index) const;
  ::autodrive::workflow::proto::RuntimeModelInfo* mutable_model_info(int index);
  ::autodrive::workflow::proto::RuntimeModelInfo* add_model_info();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RuntimeModelInfo >*
      mutable_model_info();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RuntimeModelInfo >&
      model_info() const;

  // repeated .autodrive.workflow.proto.perception_base.Category categories = 11;
  int categories_size() const;
  void clear_categories();
  static const int kCategoriesFieldNumber = 11;
  const ::autodrive::workflow::proto::perception_base::Category& categories(int index) const;
  ::autodrive::workflow::proto::perception_base::Category* mutable_categories(int index);
  ::autodrive::workflow::proto::perception_base::Category* add_categories();
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >*
      mutable_categories();
  const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >&
      categories() const;

  // .autodrive.workflow.proto.perception_base.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::perception_base::Header& header() const;
  ::autodrive::workflow::proto::perception_base::Header* release_header();
  ::autodrive::workflow::proto::perception_base::Header* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::perception_base::Header* header);

  // .autodrive.workflow.proto.perception_base.Rect parsing_roi = 8;
  bool has_parsing_roi() const;
  void clear_parsing_roi();
  static const int kParsingRoiFieldNumber = 8;
  const ::autodrive::workflow::proto::perception_base::Rect& parsing_roi() const;
  ::autodrive::workflow::proto::perception_base::Rect* release_parsing_roi();
  ::autodrive::workflow::proto::perception_base::Rect* mutable_parsing_roi();
  void set_allocated_parsing_roi(::autodrive::workflow::proto::perception_base::Rect* parsing_roi);

  // int32 parsing_type = 2;
  void clear_parsing_type();
  static const int kParsingTypeFieldNumber = 2;
  ::google::protobuf::int32 parsing_type() const;
  void set_parsing_type(::google::protobuf::int32 value);

  // int32 parsing_channels = 3;
  void clear_parsing_channels();
  static const int kParsingChannelsFieldNumber = 3;
  ::google::protobuf::int32 parsing_channels() const;
  void set_parsing_channels(::google::protobuf::int32 value);

  // float parsing_scale = 9;
  void clear_parsing_scale();
  static const int kParsingScaleFieldNumber = 9;
  float parsing_scale() const;
  void set_parsing_scale(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ParsingSetting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > channel_labels_;
  mutable int _channel_labels_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ParsingColor > channel_colors_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > freespace_channels_;
  mutable int _freespace_channels_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > boundspace_channels_;
  mutable int _boundspace_channels_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RuntimeModelInfo > model_info_;
  ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category > categories_;
  ::autodrive::workflow::proto::perception_base::Header* header_;
  ::autodrive::workflow::proto::perception_base::Rect* parsing_roi_;
  ::google::protobuf::int32 parsing_type_;
  ::google::protobuf::int32 parsing_channels_;
  float parsing_scale_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsParsingSettingImpl();
};
// -------------------------------------------------------------------

class DepthSetting : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.DepthSetting) */ {
 public:
  DepthSetting();
  virtual ~DepthSetting();

  DepthSetting(const DepthSetting& from);

  inline DepthSetting& operator=(const DepthSetting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DepthSetting(DepthSetting&& from) noexcept
    : DepthSetting() {
    *this = ::std::move(from);
  }

  inline DepthSetting& operator=(DepthSetting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DepthSetting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DepthSetting* internal_default_instance() {
    return reinterpret_cast<const DepthSetting*>(
               &_DepthSetting_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(DepthSetting* other);
  friend void swap(DepthSetting& a, DepthSetting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DepthSetting* New() const PROTOBUF_FINAL { return New(NULL); }

  DepthSetting* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DepthSetting& from);
  void MergeFrom(const DepthSetting& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DepthSetting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.CameraParam camera_param = 10;
  bool has_camera_param() const;
  void clear_camera_param();
  static const int kCameraParamFieldNumber = 10;
  const ::autodrive::workflow::proto::CameraParam& camera_param() const;
  ::autodrive::workflow::proto::CameraParam* release_camera_param();
  ::autodrive::workflow::proto::CameraParam* mutable_camera_param();
  void set_allocated_camera_param(::autodrive::workflow::proto::CameraParam* camera_param);

  // float scale_number = 1;
  void clear_scale_number();
  static const int kScaleNumberFieldNumber = 1;
  float scale_number() const;
  void set_scale_number(float value);

  // float shift_scale = 2;
  void clear_shift_scale();
  static const int kShiftScaleFieldNumber = 2;
  float shift_scale() const;
  void set_shift_scale(float value);

  // uint32 mapping_type = 3;
  void clear_mapping_type();
  static const int kMappingTypeFieldNumber = 3;
  ::google::protobuf::uint32 mapping_type() const;
  void set_mapping_type(::google::protobuf::uint32 value);

  // uint32 mapping_shift = 4;
  void clear_mapping_shift();
  static const int kMappingShiftFieldNumber = 4;
  ::google::protobuf::uint32 mapping_shift() const;
  void set_mapping_shift(::google::protobuf::uint32 value);

  // float confidence_scale = 5;
  void clear_confidence_scale();
  static const int kConfidenceScaleFieldNumber = 5;
  float confidence_scale() const;
  void set_confidence_scale(float value);

  // float max_depth = 6;
  void clear_max_depth();
  static const int kMaxDepthFieldNumber = 6;
  float max_depth() const;
  void set_max_depth(float value);

  // float min_depth = 7;
  void clear_min_depth();
  static const int kMinDepthFieldNumber = 7;
  float min_depth() const;
  void set_min_depth(float value);

  // float max_confidence = 8;
  void clear_max_confidence();
  static const int kMaxConfidenceFieldNumber = 8;
  float max_confidence() const;
  void set_max_confidence(float value);

  // float min_confidence = 9;
  void clear_min_confidence();
  static const int kMinConfidenceFieldNumber = 9;
  float min_confidence() const;
  void set_min_confidence(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.DepthSetting)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::CameraParam* camera_param_;
  float scale_number_;
  float shift_scale_;
  ::google::protobuf::uint32 mapping_type_;
  ::google::protobuf::uint32 mapping_shift_;
  float confidence_scale_;
  float max_depth_;
  float min_depth_;
  float max_confidence_;
  float min_confidence_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsDepthSettingImpl();
};
// -------------------------------------------------------------------

class ParsingImageData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ParsingImageData) */ {
 public:
  ParsingImageData();
  virtual ~ParsingImageData();

  ParsingImageData(const ParsingImageData& from);

  inline ParsingImageData& operator=(const ParsingImageData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParsingImageData(ParsingImageData&& from) noexcept
    : ParsingImageData() {
    *this = ::std::move(from);
  }

  inline ParsingImageData& operator=(ParsingImageData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParsingImageData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParsingImageData* internal_default_instance() {
    return reinterpret_cast<const ParsingImageData*>(
               &_ParsingImageData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ParsingImageData* other);
  friend void swap(ParsingImageData& a, ParsingImageData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParsingImageData* New() const PROTOBUF_FINAL { return New(NULL); }

  ParsingImageData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParsingImageData& from);
  void MergeFrom(const ParsingImageData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParsingImageData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint32 width = 2;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // uint32 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // uint32 channel = 4;
  void clear_channel();
  static const int kChannelFieldNumber = 4;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ParsingImageData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 channel_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsParsingImageDataImpl();
};
// -------------------------------------------------------------------

class ParsingMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autodrive.workflow.proto.ParsingMsg) */ {
 public:
  ParsingMsg();
  virtual ~ParsingMsg();

  ParsingMsg(const ParsingMsg& from);

  inline ParsingMsg& operator=(const ParsingMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParsingMsg(ParsingMsg&& from) noexcept
    : ParsingMsg() {
    *this = ::std::move(from);
  }

  inline ParsingMsg& operator=(ParsingMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParsingMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParsingMsg* internal_default_instance() {
    return reinterpret_cast<const ParsingMsg*>(
               &_ParsingMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ParsingMsg* other);
  friend void swap(ParsingMsg& a, ParsingMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParsingMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  ParsingMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParsingMsg& from);
  void MergeFrom(const ParsingMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParsingMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .autodrive.workflow.proto.MsgHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::autodrive::workflow::proto::MsgHeader& header() const;
  ::autodrive::workflow::proto::MsgHeader* release_header();
  ::autodrive::workflow::proto::MsgHeader* mutable_header();
  void set_allocated_header(::autodrive::workflow::proto::MsgHeader* header);

  // .autodrive.workflow.proto.Error error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::autodrive::workflow::proto::Error& error() const;
  ::autodrive::workflow::proto::Error* release_error();
  ::autodrive::workflow::proto::Error* mutable_error();
  void set_allocated_error(::autodrive::workflow::proto::Error* error);

  // .autodrive.workflow.proto.ParsingImageData free_space = 3;
  bool has_free_space() const;
  void clear_free_space();
  static const int kFreeSpaceFieldNumber = 3;
  const ::autodrive::workflow::proto::ParsingImageData& free_space() const;
  ::autodrive::workflow::proto::ParsingImageData* release_free_space();
  ::autodrive::workflow::proto::ParsingImageData* mutable_free_space();
  void set_allocated_free_space(::autodrive::workflow::proto::ParsingImageData* free_space);

  // .autodrive.workflow.proto.ParsingImageData feature_map = 4;
  bool has_feature_map() const;
  void clear_feature_map();
  static const int kFeatureMapFieldNumber = 4;
  const ::autodrive::workflow::proto::ParsingImageData& feature_map() const;
  ::autodrive::workflow::proto::ParsingImageData* release_feature_map();
  ::autodrive::workflow::proto::ParsingImageData* mutable_feature_map();
  void set_allocated_feature_map(::autodrive::workflow::proto::ParsingImageData* feature_map);

  // .autodrive.workflow.proto.RleCompressedData rle_parsing_compressed = 5;
  bool has_rle_parsing_compressed() const;
  void clear_rle_parsing_compressed();
  static const int kRleParsingCompressedFieldNumber = 5;
  const ::autodrive::workflow::proto::RleCompressedData& rle_parsing_compressed() const;
  ::autodrive::workflow::proto::RleCompressedData* release_rle_parsing_compressed();
  ::autodrive::workflow::proto::RleCompressedData* mutable_rle_parsing_compressed();
  void set_allocated_rle_parsing_compressed(::autodrive::workflow::proto::RleCompressedData* rle_parsing_compressed);

  // .autodrive.workflow.proto.perception_base.Rect roi_output = 7;
  bool has_roi_output() const;
  void clear_roi_output();
  static const int kRoiOutputFieldNumber = 7;
  const ::autodrive::workflow::proto::perception_base::Rect& roi_output() const;
  ::autodrive::workflow::proto::perception_base::Rect* release_roi_output();
  ::autodrive::workflow::proto::perception_base::Rect* mutable_roi_output();
  void set_allocated_roi_output(::autodrive::workflow::proto::perception_base::Rect* roi_output);

  // .autodrive.workflow.proto.ParsingImage image = 8;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 8;
  const ::autodrive::workflow::proto::ParsingImage& image() const;
  ::autodrive::workflow::proto::ParsingImage* release_image();
  ::autodrive::workflow::proto::ParsingImage* mutable_image();
  void set_allocated_image(::autodrive::workflow::proto::ParsingImage* image);

  // .autodrive.workflow.proto.ParsingSetting parsing_setting = 9;
  bool has_parsing_setting() const;
  void clear_parsing_setting();
  static const int kParsingSettingFieldNumber = 9;
  const ::autodrive::workflow::proto::ParsingSetting& parsing_setting() const;
  ::autodrive::workflow::proto::ParsingSetting* release_parsing_setting();
  ::autodrive::workflow::proto::ParsingSetting* mutable_parsing_setting();
  void set_allocated_parsing_setting(::autodrive::workflow::proto::ParsingSetting* parsing_setting);

  // .autodrive.workflow.proto.DepthSetting depth_setting = 10;
  bool has_depth_setting() const;
  void clear_depth_setting();
  static const int kDepthSettingFieldNumber = 10;
  const ::autodrive::workflow::proto::DepthSetting& depth_setting() const;
  ::autodrive::workflow::proto::DepthSetting* release_depth_setting();
  ::autodrive::workflow::proto::DepthSetting* mutable_depth_setting();
  void set_allocated_depth_setting(::autodrive::workflow::proto::DepthSetting* depth_setting);

  // float scale = 6;
  void clear_scale();
  static const int kScaleFieldNumber = 6;
  float scale() const;
  void set_scale(float value);

  // @@protoc_insertion_point(class_scope:autodrive.workflow.proto.ParsingMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::autodrive::workflow::proto::MsgHeader* header_;
  ::autodrive::workflow::proto::Error* error_;
  ::autodrive::workflow::proto::ParsingImageData* free_space_;
  ::autodrive::workflow::proto::ParsingImageData* feature_map_;
  ::autodrive::workflow::proto::RleCompressedData* rle_parsing_compressed_;
  ::autodrive::workflow::proto::perception_base::Rect* roi_output_;
  ::autodrive::workflow::proto::ParsingImage* image_;
  ::autodrive::workflow::proto::ParsingSetting* parsing_setting_;
  ::autodrive::workflow::proto::DepthSetting* depth_setting_;
  float scale_;
  mutable int _cached_size_;
  friend struct ::protobuf_parsing_2eproto::TableStruct;
  friend void ::protobuf_parsing_2eproto::InitDefaultsParsingMsgImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ParsingImage

// int32 width = 1;
inline void ParsingImage::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::width() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.width)
  return width_;
}
inline void ParsingImage::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.width)
}

// int32 height = 2;
inline void ParsingImage::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::height() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.height)
  return height_;
}
inline void ParsingImage::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.height)
}

// int32 channel = 3;
inline void ParsingImage::clear_channel() {
  channel_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::channel() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.channel)
  return channel_;
}
inline void ParsingImage::set_channel(::google::protobuf::int32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.channel)
}

// int32 send_mod = 4;
inline void ParsingImage::clear_send_mod() {
  send_mod_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::send_mod() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.send_mod)
  return send_mod_;
}
inline void ParsingImage::set_send_mod(::google::protobuf::int32 value) {
  
  send_mod_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.send_mod)
}

// int64 time_stamp = 5;
inline void ParsingImage::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ParsingImage::time_stamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.time_stamp)
  return time_stamp_;
}
inline void ParsingImage::set_time_stamp(::google::protobuf::int64 value) {
  
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.time_stamp)
}

// int32 format = 6;
inline void ParsingImage::clear_format() {
  format_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::format() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.format)
  return format_;
}
inline void ParsingImage::set_format(::google::protobuf::int32 value) {
  
  format_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.format)
}

// int32 index = 7;
inline void ParsingImage::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::index() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.index)
  return index_;
}
inline void ParsingImage::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.index)
}

// int32 count = 8;
inline void ParsingImage::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::count() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.count)
  return count_;
}
inline void ParsingImage::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.count)
}

// int32 depth = 9;
inline void ParsingImage::clear_depth() {
  depth_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::depth() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.depth)
  return depth_;
}
inline void ParsingImage::set_depth(::google::protobuf::int32 value) {
  
  depth_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.depth)
}

// int32 align = 10;
inline void ParsingImage::clear_align() {
  align_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::align() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.align)
  return align_;
}
inline void ParsingImage::set_align(::google::protobuf::int32 value) {
  
  align_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.align)
}

// uint32 image_counter = 11;
inline void ParsingImage::clear_image_counter() {
  image_counter_ = 0u;
}
inline ::google::protobuf::uint32 ParsingImage::image_counter() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.image_counter)
  return image_counter_;
}
inline void ParsingImage::set_image_counter(::google::protobuf::uint32 value) {
  
  image_counter_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.image_counter)
}

// int32 perception_status = 12;
inline void ParsingImage::clear_perception_status() {
  perception_status_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::perception_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.perception_status)
  return perception_status_;
}
inline void ParsingImage::set_perception_status(::google::protobuf::int32 value) {
  
  perception_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.perception_status)
}

// int64 bypass_time_diff = 13;
inline void ParsingImage::clear_bypass_time_diff() {
  bypass_time_diff_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ParsingImage::bypass_time_diff() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.bypass_time_diff)
  return bypass_time_diff_;
}
inline void ParsingImage::set_bypass_time_diff(::google::protobuf::int64 value) {
  
  bypass_time_diff_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.bypass_time_diff)
}

// int32 compression_format = 14;
inline void ParsingImage::clear_compression_format() {
  compression_format_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::compression_format() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.compression_format)
  return compression_format_;
}
inline void ParsingImage::set_compression_format(::google::protobuf::int32 value) {
  
  compression_format_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.compression_format)
}

// int32 status = 15;
inline void ParsingImage::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.status)
  return status_;
}
inline void ParsingImage::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.status)
}

// repeated .autodrive.workflow.proto.perception_base.RoiMap roi_map = 16;
inline int ParsingImage::roi_map_size() const {
  return roi_map_.size();
}
inline const ::autodrive::workflow::proto::perception_base::RoiMap& ParsingImage::roi_map(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.roi_map)
  return roi_map_.Get(index);
}
inline ::autodrive::workflow::proto::perception_base::RoiMap* ParsingImage::mutable_roi_map(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingImage.roi_map)
  return roi_map_.Mutable(index);
}
inline ::autodrive::workflow::proto::perception_base::RoiMap* ParsingImage::add_roi_map() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ParsingImage.roi_map)
  return roi_map_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::RoiMap >*
ParsingImage::mutable_roi_map() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ParsingImage.roi_map)
  return &roi_map_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::RoiMap >&
ParsingImage::roi_map() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ParsingImage.roi_map)
  return roi_map_;
}

// int32 perception_mode = 17;
inline void ParsingImage::clear_perception_mode() {
  perception_mode_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::perception_mode() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.perception_mode)
  return perception_mode_;
}
inline void ParsingImage::set_perception_mode(::google::protobuf::int32 value) {
  
  perception_mode_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.perception_mode)
}

// int32 postprocessor_status = 18;
inline void ParsingImage::clear_postprocessor_status() {
  postprocessor_status_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::postprocessor_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.postprocessor_status)
  return postprocessor_status_;
}
inline void ParsingImage::set_postprocessor_status(::google::protobuf::int32 value) {
  
  postprocessor_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.postprocessor_status)
}

// int32 frame_id = 19;
inline void ParsingImage::clear_frame_id() {
  frame_id_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::frame_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.frame_id)
  return frame_id_;
}
inline void ParsingImage::set_frame_id(::google::protobuf::int32 value) {
  
  frame_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.frame_id)
}

// int32 step = 20;
inline void ParsingImage::clear_step() {
  step_ = 0;
}
inline ::google::protobuf::int32 ParsingImage::step() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.step)
  return step_;
}
inline void ParsingImage::set_step(::google::protobuf::int32 value) {
  
  step_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.step)
}

// int64 time_stamp_us = 21;
inline void ParsingImage::clear_time_stamp_us() {
  time_stamp_us_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ParsingImage::time_stamp_us() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.time_stamp_us)
  return time_stamp_us_;
}
inline void ParsingImage::set_time_stamp_us(::google::protobuf::int64 value) {
  
  time_stamp_us_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.time_stamp_us)
}

// uint64 hw_time_stamp = 22;
inline void ParsingImage::clear_hw_time_stamp() {
  hw_time_stamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ParsingImage::hw_time_stamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.hw_time_stamp)
  return hw_time_stamp_;
}
inline void ParsingImage::set_hw_time_stamp(::google::protobuf::uint64 value) {
  
  hw_time_stamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.hw_time_stamp)
}

// int64 mcu_time_diff = 23;
inline void ParsingImage::clear_mcu_time_diff() {
  mcu_time_diff_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ParsingImage::mcu_time_diff() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.mcu_time_diff)
  return mcu_time_diff_;
}
inline void ParsingImage::set_mcu_time_diff(::google::protobuf::int64 value) {
  
  mcu_time_diff_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.mcu_time_diff)
}

// int64 mcu_board_timediff = 24;
inline void ParsingImage::clear_mcu_board_timediff() {
  mcu_board_timediff_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ParsingImage::mcu_board_timediff() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImage.mcu_board_timediff)
  return mcu_board_timediff_;
}
inline void ParsingImage::set_mcu_board_timediff(::google::protobuf::int64 value) {
  
  mcu_board_timediff_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImage.mcu_board_timediff)
}

// -------------------------------------------------------------------

// CameraValidHeight

// int32 left_y = 1;
inline void CameraValidHeight::clear_left_y() {
  left_y_ = 0;
}
inline ::google::protobuf::int32 CameraValidHeight::left_y() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraValidHeight.left_y)
  return left_y_;
}
inline void CameraValidHeight::set_left_y(::google::protobuf::int32 value) {
  
  left_y_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraValidHeight.left_y)
}

// int32 right_y = 2;
inline void CameraValidHeight::clear_right_y() {
  right_y_ = 0;
}
inline ::google::protobuf::int32 CameraValidHeight::right_y() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraValidHeight.right_y)
  return right_y_;
}
inline void CameraValidHeight::set_right_y(::google::protobuf::int32 value) {
  
  right_y_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraValidHeight.right_y)
}

// -------------------------------------------------------------------

// VCSParam

// repeated float rotation = 1;
inline int VCSParam::rotation_size() const {
  return rotation_.size();
}
inline void VCSParam::clear_rotation() {
  rotation_.Clear();
}
inline float VCSParam::rotation(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VCSParam.rotation)
  return rotation_.Get(index);
}
inline void VCSParam::set_rotation(int index, float value) {
  rotation_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VCSParam.rotation)
}
inline void VCSParam::add_rotation(float value) {
  rotation_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.VCSParam.rotation)
}
inline const ::google::protobuf::RepeatedField< float >&
VCSParam::rotation() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.VCSParam.rotation)
  return rotation_;
}
inline ::google::protobuf::RepeatedField< float >*
VCSParam::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.VCSParam.rotation)
  return &rotation_;
}

// repeated float translation = 2;
inline int VCSParam::translation_size() const {
  return translation_.size();
}
inline void VCSParam::clear_translation() {
  translation_.Clear();
}
inline float VCSParam::translation(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.VCSParam.translation)
  return translation_.Get(index);
}
inline void VCSParam::set_translation(int index, float value) {
  translation_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.VCSParam.translation)
}
inline void VCSParam::add_translation(float value) {
  translation_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.VCSParam.translation)
}
inline const ::google::protobuf::RepeatedField< float >&
VCSParam::translation() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.VCSParam.translation)
  return translation_;
}
inline ::google::protobuf::RepeatedField< float >*
VCSParam::mutable_translation() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.VCSParam.translation)
  return &translation_;
}

// -------------------------------------------------------------------

// DistortParam

// repeated float param = 1;
inline int DistortParam::param_size() const {
  return param_.size();
}
inline void DistortParam::clear_param() {
  param_.Clear();
}
inline float DistortParam::param(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DistortParam.param)
  return param_.Get(index);
}
inline void DistortParam::set_param(int index, float value) {
  param_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DistortParam.param)
}
inline void DistortParam::add_param(float value) {
  param_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.DistortParam.param)
}
inline const ::google::protobuf::RepeatedField< float >&
DistortParam::param() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.DistortParam.param)
  return param_;
}
inline ::google::protobuf::RepeatedField< float >*
DistortParam::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.DistortParam.param)
  return &param_;
}

// -------------------------------------------------------------------

// CameraParam

// float focal_u = 1;
inline void CameraParam::clear_focal_u() {
  focal_u_ = 0;
}
inline float CameraParam::focal_u() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.focal_u)
  return focal_u_;
}
inline void CameraParam::set_focal_u(float value) {
  
  focal_u_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.focal_u)
}

// float focal_v = 2;
inline void CameraParam::clear_focal_v() {
  focal_v_ = 0;
}
inline float CameraParam::focal_v() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.focal_v)
  return focal_v_;
}
inline void CameraParam::set_focal_v(float value) {
  
  focal_v_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.focal_v)
}

// float center_u = 3;
inline void CameraParam::clear_center_u() {
  center_u_ = 0;
}
inline float CameraParam::center_u() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.center_u)
  return center_u_;
}
inline void CameraParam::set_center_u(float value) {
  
  center_u_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.center_u)
}

// float center_v = 4;
inline void CameraParam::clear_center_v() {
  center_v_ = 0;
}
inline float CameraParam::center_v() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.center_v)
  return center_v_;
}
inline void CameraParam::set_center_v(float value) {
  
  center_v_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.center_v)
}

// float camera_x = 5;
inline void CameraParam::clear_camera_x() {
  camera_x_ = 0;
}
inline float CameraParam::camera_x() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.camera_x)
  return camera_x_;
}
inline void CameraParam::set_camera_x(float value) {
  
  camera_x_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.camera_x)
}

// float camera_y = 6;
inline void CameraParam::clear_camera_y() {
  camera_y_ = 0;
}
inline float CameraParam::camera_y() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.camera_y)
  return camera_y_;
}
inline void CameraParam::set_camera_y(float value) {
  
  camera_y_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.camera_y)
}

// float camera_z = 7;
inline void CameraParam::clear_camera_z() {
  camera_z_ = 0;
}
inline float CameraParam::camera_z() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.camera_z)
  return camera_z_;
}
inline void CameraParam::set_camera_z(float value) {
  
  camera_z_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.camera_z)
}

// float pitch = 8;
inline void CameraParam::clear_pitch() {
  pitch_ = 0;
}
inline float CameraParam::pitch() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.pitch)
  return pitch_;
}
inline void CameraParam::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.pitch)
}

// float yaw = 9;
inline void CameraParam::clear_yaw() {
  yaw_ = 0;
}
inline float CameraParam::yaw() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.yaw)
  return yaw_;
}
inline void CameraParam::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.yaw)
}

// float roll = 10;
inline void CameraParam::clear_roll() {
  roll_ = 0;
}
inline float CameraParam::roll() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.roll)
  return roll_;
}
inline void CameraParam::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.roll)
}

// int32 type = 11;
inline void CameraParam::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 CameraParam::type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.type)
  return type_;
}
inline void CameraParam::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.type)
}

// float fov = 12;
inline void CameraParam::clear_fov() {
  fov_ = 0;
}
inline float CameraParam::fov() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.fov)
  return fov_;
}
inline void CameraParam::set_fov(float value) {
  
  fov_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.fov)
}

// int32 version = 13;
inline void CameraParam::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 CameraParam::version() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.version)
  return version_;
}
inline void CameraParam::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.version)
}

// .autodrive.workflow.proto.ParsingCalibrationStatus cali_status = 14;
inline void CameraParam::clear_cali_status() {
  cali_status_ = 0;
}
inline ::autodrive::workflow::proto::ParsingCalibrationStatus CameraParam::cali_status() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.cali_status)
  return static_cast< ::autodrive::workflow::proto::ParsingCalibrationStatus >(cali_status_);
}
inline void CameraParam::set_cali_status(::autodrive::workflow::proto::ParsingCalibrationStatus value) {
  
  cali_status_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.cali_status)
}

// .autodrive.workflow.proto.CameraValidHeight valid_height = 15;
inline bool CameraParam::has_valid_height() const {
  return this != internal_default_instance() && valid_height_ != NULL;
}
inline void CameraParam::clear_valid_height() {
  if (GetArenaNoVirtual() == NULL && valid_height_ != NULL) {
    delete valid_height_;
  }
  valid_height_ = NULL;
}
inline const ::autodrive::workflow::proto::CameraValidHeight& CameraParam::valid_height() const {
  const ::autodrive::workflow::proto::CameraValidHeight* p = valid_height_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.valid_height)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::CameraValidHeight*>(
      &::autodrive::workflow::proto::_CameraValidHeight_default_instance_);
}
inline ::autodrive::workflow::proto::CameraValidHeight* CameraParam::release_valid_height() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.CameraParam.valid_height)
  
  ::autodrive::workflow::proto::CameraValidHeight* temp = valid_height_;
  valid_height_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::CameraValidHeight* CameraParam::mutable_valid_height() {
  
  if (valid_height_ == NULL) {
    valid_height_ = new ::autodrive::workflow::proto::CameraValidHeight;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.CameraParam.valid_height)
  return valid_height_;
}
inline void CameraParam::set_allocated_valid_height(::autodrive::workflow::proto::CameraValidHeight* valid_height) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete valid_height_;
  }
  if (valid_height) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      valid_height = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, valid_height, submessage_arena);
    }
    
  } else {
    
  }
  valid_height_ = valid_height;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.CameraParam.valid_height)
}

// .autodrive.workflow.proto.DistortParam distort = 16;
inline bool CameraParam::has_distort() const {
  return this != internal_default_instance() && distort_ != NULL;
}
inline void CameraParam::clear_distort() {
  if (GetArenaNoVirtual() == NULL && distort_ != NULL) {
    delete distort_;
  }
  distort_ = NULL;
}
inline const ::autodrive::workflow::proto::DistortParam& CameraParam::distort() const {
  const ::autodrive::workflow::proto::DistortParam* p = distort_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.distort)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::DistortParam*>(
      &::autodrive::workflow::proto::_DistortParam_default_instance_);
}
inline ::autodrive::workflow::proto::DistortParam* CameraParam::release_distort() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.CameraParam.distort)
  
  ::autodrive::workflow::proto::DistortParam* temp = distort_;
  distort_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::DistortParam* CameraParam::mutable_distort() {
  
  if (distort_ == NULL) {
    distort_ = new ::autodrive::workflow::proto::DistortParam;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.CameraParam.distort)
  return distort_;
}
inline void CameraParam::set_allocated_distort(::autodrive::workflow::proto::DistortParam* distort) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete distort_;
  }
  if (distort) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      distort = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, distort, submessage_arena);
    }
    
  } else {
    
  }
  distort_ = distort;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.CameraParam.distort)
}

// .autodrive.workflow.proto.VCSParam vcs = 17;
inline bool CameraParam::has_vcs() const {
  return this != internal_default_instance() && vcs_ != NULL;
}
inline void CameraParam::clear_vcs() {
  if (GetArenaNoVirtual() == NULL && vcs_ != NULL) {
    delete vcs_;
  }
  vcs_ = NULL;
}
inline const ::autodrive::workflow::proto::VCSParam& CameraParam::vcs() const {
  const ::autodrive::workflow::proto::VCSParam* p = vcs_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.vcs)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::VCSParam*>(
      &::autodrive::workflow::proto::_VCSParam_default_instance_);
}
inline ::autodrive::workflow::proto::VCSParam* CameraParam::release_vcs() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.CameraParam.vcs)
  
  ::autodrive::workflow::proto::VCSParam* temp = vcs_;
  vcs_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::VCSParam* CameraParam::mutable_vcs() {
  
  if (vcs_ == NULL) {
    vcs_ = new ::autodrive::workflow::proto::VCSParam;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.CameraParam.vcs)
  return vcs_;
}
inline void CameraParam::set_allocated_vcs(::autodrive::workflow::proto::VCSParam* vcs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vcs_;
  }
  if (vcs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vcs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vcs, submessage_arena);
    }
    
  } else {
    
  }
  vcs_ = vcs;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.CameraParam.vcs)
}

// .autodrive.workflow.proto.perception_base.CameraMatrix mat = 18;
inline bool CameraParam::has_mat() const {
  return this != internal_default_instance() && mat_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::CameraMatrix& CameraParam::mat() const {
  const ::autodrive::workflow::proto::perception_base::CameraMatrix* p = mat_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.mat)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::CameraMatrix*>(
      &::autodrive::workflow::proto::perception_base::_CameraMatrix_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::CameraMatrix* CameraParam::release_mat() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.CameraParam.mat)
  
  ::autodrive::workflow::proto::perception_base::CameraMatrix* temp = mat_;
  mat_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::CameraMatrix* CameraParam::mutable_mat() {
  
  if (mat_ == NULL) {
    mat_ = new ::autodrive::workflow::proto::perception_base::CameraMatrix;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.CameraParam.mat)
  return mat_;
}
inline void CameraParam::set_allocated_mat(::autodrive::workflow::proto::perception_base::CameraMatrix* mat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mat_);
  }
  if (mat) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mat, submessage_arena);
    }
    
  } else {
    
  }
  mat_ = mat;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.CameraParam.mat)
}

// int64 time_stamp = 19;
inline void CameraParam::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CameraParam::time_stamp() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.time_stamp)
  return time_stamp_;
}
inline void CameraParam::set_time_stamp(::google::protobuf::int64 value) {
  
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.time_stamp)
}

// int32 cam_id = 20;
inline void CameraParam::clear_cam_id() {
  cam_id_ = 0;
}
inline ::google::protobuf::int32 CameraParam::cam_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.cam_id)
  return cam_id_;
}
inline void CameraParam::set_cam_id(::google::protobuf::int32 value) {
  
  cam_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.cam_id)
}

// int32 frame_id = 21;
inline void CameraParam::clear_frame_id() {
  frame_id_ = 0;
}
inline ::google::protobuf::int32 CameraParam::frame_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.frame_id)
  return frame_id_;
}
inline void CameraParam::set_frame_id(::google::protobuf::int32 value) {
  
  frame_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.frame_id)
}

// int32 image_height = 22;
inline void CameraParam::clear_image_height() {
  image_height_ = 0;
}
inline ::google::protobuf::int32 CameraParam::image_height() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.image_height)
  return image_height_;
}
inline void CameraParam::set_image_height(::google::protobuf::int32 value) {
  
  image_height_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.image_height)
}

// int32 image_width = 23;
inline void CameraParam::clear_image_width() {
  image_width_ = 0;
}
inline ::google::protobuf::int32 CameraParam::image_width() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.image_width)
  return image_width_;
}
inline void CameraParam::set_image_width(::google::protobuf::int32 value) {
  
  image_width_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.image_width)
}

// int32 base_calib_done = 24;
inline void CameraParam::clear_base_calib_done() {
  base_calib_done_ = 0;
}
inline ::google::protobuf::int32 CameraParam::base_calib_done() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.base_calib_done)
  return base_calib_done_;
}
inline void CameraParam::set_base_calib_done(::google::protobuf::int32 value) {
  
  base_calib_done_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.base_calib_done)
}

// .autodrive.workflow.proto.CalibrationType calib_src = 25;
inline void CameraParam::clear_calib_src() {
  calib_src_ = 0;
}
inline ::autodrive::workflow::proto::CalibrationType CameraParam::calib_src() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.calib_src)
  return static_cast< ::autodrive::workflow::proto::CalibrationType >(calib_src_);
}
inline void CameraParam::set_calib_src(::autodrive::workflow::proto::CalibrationType value) {
  
  calib_src_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.calib_src)
}

// int64 calib_done_ts = 26;
inline void CameraParam::clear_calib_done_ts() {
  calib_done_ts_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CameraParam::calib_done_ts() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.CameraParam.calib_done_ts)
  return calib_done_ts_;
}
inline void CameraParam::set_calib_done_ts(::google::protobuf::int64 value) {
  
  calib_done_ts_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.CameraParam.calib_done_ts)
}

// -------------------------------------------------------------------

// ParsingColor

// uint32 b = 1;
inline void ParsingColor::clear_b() {
  b_ = 0u;
}
inline ::google::protobuf::uint32 ParsingColor::b() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingColor.b)
  return b_;
}
inline void ParsingColor::set_b(::google::protobuf::uint32 value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingColor.b)
}

// uint32 g = 2;
inline void ParsingColor::clear_g() {
  g_ = 0u;
}
inline ::google::protobuf::uint32 ParsingColor::g() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingColor.g)
  return g_;
}
inline void ParsingColor::set_g(::google::protobuf::uint32 value) {
  
  g_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingColor.g)
}

// uint32 r = 3;
inline void ParsingColor::clear_r() {
  r_ = 0u;
}
inline ::google::protobuf::uint32 ParsingColor::r() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingColor.r)
  return r_;
}
inline void ParsingColor::set_r(::google::protobuf::uint32 value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingColor.r)
}

// -------------------------------------------------------------------

// RuntimeModelInfo

// int32 model_id = 1;
inline void RuntimeModelInfo::clear_model_id() {
  model_id_ = 0;
}
inline ::google::protobuf::int32 RuntimeModelInfo::model_id() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RuntimeModelInfo.model_id)
  return model_id_;
}
inline void RuntimeModelInfo::set_model_id(::google::protobuf::int32 value) {
  
  model_id_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RuntimeModelInfo.model_id)
}

// string model_name = 2;
inline void RuntimeModelInfo::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RuntimeModelInfo::model_name() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.RuntimeModelInfo.model_name)
  return model_name_.GetNoArena();
}
inline void RuntimeModelInfo::set_model_name(const ::std::string& value) {
  
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.RuntimeModelInfo.model_name)
}
#if LANG_CXX11
inline void RuntimeModelInfo::set_model_name(::std::string&& value) {
  
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.RuntimeModelInfo.model_name)
}
#endif
inline void RuntimeModelInfo::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.RuntimeModelInfo.model_name)
}
inline void RuntimeModelInfo::set_model_name(const char* value, size_t size) {
  
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.RuntimeModelInfo.model_name)
}
inline ::std::string* RuntimeModelInfo::mutable_model_name() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.RuntimeModelInfo.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RuntimeModelInfo::release_model_name() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.RuntimeModelInfo.model_name)
  
  return model_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RuntimeModelInfo::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    
  } else {
    
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.RuntimeModelInfo.model_name)
}

// -------------------------------------------------------------------

// ParsingSetting

// .autodrive.workflow.proto.perception_base.Header header = 1;
inline bool ParsingSetting::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Header& ParsingSetting::header() const {
  const ::autodrive::workflow::proto::perception_base::Header* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Header*>(
      &::autodrive::workflow::proto::perception_base::_Header_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Header* ParsingSetting::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingSetting.header)
  
  ::autodrive::workflow::proto::perception_base::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Header* ParsingSetting::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::perception_base::Header;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingSetting.header)
  return header_;
}
inline void ParsingSetting::set_allocated_header(::autodrive::workflow::proto::perception_base::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingSetting.header)
}

// int32 parsing_type = 2;
inline void ParsingSetting::clear_parsing_type() {
  parsing_type_ = 0;
}
inline ::google::protobuf::int32 ParsingSetting::parsing_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.parsing_type)
  return parsing_type_;
}
inline void ParsingSetting::set_parsing_type(::google::protobuf::int32 value) {
  
  parsing_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingSetting.parsing_type)
}

// int32 parsing_channels = 3;
inline void ParsingSetting::clear_parsing_channels() {
  parsing_channels_ = 0;
}
inline ::google::protobuf::int32 ParsingSetting::parsing_channels() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.parsing_channels)
  return parsing_channels_;
}
inline void ParsingSetting::set_parsing_channels(::google::protobuf::int32 value) {
  
  parsing_channels_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingSetting.parsing_channels)
}

// repeated uint64 channel_labels = 4;
inline int ParsingSetting::channel_labels_size() const {
  return channel_labels_.size();
}
inline void ParsingSetting::clear_channel_labels() {
  channel_labels_.Clear();
}
inline ::google::protobuf::uint64 ParsingSetting::channel_labels(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.channel_labels)
  return channel_labels_.Get(index);
}
inline void ParsingSetting::set_channel_labels(int index, ::google::protobuf::uint64 value) {
  channel_labels_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingSetting.channel_labels)
}
inline void ParsingSetting::add_channel_labels(::google::protobuf::uint64 value) {
  channel_labels_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ParsingSetting.channel_labels)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ParsingSetting::channel_labels() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ParsingSetting.channel_labels)
  return channel_labels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ParsingSetting::mutable_channel_labels() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ParsingSetting.channel_labels)
  return &channel_labels_;
}

// repeated .autodrive.workflow.proto.ParsingColor channel_colors = 5;
inline int ParsingSetting::channel_colors_size() const {
  return channel_colors_.size();
}
inline void ParsingSetting::clear_channel_colors() {
  channel_colors_.Clear();
}
inline const ::autodrive::workflow::proto::ParsingColor& ParsingSetting::channel_colors(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.channel_colors)
  return channel_colors_.Get(index);
}
inline ::autodrive::workflow::proto::ParsingColor* ParsingSetting::mutable_channel_colors(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingSetting.channel_colors)
  return channel_colors_.Mutable(index);
}
inline ::autodrive::workflow::proto::ParsingColor* ParsingSetting::add_channel_colors() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ParsingSetting.channel_colors)
  return channel_colors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ParsingColor >*
ParsingSetting::mutable_channel_colors() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ParsingSetting.channel_colors)
  return &channel_colors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::ParsingColor >&
ParsingSetting::channel_colors() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ParsingSetting.channel_colors)
  return channel_colors_;
}

// repeated int32 freespace_channels = 6;
inline int ParsingSetting::freespace_channels_size() const {
  return freespace_channels_.size();
}
inline void ParsingSetting::clear_freespace_channels() {
  freespace_channels_.Clear();
}
inline ::google::protobuf::int32 ParsingSetting::freespace_channels(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.freespace_channels)
  return freespace_channels_.Get(index);
}
inline void ParsingSetting::set_freespace_channels(int index, ::google::protobuf::int32 value) {
  freespace_channels_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingSetting.freespace_channels)
}
inline void ParsingSetting::add_freespace_channels(::google::protobuf::int32 value) {
  freespace_channels_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ParsingSetting.freespace_channels)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ParsingSetting::freespace_channels() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ParsingSetting.freespace_channels)
  return freespace_channels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ParsingSetting::mutable_freespace_channels() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ParsingSetting.freespace_channels)
  return &freespace_channels_;
}

// repeated int32 boundspace_channels = 7;
inline int ParsingSetting::boundspace_channels_size() const {
  return boundspace_channels_.size();
}
inline void ParsingSetting::clear_boundspace_channels() {
  boundspace_channels_.Clear();
}
inline ::google::protobuf::int32 ParsingSetting::boundspace_channels(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.boundspace_channels)
  return boundspace_channels_.Get(index);
}
inline void ParsingSetting::set_boundspace_channels(int index, ::google::protobuf::int32 value) {
  boundspace_channels_.Set(index, value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingSetting.boundspace_channels)
}
inline void ParsingSetting::add_boundspace_channels(::google::protobuf::int32 value) {
  boundspace_channels_.Add(value);
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ParsingSetting.boundspace_channels)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ParsingSetting::boundspace_channels() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ParsingSetting.boundspace_channels)
  return boundspace_channels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ParsingSetting::mutable_boundspace_channels() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ParsingSetting.boundspace_channels)
  return &boundspace_channels_;
}

// .autodrive.workflow.proto.perception_base.Rect parsing_roi = 8;
inline bool ParsingSetting::has_parsing_roi() const {
  return this != internal_default_instance() && parsing_roi_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Rect& ParsingSetting::parsing_roi() const {
  const ::autodrive::workflow::proto::perception_base::Rect* p = parsing_roi_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.parsing_roi)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Rect*>(
      &::autodrive::workflow::proto::perception_base::_Rect_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Rect* ParsingSetting::release_parsing_roi() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingSetting.parsing_roi)
  
  ::autodrive::workflow::proto::perception_base::Rect* temp = parsing_roi_;
  parsing_roi_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Rect* ParsingSetting::mutable_parsing_roi() {
  
  if (parsing_roi_ == NULL) {
    parsing_roi_ = new ::autodrive::workflow::proto::perception_base::Rect;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingSetting.parsing_roi)
  return parsing_roi_;
}
inline void ParsingSetting::set_allocated_parsing_roi(::autodrive::workflow::proto::perception_base::Rect* parsing_roi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(parsing_roi_);
  }
  if (parsing_roi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parsing_roi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parsing_roi, submessage_arena);
    }
    
  } else {
    
  }
  parsing_roi_ = parsing_roi;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingSetting.parsing_roi)
}

// float parsing_scale = 9;
inline void ParsingSetting::clear_parsing_scale() {
  parsing_scale_ = 0;
}
inline float ParsingSetting::parsing_scale() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.parsing_scale)
  return parsing_scale_;
}
inline void ParsingSetting::set_parsing_scale(float value) {
  
  parsing_scale_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingSetting.parsing_scale)
}

// repeated .autodrive.workflow.proto.RuntimeModelInfo model_info = 10;
inline int ParsingSetting::model_info_size() const {
  return model_info_.size();
}
inline void ParsingSetting::clear_model_info() {
  model_info_.Clear();
}
inline const ::autodrive::workflow::proto::RuntimeModelInfo& ParsingSetting::model_info(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.model_info)
  return model_info_.Get(index);
}
inline ::autodrive::workflow::proto::RuntimeModelInfo* ParsingSetting::mutable_model_info(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingSetting.model_info)
  return model_info_.Mutable(index);
}
inline ::autodrive::workflow::proto::RuntimeModelInfo* ParsingSetting::add_model_info() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ParsingSetting.model_info)
  return model_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RuntimeModelInfo >*
ParsingSetting::mutable_model_info() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ParsingSetting.model_info)
  return &model_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::RuntimeModelInfo >&
ParsingSetting::model_info() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ParsingSetting.model_info)
  return model_info_;
}

// repeated .autodrive.workflow.proto.perception_base.Category categories = 11;
inline int ParsingSetting::categories_size() const {
  return categories_.size();
}
inline const ::autodrive::workflow::proto::perception_base::Category& ParsingSetting::categories(int index) const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingSetting.categories)
  return categories_.Get(index);
}
inline ::autodrive::workflow::proto::perception_base::Category* ParsingSetting::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingSetting.categories)
  return categories_.Mutable(index);
}
inline ::autodrive::workflow::proto::perception_base::Category* ParsingSetting::add_categories() {
  // @@protoc_insertion_point(field_add:autodrive.workflow.proto.ParsingSetting.categories)
  return categories_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >*
ParsingSetting::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:autodrive.workflow.proto.ParsingSetting.categories)
  return &categories_;
}
inline const ::google::protobuf::RepeatedPtrField< ::autodrive::workflow::proto::perception_base::Category >&
ParsingSetting::categories() const {
  // @@protoc_insertion_point(field_list:autodrive.workflow.proto.ParsingSetting.categories)
  return categories_;
}

// -------------------------------------------------------------------

// DepthSetting

// float scale_number = 1;
inline void DepthSetting::clear_scale_number() {
  scale_number_ = 0;
}
inline float DepthSetting::scale_number() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DepthSetting.scale_number)
  return scale_number_;
}
inline void DepthSetting::set_scale_number(float value) {
  
  scale_number_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DepthSetting.scale_number)
}

// float shift_scale = 2;
inline void DepthSetting::clear_shift_scale() {
  shift_scale_ = 0;
}
inline float DepthSetting::shift_scale() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DepthSetting.shift_scale)
  return shift_scale_;
}
inline void DepthSetting::set_shift_scale(float value) {
  
  shift_scale_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DepthSetting.shift_scale)
}

// uint32 mapping_type = 3;
inline void DepthSetting::clear_mapping_type() {
  mapping_type_ = 0u;
}
inline ::google::protobuf::uint32 DepthSetting::mapping_type() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DepthSetting.mapping_type)
  return mapping_type_;
}
inline void DepthSetting::set_mapping_type(::google::protobuf::uint32 value) {
  
  mapping_type_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DepthSetting.mapping_type)
}

// uint32 mapping_shift = 4;
inline void DepthSetting::clear_mapping_shift() {
  mapping_shift_ = 0u;
}
inline ::google::protobuf::uint32 DepthSetting::mapping_shift() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DepthSetting.mapping_shift)
  return mapping_shift_;
}
inline void DepthSetting::set_mapping_shift(::google::protobuf::uint32 value) {
  
  mapping_shift_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DepthSetting.mapping_shift)
}

// float confidence_scale = 5;
inline void DepthSetting::clear_confidence_scale() {
  confidence_scale_ = 0;
}
inline float DepthSetting::confidence_scale() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DepthSetting.confidence_scale)
  return confidence_scale_;
}
inline void DepthSetting::set_confidence_scale(float value) {
  
  confidence_scale_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DepthSetting.confidence_scale)
}

// float max_depth = 6;
inline void DepthSetting::clear_max_depth() {
  max_depth_ = 0;
}
inline float DepthSetting::max_depth() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DepthSetting.max_depth)
  return max_depth_;
}
inline void DepthSetting::set_max_depth(float value) {
  
  max_depth_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DepthSetting.max_depth)
}

// float min_depth = 7;
inline void DepthSetting::clear_min_depth() {
  min_depth_ = 0;
}
inline float DepthSetting::min_depth() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DepthSetting.min_depth)
  return min_depth_;
}
inline void DepthSetting::set_min_depth(float value) {
  
  min_depth_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DepthSetting.min_depth)
}

// float max_confidence = 8;
inline void DepthSetting::clear_max_confidence() {
  max_confidence_ = 0;
}
inline float DepthSetting::max_confidence() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DepthSetting.max_confidence)
  return max_confidence_;
}
inline void DepthSetting::set_max_confidence(float value) {
  
  max_confidence_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DepthSetting.max_confidence)
}

// float min_confidence = 9;
inline void DepthSetting::clear_min_confidence() {
  min_confidence_ = 0;
}
inline float DepthSetting::min_confidence() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DepthSetting.min_confidence)
  return min_confidence_;
}
inline void DepthSetting::set_min_confidence(float value) {
  
  min_confidence_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.DepthSetting.min_confidence)
}

// .autodrive.workflow.proto.CameraParam camera_param = 10;
inline bool DepthSetting::has_camera_param() const {
  return this != internal_default_instance() && camera_param_ != NULL;
}
inline void DepthSetting::clear_camera_param() {
  if (GetArenaNoVirtual() == NULL && camera_param_ != NULL) {
    delete camera_param_;
  }
  camera_param_ = NULL;
}
inline const ::autodrive::workflow::proto::CameraParam& DepthSetting::camera_param() const {
  const ::autodrive::workflow::proto::CameraParam* p = camera_param_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.DepthSetting.camera_param)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::CameraParam*>(
      &::autodrive::workflow::proto::_CameraParam_default_instance_);
}
inline ::autodrive::workflow::proto::CameraParam* DepthSetting::release_camera_param() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.DepthSetting.camera_param)
  
  ::autodrive::workflow::proto::CameraParam* temp = camera_param_;
  camera_param_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::CameraParam* DepthSetting::mutable_camera_param() {
  
  if (camera_param_ == NULL) {
    camera_param_ = new ::autodrive::workflow::proto::CameraParam;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.DepthSetting.camera_param)
  return camera_param_;
}
inline void DepthSetting::set_allocated_camera_param(::autodrive::workflow::proto::CameraParam* camera_param) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete camera_param_;
  }
  if (camera_param) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      camera_param = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, camera_param, submessage_arena);
    }
    
  } else {
    
  }
  camera_param_ = camera_param;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.DepthSetting.camera_param)
}

// -------------------------------------------------------------------

// ParsingImageData

// bytes data = 1;
inline void ParsingImageData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ParsingImageData::data() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImageData.data)
  return data_.GetNoArena();
}
inline void ParsingImageData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImageData.data)
}
#if LANG_CXX11
inline void ParsingImageData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:autodrive.workflow.proto.ParsingImageData.data)
}
#endif
inline void ParsingImageData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:autodrive.workflow.proto.ParsingImageData.data)
}
inline void ParsingImageData::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:autodrive.workflow.proto.ParsingImageData.data)
}
inline ::std::string* ParsingImageData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingImageData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsingImageData::release_data() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingImageData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsingImageData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingImageData.data)
}

// uint32 width = 2;
inline void ParsingImageData::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 ParsingImageData::width() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImageData.width)
  return width_;
}
inline void ParsingImageData::set_width(::google::protobuf::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImageData.width)
}

// uint32 height = 3;
inline void ParsingImageData::clear_height() {
  height_ = 0u;
}
inline ::google::protobuf::uint32 ParsingImageData::height() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImageData.height)
  return height_;
}
inline void ParsingImageData::set_height(::google::protobuf::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImageData.height)
}

// uint32 channel = 4;
inline void ParsingImageData::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 ParsingImageData::channel() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingImageData.channel)
  return channel_;
}
inline void ParsingImageData::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingImageData.channel)
}

// -------------------------------------------------------------------

// ParsingMsg

// .autodrive.workflow.proto.MsgHeader header = 1;
inline bool ParsingMsg::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::autodrive::workflow::proto::MsgHeader& ParsingMsg::header() const {
  const ::autodrive::workflow::proto::MsgHeader* p = header_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingMsg.header)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::MsgHeader*>(
      &::autodrive::workflow::proto::_MsgHeader_default_instance_);
}
inline ::autodrive::workflow::proto::MsgHeader* ParsingMsg::release_header() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingMsg.header)
  
  ::autodrive::workflow::proto::MsgHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::MsgHeader* ParsingMsg::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::autodrive::workflow::proto::MsgHeader;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingMsg.header)
  return header_;
}
inline void ParsingMsg::set_allocated_header(::autodrive::workflow::proto::MsgHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingMsg.header)
}

// .autodrive.workflow.proto.Error error = 2;
inline bool ParsingMsg::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::autodrive::workflow::proto::Error& ParsingMsg::error() const {
  const ::autodrive::workflow::proto::Error* p = error_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingMsg.error)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::Error*>(
      &::autodrive::workflow::proto::_Error_default_instance_);
}
inline ::autodrive::workflow::proto::Error* ParsingMsg::release_error() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingMsg.error)
  
  ::autodrive::workflow::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::Error* ParsingMsg::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::autodrive::workflow::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingMsg.error)
  return error_;
}
inline void ParsingMsg::set_allocated_error(::autodrive::workflow::proto::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingMsg.error)
}

// .autodrive.workflow.proto.ParsingImageData free_space = 3;
inline bool ParsingMsg::has_free_space() const {
  return this != internal_default_instance() && free_space_ != NULL;
}
inline void ParsingMsg::clear_free_space() {
  if (GetArenaNoVirtual() == NULL && free_space_ != NULL) {
    delete free_space_;
  }
  free_space_ = NULL;
}
inline const ::autodrive::workflow::proto::ParsingImageData& ParsingMsg::free_space() const {
  const ::autodrive::workflow::proto::ParsingImageData* p = free_space_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingMsg.free_space)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::ParsingImageData*>(
      &::autodrive::workflow::proto::_ParsingImageData_default_instance_);
}
inline ::autodrive::workflow::proto::ParsingImageData* ParsingMsg::release_free_space() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingMsg.free_space)
  
  ::autodrive::workflow::proto::ParsingImageData* temp = free_space_;
  free_space_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::ParsingImageData* ParsingMsg::mutable_free_space() {
  
  if (free_space_ == NULL) {
    free_space_ = new ::autodrive::workflow::proto::ParsingImageData;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingMsg.free_space)
  return free_space_;
}
inline void ParsingMsg::set_allocated_free_space(::autodrive::workflow::proto::ParsingImageData* free_space) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete free_space_;
  }
  if (free_space) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      free_space = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, free_space, submessage_arena);
    }
    
  } else {
    
  }
  free_space_ = free_space;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingMsg.free_space)
}

// .autodrive.workflow.proto.ParsingImageData feature_map = 4;
inline bool ParsingMsg::has_feature_map() const {
  return this != internal_default_instance() && feature_map_ != NULL;
}
inline void ParsingMsg::clear_feature_map() {
  if (GetArenaNoVirtual() == NULL && feature_map_ != NULL) {
    delete feature_map_;
  }
  feature_map_ = NULL;
}
inline const ::autodrive::workflow::proto::ParsingImageData& ParsingMsg::feature_map() const {
  const ::autodrive::workflow::proto::ParsingImageData* p = feature_map_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingMsg.feature_map)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::ParsingImageData*>(
      &::autodrive::workflow::proto::_ParsingImageData_default_instance_);
}
inline ::autodrive::workflow::proto::ParsingImageData* ParsingMsg::release_feature_map() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingMsg.feature_map)
  
  ::autodrive::workflow::proto::ParsingImageData* temp = feature_map_;
  feature_map_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::ParsingImageData* ParsingMsg::mutable_feature_map() {
  
  if (feature_map_ == NULL) {
    feature_map_ = new ::autodrive::workflow::proto::ParsingImageData;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingMsg.feature_map)
  return feature_map_;
}
inline void ParsingMsg::set_allocated_feature_map(::autodrive::workflow::proto::ParsingImageData* feature_map) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete feature_map_;
  }
  if (feature_map) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature_map = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature_map, submessage_arena);
    }
    
  } else {
    
  }
  feature_map_ = feature_map;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingMsg.feature_map)
}

// .autodrive.workflow.proto.RleCompressedData rle_parsing_compressed = 5;
inline bool ParsingMsg::has_rle_parsing_compressed() const {
  return this != internal_default_instance() && rle_parsing_compressed_ != NULL;
}
inline const ::autodrive::workflow::proto::RleCompressedData& ParsingMsg::rle_parsing_compressed() const {
  const ::autodrive::workflow::proto::RleCompressedData* p = rle_parsing_compressed_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingMsg.rle_parsing_compressed)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::RleCompressedData*>(
      &::autodrive::workflow::proto::_RleCompressedData_default_instance_);
}
inline ::autodrive::workflow::proto::RleCompressedData* ParsingMsg::release_rle_parsing_compressed() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingMsg.rle_parsing_compressed)
  
  ::autodrive::workflow::proto::RleCompressedData* temp = rle_parsing_compressed_;
  rle_parsing_compressed_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::RleCompressedData* ParsingMsg::mutable_rle_parsing_compressed() {
  
  if (rle_parsing_compressed_ == NULL) {
    rle_parsing_compressed_ = new ::autodrive::workflow::proto::RleCompressedData;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingMsg.rle_parsing_compressed)
  return rle_parsing_compressed_;
}
inline void ParsingMsg::set_allocated_rle_parsing_compressed(::autodrive::workflow::proto::RleCompressedData* rle_parsing_compressed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rle_parsing_compressed_);
  }
  if (rle_parsing_compressed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rle_parsing_compressed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rle_parsing_compressed, submessage_arena);
    }
    
  } else {
    
  }
  rle_parsing_compressed_ = rle_parsing_compressed;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingMsg.rle_parsing_compressed)
}

// float scale = 6;
inline void ParsingMsg::clear_scale() {
  scale_ = 0;
}
inline float ParsingMsg::scale() const {
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingMsg.scale)
  return scale_;
}
inline void ParsingMsg::set_scale(float value) {
  
  scale_ = value;
  // @@protoc_insertion_point(field_set:autodrive.workflow.proto.ParsingMsg.scale)
}

// .autodrive.workflow.proto.perception_base.Rect roi_output = 7;
inline bool ParsingMsg::has_roi_output() const {
  return this != internal_default_instance() && roi_output_ != NULL;
}
inline const ::autodrive::workflow::proto::perception_base::Rect& ParsingMsg::roi_output() const {
  const ::autodrive::workflow::proto::perception_base::Rect* p = roi_output_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingMsg.roi_output)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::perception_base::Rect*>(
      &::autodrive::workflow::proto::perception_base::_Rect_default_instance_);
}
inline ::autodrive::workflow::proto::perception_base::Rect* ParsingMsg::release_roi_output() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingMsg.roi_output)
  
  ::autodrive::workflow::proto::perception_base::Rect* temp = roi_output_;
  roi_output_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::perception_base::Rect* ParsingMsg::mutable_roi_output() {
  
  if (roi_output_ == NULL) {
    roi_output_ = new ::autodrive::workflow::proto::perception_base::Rect;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingMsg.roi_output)
  return roi_output_;
}
inline void ParsingMsg::set_allocated_roi_output(::autodrive::workflow::proto::perception_base::Rect* roi_output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roi_output_);
  }
  if (roi_output) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roi_output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roi_output, submessage_arena);
    }
    
  } else {
    
  }
  roi_output_ = roi_output;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingMsg.roi_output)
}

// .autodrive.workflow.proto.ParsingImage image = 8;
inline bool ParsingMsg::has_image() const {
  return this != internal_default_instance() && image_ != NULL;
}
inline void ParsingMsg::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) {
    delete image_;
  }
  image_ = NULL;
}
inline const ::autodrive::workflow::proto::ParsingImage& ParsingMsg::image() const {
  const ::autodrive::workflow::proto::ParsingImage* p = image_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingMsg.image)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::ParsingImage*>(
      &::autodrive::workflow::proto::_ParsingImage_default_instance_);
}
inline ::autodrive::workflow::proto::ParsingImage* ParsingMsg::release_image() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingMsg.image)
  
  ::autodrive::workflow::proto::ParsingImage* temp = image_;
  image_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::ParsingImage* ParsingMsg::mutable_image() {
  
  if (image_ == NULL) {
    image_ = new ::autodrive::workflow::proto::ParsingImage;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingMsg.image)
  return image_;
}
inline void ParsingMsg::set_allocated_image(::autodrive::workflow::proto::ParsingImage* image) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete image_;
  }
  if (image) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingMsg.image)
}

// .autodrive.workflow.proto.ParsingSetting parsing_setting = 9;
inline bool ParsingMsg::has_parsing_setting() const {
  return this != internal_default_instance() && parsing_setting_ != NULL;
}
inline void ParsingMsg::clear_parsing_setting() {
  if (GetArenaNoVirtual() == NULL && parsing_setting_ != NULL) {
    delete parsing_setting_;
  }
  parsing_setting_ = NULL;
}
inline const ::autodrive::workflow::proto::ParsingSetting& ParsingMsg::parsing_setting() const {
  const ::autodrive::workflow::proto::ParsingSetting* p = parsing_setting_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingMsg.parsing_setting)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::ParsingSetting*>(
      &::autodrive::workflow::proto::_ParsingSetting_default_instance_);
}
inline ::autodrive::workflow::proto::ParsingSetting* ParsingMsg::release_parsing_setting() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingMsg.parsing_setting)
  
  ::autodrive::workflow::proto::ParsingSetting* temp = parsing_setting_;
  parsing_setting_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::ParsingSetting* ParsingMsg::mutable_parsing_setting() {
  
  if (parsing_setting_ == NULL) {
    parsing_setting_ = new ::autodrive::workflow::proto::ParsingSetting;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingMsg.parsing_setting)
  return parsing_setting_;
}
inline void ParsingMsg::set_allocated_parsing_setting(::autodrive::workflow::proto::ParsingSetting* parsing_setting) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parsing_setting_;
  }
  if (parsing_setting) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parsing_setting = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parsing_setting, submessage_arena);
    }
    
  } else {
    
  }
  parsing_setting_ = parsing_setting;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingMsg.parsing_setting)
}

// .autodrive.workflow.proto.DepthSetting depth_setting = 10;
inline bool ParsingMsg::has_depth_setting() const {
  return this != internal_default_instance() && depth_setting_ != NULL;
}
inline void ParsingMsg::clear_depth_setting() {
  if (GetArenaNoVirtual() == NULL && depth_setting_ != NULL) {
    delete depth_setting_;
  }
  depth_setting_ = NULL;
}
inline const ::autodrive::workflow::proto::DepthSetting& ParsingMsg::depth_setting() const {
  const ::autodrive::workflow::proto::DepthSetting* p = depth_setting_;
  // @@protoc_insertion_point(field_get:autodrive.workflow.proto.ParsingMsg.depth_setting)
  return p != NULL ? *p : *reinterpret_cast<const ::autodrive::workflow::proto::DepthSetting*>(
      &::autodrive::workflow::proto::_DepthSetting_default_instance_);
}
inline ::autodrive::workflow::proto::DepthSetting* ParsingMsg::release_depth_setting() {
  // @@protoc_insertion_point(field_release:autodrive.workflow.proto.ParsingMsg.depth_setting)
  
  ::autodrive::workflow::proto::DepthSetting* temp = depth_setting_;
  depth_setting_ = NULL;
  return temp;
}
inline ::autodrive::workflow::proto::DepthSetting* ParsingMsg::mutable_depth_setting() {
  
  if (depth_setting_ == NULL) {
    depth_setting_ = new ::autodrive::workflow::proto::DepthSetting;
  }
  // @@protoc_insertion_point(field_mutable:autodrive.workflow.proto.ParsingMsg.depth_setting)
  return depth_setting_;
}
inline void ParsingMsg::set_allocated_depth_setting(::autodrive::workflow::proto::DepthSetting* depth_setting) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete depth_setting_;
  }
  if (depth_setting) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      depth_setting = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, depth_setting, submessage_arena);
    }
    
  } else {
    
  }
  depth_setting_ = depth_setting;
  // @@protoc_insertion_point(field_set_allocated:autodrive.workflow.proto.ParsingMsg.depth_setting)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace workflow
}  // namespace autodrive

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::autodrive::workflow::proto::CompressionFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::CompressionFormat>() {
  return ::autodrive::workflow::proto::CompressionFormat_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ImageFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ImageFormat>() {
  return ::autodrive::workflow::proto::ImageFormat_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ParsingFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ParsingFormat>() {
  return ::autodrive::workflow::proto::ParsingFormat_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::IPMSelect> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::IPMSelect>() {
  return ::autodrive::workflow::proto::IPMSelect_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::PerceptionStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::PerceptionStatus>() {
  return ::autodrive::workflow::proto::PerceptionStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ImageStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ImageStatus>() {
  return ::autodrive::workflow::proto::ImageStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::CameraType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::CameraType>() {
  return ::autodrive::workflow::proto::CameraType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::CameraVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::CameraVersion>() {
  return ::autodrive::workflow::proto::CameraVersion_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ParsingCalibrationStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ParsingCalibrationStatus>() {
  return ::autodrive::workflow::proto::ParsingCalibrationStatus_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::CalibrationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::CalibrationType>() {
  return ::autodrive::workflow::proto::CalibrationType_descriptor();
}
template <> struct is_proto_enum< ::autodrive::workflow::proto::ParsingType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::autodrive::workflow::proto::ParsingType>() {
  return ::autodrive::workflow::proto::ParsingType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_parsing_2eproto__INCLUDED
